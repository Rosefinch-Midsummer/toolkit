<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mdbook Template</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">开发工具</li><li class="chapter-item expanded "><a href="Shell工具和脚本.html"><strong aria-hidden="true">1.</strong> Shell Tools and Scripting</a></li><li class="chapter-item expanded "><a href="编辑器Vim.html"><strong aria-hidden="true">2.</strong> Editors (Vim)</a></li><li class="chapter-item expanded "><a href="数据整理.html"><strong aria-hidden="true">3.</strong> Data Wrangling</a></li><li class="chapter-item expanded "><a href="命令行环境.html"><strong aria-hidden="true">4.</strong> Command-line Environment</a></li><li class="chapter-item expanded "><a href="版本控制Git.html"><strong aria-hidden="true">5.</strong> Version Control (Git)</a></li><li class="chapter-item expanded "><a href="调试及性能分析.html"><strong aria-hidden="true">6.</strong> Debugging and Profiling</a></li><li class="chapter-item expanded "><a href="元编程.html"><strong aria-hidden="true">7.</strong> Metaprogramming</a></li><li class="chapter-item expanded "><a href="安全与密码学.html"><strong aria-hidden="true">8.</strong> Security and Cryptography</a></li><li class="chapter-item expanded affix "><li class="part-title">非开发实用工具</li><li class="chapter-item expanded "><a href="大杂烩.html"><strong aria-hidden="true">9.</strong> Potpourri</a></li><li class="chapter-item expanded "><a href="问答.html"><strong aria-hidden="true">10.</strong> Q&A</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mdbook Template</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>本仓库大部分内容来自MIT<a href="https://missing.csail.mit.edu/">计算机教育中缺失的一课</a>。</p>
<p><a href="https://csdiy.wiki/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/MIT-Missing-Semester/">MIT-Missing-Semester</a> 这门课覆盖了这些工具中绝大部分，而且有相当详细的使用指导，强烈建议小白学习。不过需要注意的一点是，在课程中会不时提到一些与开发流程相关的术语。因此推荐至少在学完计算机导论级别的课程之后进行学习。</p>
<h1 id="the-missing-semester-of-your-cs-education-中文版"><a class="header" href="#the-missing-semester-of-your-cs-education-中文版">The Missing Semester of Your CS Education 中文版</a></h1>
<p><a href="https://missing-semester-cn.github.io/">中文版网址</a></p>
<p>大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何精通工具这一主题则往往会留给学生自行探索。在这个系列课程中，我们讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等。学生在他们受教育阶段就会和这些工具朝夕相处（在他们的职业生涯中更是这样）。</p>
<p>因此，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们是非常有必要的。</p>
<p>精通这些工具不仅可以帮助您更快的使用工具完成任务，并且可以帮助您解决在之前看来似乎无比复杂的问题。</p>
<p>关于 <a href="https://missing-semester-cn.github.io/about/">开设此课程的动机</a>。</p>
<h1 id="日程"><a class="header" href="#日程">日程<img src="https://img.shields.io/badge/%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4-2021--04--24-blue" alt="" /></a></h1>
<ul>
<li><strong>1/13</strong>: <a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/14</strong>: <a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//shell-tools-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/15</strong>: <a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim)</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//editors-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/16</strong>: <a href="https://missing-semester-cn.github.io/2020/data-wrangling/">数据整理</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//data-wrangling-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/21</strong>: <a href="https://missing-semester-cn.github.io/2020/command-line/">命令行环境</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//command-line-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/22</strong>: <a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git)</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//version-control-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/23</strong>: <a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//debugging-profiling-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/27</strong>: <a href="https://missing-semester-cn.github.io/2020/metaprogramming/">元编程</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//metaprogramming-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/28</strong>: <a href="https://missing-semester-cn.github.io/2020/security/">安全和密码学</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//security-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/29</strong>: <a href="https://missing-semester-cn.github.io/2020/potpourri/">大杂烩</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Solution-%E2%9C%98-orange" alt="" /></li>
<li><strong>1/30</strong>: <a href="https://missing-semester-cn.github.io/2020/qa/">提问&amp;回答</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Solution-%E2%9C%98-orange" alt="" /></li>
</ul>
<p>讲座视频可以在 <a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">YouTube</a> 上找到。</p>
<h1 id="开设此课程的动机"><a class="header" href="#开设此课程的动机">开设此课程的动机</a></h1>
<p>在传统的计算机科学课程中，从操作系统、编程语言到机器学习，这些高大上课程和主题已经非常多了。 然而有一个至关重要的主题却很少被专门讲授，而是留给学生们自己去探索。 这部分内容就是：精通工具。</p>
<p>这些年，我们在麻省理工学院参与了许多课程的助教活动，过程当中愈发意识到很多学生对于工具的了解知之甚少。 计算机设计的初衷就是任务自动化，然而学生们却常常陷在大量的重复任务中，或者无法完全发挥出诸如 版本控制、文本编辑器等工具的强大作用。效率低下和浪费时间还是其次，更糟糕的是，这还可能导致数据丢失或 无法完成某些特定任务。</p>
<p>这些主题不是大学课程的一部分：学生一直都不知道如何使用这些工具，或者说，至少是不知道如何高效 地使用，因此浪费了时间和精力在本来可以更简单的任务上。标准的计算机科学课程缺少了这门能让计算 变得更简捷的关键课程。</p>
<h1 id="the-missing-semester-of-your-cs-education"><a class="header" href="#the-missing-semester-of-your-cs-education">The missing semester of your CS education</a></h1>
<p>为了解决这个问题，我们开设了一个课程，涵盖各项对成为高效率计算机科学家或程序员至关重要的 主题。这个课程实用且具有很强的实践性，提供了各种能够立即广泛应用解决问题的趁手工具指导。 该课在 2020 年 1 月“独立活动期”开设，为期一个月，是学生开办的短期课程。虽然该课程针对 麻省理工学院，但我们公开提供了全部课程的录制视频与相关资料。</p>
<p>如果该课程适合你，那么以下还有一些具体的课程示例：</p>
<h2 id="命令行与-shell-工具"><a class="header" href="#命令行与-shell-工具">命令行与 shell 工具</a></h2>
<p>如何使用别名、脚本和构建系统来自动化执行通用重复的任务。不再总是从文档中拷贝粘贴 命令。不要再“逐个执行这 15 个命令”，不要再“你忘了执行这个命令”、“你忘了传那个 参数”，类似的对话不要再有了。</p>
<p>例如，快速搜索历史记录可以节省大量时间。在下面这个示例中，我们展示了如何通过<code>convert</code>命令 在历史记录中跳转的一些技巧。</p>
<h2 id="版本控制"><a class="header" href="#版本控制">版本控制</a></h2>
<p>如何<strong>正确地</strong>使用版本控制，利用它避免尴尬的情况发生。与他人协作，并且能够快速定位 有问题的提交 不再大量注释代码。不再为解决 bug 而找遍所有代码。不再“我去，刚才是删了有用的代码？！”。 我们将教你如何通过拉取请求来为他人的项目贡献代码。</p>
<p>下面这个示例中，我们使用<code>git bisect</code>来定位哪个提交破坏了单元测试，并且通过<code>git revert</code>来进行修复。</p>
<h2 id="文本编辑"><a class="header" href="#文本编辑">文本编辑</a></h2>
<p>不论是本地还是远程，如何通过命令行高效地编辑文件，并且充分利用编辑器特性。不再来回复制 文件。不再重复编辑文件。</p>
<p>Vim 的宏是它最好的特性之一，在下面这个示例中，我们使用嵌套的 Vim 宏快速地将 html 表格转换成了 csv 格式。</p>
<h2 id="远程服务器"><a class="header" href="#远程服务器">远程服务器</a></h2>
<p>使用 SSH 密钥连接远程机器进行工作时如何保持连接，并且让终端能够复用。不再为了仅执行个别命令 总是打开许多命令行终端。不再每次连接都总输入密码。不再因为网络断开或必须重启笔记本时 就丢失全部上下文。</p>
<p>以下示例，我们使用<code>tmux</code>来保持远程服务器的会话存在，并使用<code>mosh</code>来支持网络漫游和断开连接。</p>
<h2 id="查找文件"><a class="header" href="#查找文件">查找文件</a></h2>
<p>如何快速查找你需要的文件。不再挨个点击项目中的文件，直到找到你所需的代码。</p>
<p>以下示例，我们通过<code>fd</code>快速查找文件，通过<code>rg</code>找代码片段。我们也用到了<code>fasd</code>快速<code>cd</code>并<code>vim</code>最近/常用的文件/文件夹。</p>
<h2 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h2>
<p>如何通过命令行直接轻松快速地修改、查看、解析、绘制和计算数据和文件。不再从日志文件拷贝 粘贴。不再手动统计数据。不再用电子表格画图。</p>
<h2 id="虚拟机"><a class="header" href="#虚拟机">虚拟机</a></h2>
<p>如何使用虚拟机尝试新操作系统，隔离无关的项目，并且保持宿主机整洁。不再因为做安全实验而 意外损坏你的计算机。不再有大量随机安装的不同版本软件包。</p>
<h2 id="安全"><a class="header" href="#安全">安全</a></h2>
<p>如何在不泄露隐私的情况下畅游互联网。不再抓破脑袋想符合自己疯狂规则的密码。不再连接不安全 的开放 WiFi 网络。不再传输未加密的信息。</p>
<h1 id="结论"><a class="header" href="#结论">结论</a></h1>
<p>这 12 节课将包括但不限于以上内容，同时每堂课都提供了能帮助你熟悉这些工具的练手小测验。如果不能 等到一月，你也可以看下<a href="https://hacker-tools.github.io/lectures/">黑客工具</a>，这是我们去年的 试讲。它是本课程的前身，包含许多相同的主题。</p>
<p>无论面对面还是远程在线，欢迎你的参与。</p>
<p>Happy hacking,<br />
Anish, Jose, and Jon</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shell工具和脚本"><a class="header" href="#shell工具和脚本">Shell工具和脚本</a></h1>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell%E5%85%A5%E9%97%A8">Shell入门</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E6%98%AF%E4%BB%80%E4%B9%88">shell 是什么？</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E4%BD%BF%E7%94%A8-shell">使用 shell</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E5%9C%A8shell%E4%B8%AD%E5%AF%BC%E8%88%AA">在shell中导航</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E9%99%84%E5%BD%95%E5%A4%84%E7%90%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">附录处理目录的常用命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E9%99%84%E5%BD%95cd%E5%91%BD%E4%BB%A4">附录cd命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E9%97%B4%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5">在程序间创建连接</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%85%A8%E9%9D%A2%E5%8F%88%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%B7%A5%E5%85%B7">一个功能全面又强大的工具</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%8E%A5%E4%B8%8B%E6%9D%A5">接下来…..</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#solution-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%A7%88%E4%B8%8E-shell">Solution-课程概览与 shell</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC">Shell 工具和脚本</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E8%84%9A%E6%9C%AC">Shell 脚本</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E5%B7%A5%E5%85%B7">Shell 工具</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">查看命令如何使用</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6">查找文件</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81">查找代码</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE-shell-%E5%91%BD%E4%BB%A4">查找 shell 命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%BC%E8%88%AA">文件夹导航</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-1">课后练习</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#solution-shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC">Solution-Shell 工具和脚本</a></li>
</ul>
<h1 id="shell入门"><a class="header" href="#shell入门">Shell入门</a></h1>
<h2 id="shell-是什么"><a class="header" href="#shell-是什么">shell 是什么？</a></h2>
<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>
<p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。 这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开shell <em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>
<h2 id="使用-shell"><a class="header" href="#使用-shell">使用 shell</a></h2>
<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>
<pre><code>missing:~$ 
</code></pre>
<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（”current working directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。 <code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入命令 ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p>
<pre><code>missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
</code></pre>
<p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递参数 ：</p>
<pre><code>missing:~$ echo hello
hello
</code></pre>
<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号、双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询环境变量<code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p>
<pre><code>missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/usr/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用 <code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序。</p>
<h2 id="在shell中导航"><a class="header" href="#在shell中导航">在shell中导航</a></h2>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： <code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p>
<pre><code class="language-bash">missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
</code></pre>
<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>
<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>
<pre><code>missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
</code></pre>
<p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p>
<pre><code>  -l                         use a long listing format
</code></pre>
<pre><code>missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
</code></pre>
<p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示 <code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。 （<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。</p>
<pre><code>ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;
                               e.g., '--block-size=M'; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
  -C                         list entries by columns
      --color[=WHEN]         colorize the output; WHEN can be 'always' (default
                               if omitted), 'auto', or 'never'; more info below
  -d, --directory            list directories themselves, not their contents
  -D, --dired                generate output designed for Emacs' dired mode
  -f                         do not sort, enable -aU, disable -ls --color
  -F, --classify             append indicator (one of */=&gt;@|) to entries
      --file-type            likewise, except do not append '*'
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            like -l --time-style=full-iso
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -G, --no-group             in a long listing, don't print group names
  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.
      --si                   likewise, but use powers of 1000 not 1024
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow each command line symbolic link
                               that points to a directory
      --hide=PATTERN         do not list implied entries matching shell PATTERN
                               (overridden by -a or -A)
      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'
                               (default if omitted), 'auto', or 'never'
      --indicator-style=WORD  append indicator with style WORD to entry names:
                               none (default), slash (-p),
                               file-type (--file-type), classify (-F)
  -i, --inode                print the index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -k, --kibibytes            default to 1024-byte blocks for disk usage;
                               used only with -s and per directory totals
  -l                         use a long listing format
  -L, --dereference          when showing file information for a symbolic
                               link, show information for the file the link
                               references rather than for the link itself
  -m                         fill width with a comma separated list of entries
  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs
  -N, --literal              print entry names without quoting
  -o                         like -l, but do not list group information
  -p, --indicator-style=slash
                             append / indicator to directories
  -q, --hide-control-chars   print ? instead of nongraphic characters
      --show-control-chars   show nongraphic characters as-is (the default,
                               unless program is 'ls' and output is a terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always,
                               shell-escape, shell-escape-always, c, escape
                               (overrides QUOTING_STYLE environment variable)
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print the allocated size of each file, in blocks
  -S                         sort by file size, largest first
      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),
                               time (-t), version (-v), extension (-X)
      --time=WORD            change the default of using modification times;
                               access time (-u): atime, access, use;
                               change time (-c): ctime, status;
                               birth time: birth, creation;
                             with -l, WORD determines which time to show;
                             with --sort=time, sort by WORD (newest first)
      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE below
  -t                         sort by time, newest first; see --time
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time;
                               with -l: show access time and sort by name;
                               otherwise: sort by access time, newest first
  -U                         do not sort; list entries in directory order
  -v                         natural sort of (version) numbers within text
  -w, --width=COLS           set output width to COLS.  0 means no limit
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -Z, --context              print any security context of each file
  -1                         list one file per line.  Avoid '\n' with -q or -b
      --help     display this help and exit
      --version  output version information and exit

The SIZE argument is an integer and optional unit (example: 10K is 10*1024).
Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).
Binary prefixes can be used, too: KiB=K, MiB=M, and so on.

The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.
FORMAT is interpreted like in date(1).  If FORMAT is FORMAT1&lt;newline&gt;FORMAT2,
then FORMAT1 applies to non-recent files and FORMAT2 to recent files.
TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX locale.
Also the TIME_STYLE environment variable sets the default style to use.

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Report any translation bugs to &lt;https://translationproject.org/team/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/ls&gt;
or available locally via: info '(coreutils) ls invocation'
</code></pre>
<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <code>mv</code>（用于重命名或移动文件）、 <code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>
<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p>
<pre><code>missing:~$ man ls
</code></pre>
<h2 id="附录处理目录的常用命令"><a class="header" href="#附录处理目录的常用命令">附录处理目录的常用命令</a></h2>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <code>man [命令]</code> 来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="附录cd命令"><a class="header" href="#附录cd命令">附录cd命令</a></h2>
<p>Linux cd（英文全拼：change directory）命令用于改变当前工作目录的命令，切换到指定的路径。</p>
<p>若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p>
<p>另外，~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录， .. 则表示目前目录位置的上一层目录。</p>
<p>切换到 /usr/bin/ 目录: <code>cd /usr/bin</code></p>
<p><strong>切换到上级目录：</strong> 使用 .. 表示上级目录，可以通过连续多次使用 .. 来切换到更高级的目录。</p>
<pre><code class="language-bash">cd ..
cd ../../   // 切换到上上级目录
</code></pre>
<p><strong>切换到用户主目录（home）：</strong> 使用 ~ 表示当前用户的主目录，可以使用 cd 命令直接切换到主目录。</p>
<pre><code class="language-bash">cd ~
</code></pre>
<p><strong>切换到上次访问的目录：</strong> 使用 cd - 可以切换到上次访问的目录。</p>
<pre><code class="language-bash">cd -
</code></pre>
<p><strong>切换到环境变量指定的目录：</strong> 可以使用环境变量来指定目标目录，并使用 cd 命令切换到该目录。</p>
<pre><code class="language-bash">cd $VAR_NAME
</code></pre>
<p>以上实例都是 cd 命令的一些基本用法，它们可以帮助您在 Linux 系统中进行目录切换操作。</p>
<p>使用<code>cd --help</code>命令可以获取更多关于 cd 命令的详细信息，包括可用的选项和更高级的用法。</p>
<h2 id="在程序间创建连接"><a class="header" href="#在程序间创建连接">在程序间创建连接</a></h2>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<pre><code>missing:~$ echo hello &gt; hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat &lt; hello.txt
hello
missing:~$ cat &lt; hello.txt &gt; hello2.txt
missing:~$ cat hello2.txt
hello
</code></pre>
<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<pre><code>missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
</code></pre>
<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>
<h2 id="一个功能全面又强大的工具"><a class="header" href="#一个功能全面又强大的工具">一个功能全面又强大的工具</a></h2>
<p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。 您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。 通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。 当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>
<p>可以利用<code>sudo su</code>命令进入root用户模式，使用<code>exit</code>命令退出root用户模式。</p>
<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p>
<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p>
<pre><code>/sys/class/backlight
</code></pre>
<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>
<pre><code>$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 &gt; brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
</code></pre>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p>
<p>明白这一点后，我们可以这样操作：</p>
<pre><code>$ echo 3 | sudo tee brightness
</code></pre>
<p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。 这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p>
<pre><code>$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
</code></pre>
<h2 id="接下来"><a class="header" href="#接下来">接下来…..</a></h2>
<p>学到这里，您掌握的 shell 知识已经可以完成一些基础的任务了。您应该已经可以查找感兴趣的文件并使用大多数程序的基本功能了。 在下一场讲座中，我们会探讨如何利用 shell 及其他工具执行并自动化更复杂的任务。</p>
<h2 id="课后练习"><a class="header" href="#课后练习">课后练习</a></h2>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution">习题解答</a> 本课程中的每节课都包含一系列练习题。有些题目是有明确目的的，另外一些则是开放题，例如“尝试使用 X 和 Y”，我们强烈建议您一定要动手实践，用于尝试这些内容。 此外，我们没有为这些练习题提供答案。如果有任何困难，您可以发送邮件给我们并描述你已经做出的尝试，我们会设法帮您解答。</p>
<ol>
<li>
<p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用<a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a>或者是 Linux 虚拟机。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p>
</li>
<li>
<p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p>
</li>
<li>
<p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p>
</li>
<li>
<p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p>
</li>
<li>
<p>将以下内容一行一行地写入 <code>semester</code> 文件：</p>
<pre><code> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
</li>
</ol>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p>
<ol start="6">
<li>
<p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p>
</li>
<li>
<p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code> 命令)</p>
</li>
<li>
<p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p>
</li>
<li>
<p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p>
</li>
</ol>
<p>注：使用 <code>chmod +x semester</code> 命令改变权限，使 <code>./semester</code> 能够成功执行</p>
<h2 id="solution-课程概览与-shell"><a class="header" href="#solution-课程概览与-shell">Solution-课程概览与 shell</a></h2>
<ol>
<li>
<p>在 /tmp 下新建一个名为 missing 的文件夹。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/1.png" alt="1.png" /></p>
</li>
<li>
<p>用 man 查看程序 touch 的使用手册。 <code>man touch</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/2.png" alt="2.png" /></p>
</li>
<li>
<p>用 touch 在 missing 文件夹中新建一个叫 semester 的文件。 <code>touch semester</code></p>
</li>
<li>
<p>将以下内容一行一行地写入 semester 文件：</p>
<pre><code> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting</a>手册<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/3.png" alt="3.png" /></p>
</li>
<li>
<p>尝试执行这个文件。即，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 ls 命令来获取信息并理解其不能执行的原因。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/4.png" alt="4.png" /></p>
</li>
<li>
<p>查看 chmod 的手册(例如，使用 <code>man chmod</code> 命令)<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/5.png" alt="5.png" /></p>
</li>
<li>
<p>使用 chmod 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 sh semester 来执行该程序。您的 shell 是如何知晓这个文件需要使用 sh 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/6.png" alt="6.png" /></p>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 semester 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/7.png" alt="7.png" /></p>
</li>
<li>
<p>写一段命令来从 /sys 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。 Windows 用户可以通过以下命令查询：</p>
<p>WSL2：</p>
<pre><code> &gt; cat /sys/class/power_supply/BAT1/capacity
 100
</code></pre>
<p>Linux 用户可以通过以下命令查询：</p>
<pre><code> &gt; cat /sys/class/power_supply/BAT1/capacity
 100
</code></pre>
</li>
</ol>
<h1 id="shell-工具和脚本"><a class="header" href="#shell-工具和脚本">Shell 工具和脚本</a></h1>
<p>在这节课中，我们将会展示 bash 作为脚本语言的一些基础操作，以及几种最常用的 shell 工具。</p>
<h2 id="shell-脚本"><a class="header" href="#shell-脚本">Shell 脚本</a></h2>
<p>到目前为止，我们已经学习来如何在 shell 中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>
<p>shell 脚本是一种更加复杂度的工具。</p>
<p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。</p>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，<strong>在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</strong></p>
<p><strong>Bash中的字符串通过<code>'</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</strong></p>
<pre><code class="language-bash">foo=bar
echo &quot;$foo&quot;
# 打印 bar
echo '$foo'
# 打印 $foo
</code></pre>
<p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p>
<pre><code class="language-bash">mcd () {
    mkdir -p &quot;$1&quot;
    cd &quot;$1&quot;
}
</code></pre>
<p>这里 <code>$1</code> 是脚本的第一个参数。</p>
<p>这里可以使用vim打开一个文件写入上面的代码并执行<code>source mcd.sh</code>来加载mcd函数，再执行<code>mcd test</code>就能进入test文件夹。</p>
<p>与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p>
<pre><code class="language-bash">xx:~/missing$ echo &quot;Hello&quot;
Hello
xx:~/missing$ echo $?
0
xx:~/missing$ grep foobar mcd.sh
xx:~/missing$ echo $?
1
</code></pre>
<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">运算符</a>（short-circuiting） 同一行的多个命令可以用 <code>;</code> 分隔。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。让我们看几个例子</p>
<pre><code class="language-bash">false || echo &quot;Oops, fail&quot;
# Oops, fail

true || echo &quot;Will not be printed&quot;
#

true &amp;&amp; echo &quot;Things went well&quot;
# Things went well

false &amp;&amp; echo &quot;Will not be printed&quot;
#

false ; echo &quot;This will always run&quot;
# This will always run
</code></pre>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em>（<em>command substitution</em>）实现。</p>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。<strong>这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</strong></p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<pre><code class="language-bash">#!/bin/bash

echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间

echo &quot;Running program $0 with $# arguments with pid $$&quot;

for file in &quot;$@&quot;; do
    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null
    # 如果模式没有找到，则grep退出状态为 1
    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息
    if [[ $? -ne 0 ]]; then
        echo &quot;File $file does not have any foobar, adding one&quot;
        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;
    fi
done
</code></pre>
<p>在条件语句中，我们比较 <code>$?</code> 是否等于0。 执行<code> ./example.sh mcd.sh example.sh</code>时权限不足就执行<code>chmod 777 ./example.sh</code>赋予shell脚本足够权限再执行<code>./example.sh mcd.sh example.sh</code>。输出结果如下：</p>
<pre><code>Starting program at Mon Jan  1 19:13:58 CST 2024
Running program ./example.sh with 2 arguments with pid 144
File mcd.sh does not have any foobar, adding one
</code></pre>
<p>Bash实现了许多类似的比较操作，您可以查看 <a href="https://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。 在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见<a href="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</p>
<p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 <em>通配</em>（<em>globbing</em>）</p>
<ul>
<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
</ul>
<pre><code class="language-bash">convert image.{png,jpg}
# 会展开为
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# 会展开为
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# 也可以结合通配使用
mv *{.py,.sh} folder
# 会移动所有 *.py 和 *.sh 文件

mkdir foo bar

# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件
touch {foo,bar}/{a..h}
touch foo/x bar/y
# 比较文件夹 foo 和 bar 中包含文件的不同
diff &lt;(ls foo) &lt;(ls bar)
# 输出
# &lt; x
# ---
# &gt; y
</code></pre>
<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位sh/bash脚本中的错误。安装shellcheck可以执行<code>sudo apt install shellcheck</code>命令。</p>
<p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p>
<pre><code class="language-bash">#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
</code></pre>
<p>内核知道去用 python 解释器而不是 shell 命令来运行这段脚本，是因为脚本的开头第一行的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p>
<p>在 <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。 例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code>。</p>
<p>shell函数和脚本有如下一些不同点：</p>
<ul>
<li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ul>
<h2 id="shell-工具"><a class="header" href="#shell-工具">Shell 工具</a></h2>
<h3 id="查看命令如何使用"><a class="header" href="#查看命令如何使用">查看命令如何使用</a></h3>
<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？ 一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>
<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<a href="https://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。 事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。 <a href="https://tldr.sh/">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>
<p>例如，自己就常常在tldr上搜索<a href="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <a href="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a> 的用法。</p>
<h3 id="查找文件-1"><a class="header" href="#查找文件-1">查找文件</a></h3>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <a href="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a> 的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p>
<pre><code># 查找所有名称为src的文件夹
find . -name src -type d
# 查找所有文件夹路径中包含test的python文件
find . -path '*/test/*.py' -type f
# 查找前一天修改的所有文件
find . -mtime -1
# 查找所有大小在500k至10M的tar.gz文件
find . -size +500k -size -10M -name '*.tar.gz'
</code></pre>
<p>除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<pre><code># 删除全部扩展名为.tmp 的文件
find . -name '*.tmp' -exec rm {} \;
# 查找全部的 PNG 文件并将其转换为 JPG
find . -name '*.png' -exec convert {} {}.jpg \;
</code></pre>
<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码"><a class="header" href="#查找代码">查找代码</a></h3>
<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>
<p>为了实现这一点，很多类UNIX的系统都提供了<a href="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>
<p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p>
<p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>
<pre><code># 查找所有使用了 requests 库的文件
rg -t py 'import requests'
# 查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match &quot;^#!&quot;
# 查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
# 打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN
</code></pre>
<p>与 <code>find</code>/<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>
<h3 id="查找-shell-命令"><a class="header" href="#查找-shell-命令">查找 shell 命令</a></h3>
<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
<h3 id="文件夹导航"><a class="header" href="#文件夹导航">文件夹导航</a></h3>
<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>
<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<p>安装tree使用<code>sudo apt install tree</code>命令。</p>
<h2 id="课后练习-1"><a class="header" href="#课后练习-1">课后练习</a></h2>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//shell-tools-solution">习题解答</a></p>
<ol>
<li>
<p>阅读 <a href="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p>
<ul>
<li>所有文件（包括隐藏文件）</li>
<li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li>
<li>文件以最近访问顺序排序</li>
<li>以彩色文本显示输出结果</li>
</ul>
<p>典型输出如下：</p>
<pre><code> -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
</li>
<li>
<p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</p>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<pre><code> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
    echo &quot;Something went wrong&quot;
    &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
    exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
</li>
<li>
<p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p>
<p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>，译注：MacOS 上的 <code>xargs</code>没有<code>-d</code>，<a href="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）</p>
<p>如果您使用的是 MacOS，请注意默认的 BSD <code>find</code> 与 <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为<code>find</code>添加<code>-print0</code>选项，并为<code>xargs</code>添加<code>-0</code>选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew 来安装</a>。</p>
</li>
<li>
<p>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</p>
</li>
</ol>
<h1 id="solution-shell-工具和脚本"><a class="header" href="#solution-shell-工具和脚本">Solution-Shell 工具和脚本</a></h1>
<ol>
<li>
<p>阅读 man ls ，然后使用ls 命令进行如下操作：</p>
<ul>
<li>
<p>所有文件（包括隐藏文件） ：<code>-a</code></p>
</li>
<li>
<p>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) : <code>-h</code></p>
</li>
<li>
<p>文件以最近访问顺序排序：<code>-t</code></p>
</li>
<li>
<p>以彩色文本显示输出结果<code>--color=auto</code><br />
典型输出如下：</p>
<pre><code> -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
</li>
</ul>
</li>
<li>
<p>编写两个bash函数 marco 和 polo 执行下面的操作。 每当你执行 marco 时，当前的工作目录应当以某种形式保存，当执行 polo 时，无论现在处在什么目录下，都应当 cd 回到当时执行 marco 的目录。 为了方便debug，你可以把代码写在单独的文件 marco.sh 中，并通过 source marco.sh命令，（重新）加载函数。通过source 来加载函数，随后可以在 bash 中直接使用。</p>
<pre><code> #!/bin/bash
 marco(){
     echo &quot;$(pwd)&quot; &gt; $HOME/marco_history.log
     echo &quot;save pwd $(pwd)&quot;
 }
 polo(){
     cd &quot;$(cat &quot;$HOME/marco_history.log&quot;)&quot;
 }
</code></pre>
<p>或者</p>
<pre><code> #!/bin/bash
 marco() {
     export MARCO=$(pwd)
 }
 polo() {
     cd &quot;$MARCO&quot;
 }
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/1.png" alt="1.png" /></p>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<pre><code> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
     echo &quot;Something went wrong&quot;
     &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
     exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
<p>使用 while 循环完成</p>
<pre><code> #!/usr/bin/env bash
 count=0
 echo &gt; out.log

 while true
 do
     ./buggy.sh &amp;&gt;&gt; out.log
     if [[ $? -ne 0 ]]; then
         cat out.log
         echo &quot;failed after $count times&quot;
         break
     fi
     ((count++))

 done

</code></pre>
<p>使用 for 循环完成</p>
<pre><code> #!/usr/bin/env bash
 echo &gt; out.log
 for ((count=0;;count++))
 do
     ./buggy.sh &amp;&gt;&gt; out.log
     if [[ $? -ne 0 ]]; then
         echo &quot;failed after $count times&quot;
         break

     fi
 done

</code></pre>
<p>使用 until 完成</p>
<pre><code> #!/usr/bin/env bash
 count=0
 ./buggy.sh &amp;&gt;&gt; out.log
 until [[ &quot;$?&quot; -ne 0 ]];
 do
     count=$((count+1))
     ./buggy.sh &amp;&gt;&gt; out.log
 done

 echo &quot;failed after $count runs&quot;

</code></pre>
<p>执行测试脚本debug.sh,并验证脚本结果的正确性</p>
<pre><code> ~$ ./debug.sh
 failed after 34 times
 ~$ cat out.log | grep Everything | wc -l
 34
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/2.png" alt="1.png" /></p>
</li>
<li>
<p>本节课我们讲解的 find 命令中的 -exec 参数非常强大，它可以对我们查找的文件进行操作。 如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如tar 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html">xargs</a> 命令，它可以使用标准输入中的内容作为参数。 例如 ls | xargs rm 会删除当前目录中的所有文件。您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 xargs的参数-d）<em>译注：MacOS 上的 xargs没有-d，查看这个<a href="https://github.com/missing-semester/missing-semester/issues/93">issue</a></em></p>
<p>如果您使用的是 MacOS，请注意默认的 BSD find 与<a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为find添加-print0选项，并为xargs添加-0选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew</a> 来安装。</p>
<ol>
<li>
<p>首先创建所需的文件</p>
<pre><code>  mkdir html_root
  cd html_root
  touch {1..10}.html
  mkdir html
  cd html
  touch xxxx.html
</code></pre>
<pre><code>  ├── html_root
  │   ├── 1.html
  │   ├── 10.html
  │   ├── 2.html
  │   ├── 3.html
  │   ├── 4.html
  │   ├── 5.html
  │   ├── 6.html
  │   ├── 7.html
  │   ├── 8.html
  │   ├── 9.html
  │   └── html
  │       └── xxxx.html
</code></pre>
</li>
<li>
<p>执行 find 命令</p>
<pre><code>  #for MacOS
  find html_root -name &quot;*.html&quot; -print0 | xargs -0 tar vcf html.zip
</code></pre>
<pre><code>  #for Linux
  find . -type f -name &quot;*.html&quot; | xargs -d '\n'  tar -cvzf html.zip
</code></pre>
<pre><code>  a html_root/9.html
  a html_root/5.html
  a html_root/4.html
  a html_root/8.html
  a html_root/3.html
  a html_root/html/xxxx.html
  a html_root/2.html
  a html_root/1.html
  a html_root/10.html
  a html_root/7.html
  a html_root/6.html
</code></pre>
</li>
</ol>
</li>
<li>
<p>(进阶) 编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？ <code>find . -type f -print0 | xargs -0 ls -lt | head -1</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/4.png" alt="1.png" /></p>
</li>
</ol>
<p>当文件数量较多时，上面的解答会得出错误结果，解决办法是增加 <code>-mmin</code> 条件，先将最近修改的文件进行初步筛选再交给ls进行排序显示 <code>find . -type f -mmin -60 -print0 | xargs -0 ls -lt | head -10</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/5.png" alt="1.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="编辑器-vim"><a class="header" href="#编辑器-vim">编辑器 (Vim)</a></h1>
<p><a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim)来源地址</a></p>
<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的 Word 与 Visual Studio Code）。</p>
<p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p>
<ul>
<li>阅读教程（比如这节课以及我们为您提供的资源）</li>
<li>坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li>
<li>随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有</li>
</ul>
<p>如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。当学习时间累计达到20个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%AF%A5%E5%AD%A6%E5%93%AA%E4%B8%AA%E7%BC%96%E8%BE%91%E5%99%A8">该学哪个编辑器？</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim">Vim</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim-%E7%9A%84%E5%93%B2%E5%AD%A6">Vim 的哲学</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F">编辑模式</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">基本操作</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC">插入文本</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%BC%93%E5%AD%98-%E6%A0%87%E7%AD%BE%E9%A1%B5-%E7%AA%97%E5%8F%A3">缓存， 标签页， 窗口</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%91%BD%E4%BB%A4%E8%A1%8C">命令行</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">Vim 的接口其实是一种编程语言</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%A7%BB%E5%8A%A8">移动</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E9%80%89%E6%8B%A9">选择</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%BC%96%E8%BE%91">编辑</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%AE%A1%E6%95%B0">计数</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E4%BF%AE%E9%A5%B0%E8%AF%AD">修饰语</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%BC%94%E7%A4%BA">演示</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%87%AA%E5%AE%9A%E4%B9%89-vim">自定义 Vim</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%89%A9%E5%B1%95-vim">扩展 Vim</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%9A%84-vim-%E6%A8%A1%E5%BC%8F">其他程序的 Vim 模式</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#shell">Shell</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#readline">Readline</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim-%E8%BF%9B%E9%98%B6">Vim 进阶</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2">搜索和替换</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4">复制粘贴</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%A4%9A%E7%AA%97%E5%8F%A3">多窗口</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%AE%8F">宏</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99">扩展资料</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#solution-%E7%BC%96%E8%BE%91%E5%99%A8-vim">Solution-编辑器 (Vim)</a></li>
</ul>
<h1 id="该学哪个编辑器"><a class="header" href="#该学哪个编辑器">该学哪个编辑器？</a></h1>
<p>程序员们对自己正在使用的文本编辑器通常有着 <a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98">非常强的执念</a>。</p>
<p>现在最流行的编辑器是什么？<a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>（这个调查可能并不如我们想象的那样客观，因为 Stack Overflow 的用户并不能代表所有程序员）显示，<a href="https://code.visualstudio.com/">Visual Studio Code</a> 是目前最流行的代码编辑器。而 <a href="https://www.vim.org/">Vim</a> 则是最流行的基于命令行的编辑器。</p>
<h2 id="vim"><a class="header" href="#vim">Vim</a></h2>
<p>这门课的所有教员都使用 Vim 作为编辑器。Vim 有着悠久历史；它始于 1976 年的 Vi 编辑器，到现在还在 不断开发中。Vim 有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140 万人安装了 <a href="https://github.com/VSCodeVim/Vim">Vim emulation for VS code</a>）。即使你最后使用 其他编辑器，Vim 也值得学习。</p>
<p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim 的设计哲学，教你基础知识， 并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p>
<h1 id="vim-的哲学"><a class="header" href="#vim-的哲学">Vim 的哲学</a></h1>
<p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以，Vim 是一个_多模态_编辑 器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一种程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</p>
<p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p>
<h1 id="编辑模式"><a class="header" href="#编辑模式">编辑模式</a></h1>
<p>Vim 的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p>
<ul>
<li><strong>正常模式</strong>：在文件中四处移动光标进行修改</li>
<li><strong>插入模式</strong>：插入文本</li>
<li><strong>替换模式</strong>：替换文本</li>
<li><strong>可视化模式</strong>（一般，行，块）：选中文本块</li>
<li><strong>命令模式</strong>：用于执行命令</li>
</ul>
<p>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code> 在插入模式会插入字母 <code>x</code>，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p>
<p>在默认设置下，Vim 会在左下角显示当前的模式。Vim 启动时的默认模式是正常模式。通常你会把大部分 时间花在正常模式和插入模式。</p>
<p>你可以按下 <code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入 <code>i</code> 进入插入 模式，<code>R</code> 进入替换模式，<code>v</code> 进入可视（一般）模式，<code>V</code> 进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p>
<p>因为你会在使用 Vim 时大量使用 <code>&lt;ESC&gt;</code> 键，所以可以考虑把大小写锁定键重定义成 <code>&lt;ESC&gt;</code> 键（<a href="https://vim.fandom.com/wiki/Map_caps_lock_to_escape_in_macOS">MacOS 教程</a>）。</p>
<h1 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h1>
<h2 id="插入文本"><a class="header" href="#插入文本">插入文本</a></h2>
<p>在正常模式，键入 <code>i</code> 进入插入模式。现在 Vim 跟很多其他的编辑器一样，直到你键入 <code>&lt;ESC&gt;</code> 返回正常模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p>
<h2 id="缓存-标签页-窗口"><a class="header" href="#缓存-标签页-窗口">缓存， 标签页， 窗口</a></h2>
<p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系；窗口只是视角。一个缓存可以在多个窗口打开，甚至在同一个标签页内的多个窗口打开。这个功能其实很好用，比如在查看同一个文件的不同部分的时候。</p>
<p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p>
<h2 id="命令行"><a class="header" href="#命令行">命令行</a></h2>
<p>在正常模式下键入 <code>:</code> 进入命令行模式。 在键入 <code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能，包括打开，保存，关闭文件，以及 <a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p>
<ul>
<li><code>:q</code> 退出（关闭窗口）</li>
<li><code>:w</code> 保存（写）</li>
<li><code>:wq</code> 保存然后退出</li>
<li><code>:e {文件名}</code> 打开要编辑的文件</li>
<li><code>:ls</code> 显示打开的缓存</li>
<li><code>:help {标题}</code> 打开帮助文档
<ul>
<li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li>
<li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li>
</ul>
</li>
</ul>
<h1 id="vim-的接口其实是一种编程语言"><a class="header" href="#vim-的接口其实是一种编程语言">Vim 的接口其实是一种编程语言</a></h1>
<p>Vim 最重要的设计思想是 Vim 的界面本身是一种程序语言。键入操作（以及他们的助记名） 本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p>
<h2 id="移动"><a class="header" href="#移动">移动</a></h2>
<p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。</p>
<ul>
<li>基本移动: <code>hjkl</code> （左， 下， 上， 右）</li>
<li>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</li>
<li>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</li>
<li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</li>
<li>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻）</li>
<li>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</li>
<li>行数： <code>:{行数}&lt;CR&gt;</code> 或者 <code>{行数}G</code> ({行数}为行数)</li>
<li>杂项： <code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）</li>
<li>查找： <code>f{字符}</code>， <code>t{字符}</code>， <code>F{字符}</code>， <code>T{字符}</code>
<ul>
<li>查找/到 向前/向后 在本行的{字符}</li>
<li><code>,</code> / <code>;</code> 用于导航匹配</li>
</ul>
</li>
<li>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配</li>
</ul>
<h2 id="选择"><a class="header" href="#选择">选择</a></h2>
<p>可视化模式:</p>
<ul>
<li>可视化：<code>v</code></li>
<li>可视化行： <code>V</code></li>
<li>可视化块：<code>Ctrl+v</code></li>
</ul>
<p>可以用移动命令来选中。</p>
<h2 id="编辑"><a class="header" href="#编辑">编辑</a></h2>
<p>所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</p>
<ul>
<li><code>i</code> 进入插入模式
<ul>
<li>但是对于操纵/编辑文本，不单想用退格键完成</li>
</ul>
</li>
<li><code>O</code> / <code>o</code> 在之上/之下插入行</li>
<li><code>d{移动命令}</code> 删除 {移动命令}
<ul>
<li>例如，<code>dw</code> 删除词, <code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。</li>
</ul>
</li>
<li><code>c{移动命令}</code> 改变 {移动命令}
<ul>
<li>例如，<code>cw</code> 改变词</li>
<li>比如 <code>d{移动命令}</code> 再 <code>i</code></li>
</ul>
</li>
<li><code>x</code> 删除字符（等同于 <code>dl</code>）</li>
<li><code>s</code> 替换字符（等同于 <code>xi</code>）</li>
<li>可视化模式 + 操作
<ul>
<li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li>
</ul>
</li>
<li><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</li>
<li><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</li>
<li><code>p</code> 粘贴</li>
<li>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</li>
</ul>
<h2 id="计数"><a class="header" href="#计数">计数</a></h2>
<p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p>
<ul>
<li><code>3w</code> 向后移动三个词</li>
<li><code>5j</code> 向下移动5行</li>
<li><code>7dw</code> 删除7个词</li>
</ul>
<h2 id="修饰语"><a class="header" href="#修饰语">修饰语</a></h2>
<p>你可以用修饰语改变“名词”的意义。修饰语有 <code>i</code>，表示“内部”或者“在内”，和 <code>a</code>， 表示“周围”。</p>
<ul>
<li><code>ci(</code> 改变当前括号内的内容</li>
<li><code>ci[</code> 改变当前方括号内的内容</li>
<li><code>da'</code> 删除一个单引号字符串， 包括周围的单引号</li>
</ul>
<h1 id="演示"><a class="header" href="#演示">演示</a></h1>
<p>这里是一个有问题的 <a href="https://en.wikipedia.org/wiki/Fizz_buzz">fizz buzz</a> 实现：</p>
<pre><code class="language-python">def fizz_buzz(limit):
    for i in range(limit):
        if i % 3 == 0:
            print('fizz')
        if i % 5 == 0:
            print('fizz')
        if i % 3 and i % 5:
            print(i)

def main():
    fizz_buzz(10)
</code></pre>
<p>我们会修复以下问题：</p>
<ul>
<li>
<p>主函数没有被调用</p>
</li>
<li>
<p>从 0 而不是 1 开始</p>
</li>
<li>
<p>在 15 的整数倍的时候在不同行打印 “fizz” 和 “buzz”</p>
</li>
<li>
<p>在 5 的整数倍的时候打印 “fizz”</p>
</li>
<li>
<p>采用硬编码的参数 10 而不是从命令控制行读取参数</p>
</li>
<li>
<p>主函数没有被调用</p>
<ul>
<li><code>G</code> 文件尾</li>
<li><code>o</code> 向下打开一个新行</li>
<li>输入 “if <strong>name</strong> …”</li>
</ul>
</li>
<li>
<p>从 0 而不是 1 开始</p>
<ul>
<li>搜索 <code>/range</code></li>
<li><code>ww</code> 向后移动两个词</li>
<li><code>i</code> 插入文字， “1, “</li>
<li><code>ea</code> 在 limit 后插入， “+1”</li>
</ul>
</li>
<li>
<p>在新的一行 “fizzbuzz”</p>
<ul>
<li><code>jj$i</code> 插入文字到行尾</li>
<li>加入 “, end=’’”</li>
<li><code>jj.</code> 重复第二个打印</li>
<li><code>jjo</code> 在 if 打开一行</li>
<li>加入 “else: print()” ❗ 🔄</li>
</ul>
</li>
<li>
<p>fizz fizz</p>
<ul>
<li><code>ci'</code> 变到 fizz</li>
</ul>
</li>
<li>
<p>命令控制行参数</p>
<ul>
<li><code>ggO</code> 向上打开</li>
<li>“import sys” </li>
<li><code>/10</code></li>
<li><code>ci(</code> to “int(sys.argv[1])” </li>
</ul>
</li>
</ul>
<pre><code class="language-python">import sys
def fizz_buzz(limit):
    for i in range(limit):
        if i % 3 == 0:
            print('fizz')
        if i % 5 == 0:
            print('buzz')
        if i % 3 and i % 5:
            print(i)

def main():
    fizz_buzz(int(sys.argv[1]))

if __name__ == '__main__':
	main()
</code></pre>
<p>展示详情请观看课程视频。比较上面用 Vim 的操作和你可能使用其他程序的操作。 值得一提的是 Vim 需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p>
<h1 id="自定义-vim"><a class="header" href="#自定义-vim">自定义 Vim</a></h1>
<p>Vim 由一个位于 <code>~/.vimrc</code> 的文本配置文件（包含 Vim 脚本命令）。你可能会启用很多基本 设置。</p>
<p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。 <strong>在<a href="https://missing-semester-cn.github.io/2020/files/vimrc">这儿</a> 下载我们的设置，然后将它保存成 <code>~/.vimrc</code>.</strong></p>
<p>Vim 能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在 GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (<a href="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>, <a href="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a> (uses <a href="https://neovim.io/">neovim</a>), <a href="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。 有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它，然后采用对你有用的部分。</p>
<h1 id="扩展-vim"><a class="header" href="#扩展-vim">扩展 Vim</a></h1>
<p>Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你_不_需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。你可以使用内置的插件管理系统。只需要创建一个 <code>~/.vim/pack/vendor/start/</code> 的文件夹，然后把插件放到这里（比如通过 <code>git clone</code>）。</p>
<p>以下是一些我们最爱的插件：</p>
<ul>
<li><a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>: 模糊文件查找</li>
<li><a href="https://github.com/mileszs/ack.vim">ack.vim</a>: 代码搜索</li>
<li><a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: 文件浏览器</li>
<li><a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>: 魔术操作</li>
</ul>
<p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件 (<a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/JJGO/dotfiles">Jose</a>) 来看看我们使用的其他插件。 浏览 <a href="https://vimawesome.com/">Vim Awesome</a> 来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim plugins”。</p>
<h1 id="其他程序的-vim-模式"><a class="header" href="#其他程序的-vim-模式">其他程序的 Vim 模式</a></h1>
<p>很多工具提供了 Vim 模式。这些 Vim 模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim 功能，但是大多数对基本功能支持的很好。</p>
<h2 id="shell"><a class="header" href="#shell">Shell</a></h2>
<p>如果你是一个 Bash 用户，用 <code>set -o vi</code>。如果你用 Zsh：<code>bindkey -v</code>。Fish 用 <code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以 <code>export EDITOR=vim</code>。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如，<code>git</code> 会使用这个编辑器来编辑 commit 信息。</p>
<h2 id="readline"><a class="header" href="#readline">Readline</a></h2>
<p>很多程序使用 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a> 库来作为它们的命令控制行界面。Readline 也支持基本的 Vim 模式， 可以通过在 <code>~/.inputrc</code> 添加如下行开启：</p>
<pre><code>set editing-mode vi
</code></pre>
<p>比如，在这个设置下，Python REPL 会支持 Vim 快捷键。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<p>甚至有 Vim 的网页浏览快捷键 <a href="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>, 受欢迎的有 用于 Google Chrome 的 <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a> 和用于 Firefox 的 <a href="https://github.com/tridactyl/tridactyl">Tridactyl</a>。 你甚至可以在 <a href="https://github.com/lambdalisue/jupyter-vim-binding">Jupyter notebooks</a> 中用 Vim 快捷键。 <a href="https://reversed.top/2016-08-13/big-list-of-vim-like-software">这个列表</a> 中列举了支持类 vim 键位绑定的软件。</p>
<h1 id="vim-进阶"><a class="header" href="#vim-进阶">Vim 进阶</a></h1>
<p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你 可以在使用中学习。一个好的对策是: 当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p>
<h2 id="搜索和替换"><a class="header" href="#搜索和替换">搜索和替换</a></h2>
<p><code>:s</code> （替换）命令（<a href="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p>
<ul>
<li><code>%s/foo/bar/g</code>
<ul>
<li>在整个文件中将 foo 全局替换成 bar</li>
</ul>
</li>
<li><code>%s/\[.*\](\(.*\))/\1/g</code>
<ul>
<li>将有命名的 Markdown 链接替换成简单 URLs</li>
</ul>
</li>
</ul>
<h2 id="复制粘贴"><a class="header" href="#复制粘贴">复制粘贴</a></h2>
<p>vim中的复制和粘贴命令分别是y和p，在不需要和系统交互剪贴板数据时还好，一旦要复制外部数据到vim中或者将vim中的数据复制到外部，这两个命令就无效了，只能用鼠标选中再右键复制粘贴。虽然和windows下的Ctrl C、Ctrl V不同，但vim可以通过配置实现和系统剪贴板的“沟通”。
需要注意的是Ctrl y和Ctrl p在 vim 中有特殊含义，使用以下设置后会覆盖默认设置。</p>
<p>前提
开始前需要先查看vim是否已经支持clipboard功能，使用vim --version | grep clipboard命令查看，有+clipboard说已经支持clipboard功能。</p>
<pre><code>-clipboard         +keymap            +printer           +vertsplit
+eval              -mouse_jsbterm     -sun_workshop      -xterm_clipboard
</code></pre>
<p>如果其前为-号，执行sudo apt install vim-gtk安装vim-gtk即可（或者安装gvim，非debian系的系统不是用apt命令，根据系统变动就行，都差不多），安装完成后再执行vim --version | grep clipboard此时应该已经支持clipboard功能。</p>
<p>配置vim</p>
<p>此时如果在vim外复制了文本，要粘贴到打开的vim文件内，只需在normal模式下（如果不知道当前在哪个模式就先按一次ESC键）执行&quot;*p，注意是三个键连续输入，由于要输入双引号和星号，因此需要先按下Shift键，再分别按下&quot; *（过程中Shift不要放下），最后按下p（小写，此时不要按Shift），如果没问题应该可以将系统剪贴板数据粘贴到vim中；</p>
<p>类似的，要将vim中的数据复制到vim外，需要回到normal模式先按v进入visual模式，移动光标选中目标文本后，在visua模式下执行&quot; + y即可将vim数据复制到系统剪贴板，在vim外执行Ctrl V即可完成数据粘贴。</p>
<p>vim支持自定义快捷键，使用vim打开~/.vimrc文件这是当前用户的vim配置文件，vim会读取配置文件中的内容完成相应的配置，在这个配置文件中添加（中文前的“号是注释）</p>
<pre><code>vnoremap &lt;C-y&gt; &quot;+y   &quot;支持在Visual模式下，通过C-y复制到系统剪切板
nnoremap &lt;C-p&gt; &quot;*p   &quot;支持在normal模式下，通过C-p粘贴系统剪切板
</code></pre>
<p>添加完成后按ESC回到normal模式输入:wq保存并退出，此后就可以像Ctrl C、Ctrl V那样愉快地使用Ctrl y和Ctrl p进行复制粘贴了。</p>
<h2 id="多窗口"><a class="header" href="#多窗口">多窗口</a></h2>
<ul>
<li>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口</li>
<li>同一个缓存可以在多个窗口中显示。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/337157587">来源</a></p>
<p>Vim分屏功能是通过分割窗口来实现的，这是提高工作效率的一大利器。无论我们想同时显示两个文件，或者同时显示一个文件的两个不同的位置，又或者并排比较两个文件，等等，这些都能通过分屏来实现，这样子很方便代码的比对和复制粘贴</p>
<p><strong>水平方向分屏打开新文件</strong></p>
<p>:sp linuxmi.py</p>
<p>或者</p>
<p>:split linuxmi.py</p>
<p>这个命令把窗口横向切分为两个窗口，并把光标置于上面的窗口中。</p>
<p><strong>垂直方向分屏打开新文件</strong></p>
<p>:vsp linux.py</p>
<p>:vsplit linux.py</p>
<p>:sview linux.py -&gt;只读分屏打开文件</p>
<p>另外，要打开窗口编辑一个新的文件时，可以用以下命令：</p>
<p>:new</p>
<p><strong>从命令行直接打开多个文件且是分屏</strong></p>
<p>vim -On file1, file2 ... -&gt;垂直分屏</p>
<p>vim -on file1, file2 ... -&gt;水平分屏</p>
<p>linuxmi@linuxmi:~/<a href="https://link.zhihu.com/?target=http%3A//www.linuxmi.com">http://www.linuxmi.com</a> vim -O3 linux.py linuxmi.py linuxmi.cpp</p>
<p><img src="https://pic3.zhimg.com/80/v2-2fbea6832d96ea4ca18d8c8fc6aa76a2_1440w.webp" alt="" /></p>
<p>注：-O垂直分屏，-o水平分屏，n表示分几个屏</p>
<p><strong>实时调整当前窗口的宽度</strong><br />
ctrl-w &gt; //向右加宽，默认值为1<br />
ctrl-w N &gt; //向右加宽宽度N<br />
ctrl-w &lt; // 同理</p>
<p><strong>横屏/竖屏分屏打开当前文件</strong></p>
<p>ctrl+w s<br />
ctrl+w v</p>
<p><strong>切换分屏</strong></p>
<p>ctrl+w h,j,k,l<br />
ctrl+w 上下左右键</p>
<p>crtl+w进行分屏窗口的切换 按完以后再按一个w</p>
<p>crtl+w进行分屏窗口的切换 按完以后再按一个r 互换窗口</p>
<p>crtl+w进行分屏窗口的切换 按完以后再按一个c 关闭窗口</p>
<p><strong>关闭分屏</strong></p>
<p>关闭窗口有以下几个个命令：</p>
<p>ctrl+W c 关闭当前窗口</p>
<p>ctrl+w q 关闭当前窗口，若只有一个分屏且退出vim</p>
<p>:only 仅保留当前分屏<br />
:hide 关闭当前分屏</p>
<p><strong>调整分屏的大小（宽度与高度）</strong></p>
<p>ctrl+w = 所有分屏都统一高度<br />
ctrl+w + 增加高度，默认值为1<br />
ctrl+w - 减少高度<br />
10 ctrl+w + 增加10行高度<br />
ctrl-w N + //当前屏高度加N</p>
<p>使用指定当前屏的调整高度<br />
: resize N</p>
<p>示例：</p>
<p>:resize 30</p>
<p><strong>移动分屏</strong></p>
<p>ctrl+W H,J,K,L</p>
<p><strong>将屏幕移动到最顶端</strong><br />
ctrl-w + K</p>
<p><strong>将屏幕移动到最低端</strong><br />
ctrl-w + J</p>
<p><strong>将屏幕移动到最左边</strong><br />
ctrl-w + H</p>
<p><strong>将屏幕移动到最右边</strong><br />
ctrl-w + L</p>
<h2 id="宏"><a class="header" href="#宏">宏</a></h2>
<ul>
<li><code>q{字符}</code> 来开始在寄存器<code>{字符}</code>中录制宏</li>
<li><code>q</code>停止录制</li>
<li><code>@{字符}</code> 重放宏</li>
<li>宏的执行遇错误会停止</li>
<li><code>{计数}@{字符}</code>执行一个宏{计数}次</li>
<li>宏可以递归
<ul>
<li>首先用<code>q{字符}q</code>清除宏</li>
<li>录制该宏，用 <code>@{字符}</code> 来递归调用该宏 （在录制完成之前不会有任何操作）</li>
</ul>
</li>
<li>例子：将 xml 转成 json (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">file</a>)
<ul>
<li>一个有 “name” / “email” 键对象的数组</li>
<li>用一个 Python 程序？</li>
<li>用 sed / 正则表达式
<ul>
<li><code>g/people/d</code></li>
<li><code>%s/&lt;person&gt;/{/g</code></li>
<li><code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/&quot;name&quot;: &quot;\1&quot;,/g</code></li>
<li>…</li>
</ul>
</li>
<li>Vim 命令 / 宏
<ul>
<li><code>ggdd</code>, <code>Gdd</code> 删除第一行和最后一行</li>
<li>格式化最后一个元素的宏 （寄存器 <code>e</code>）
<ul>
<li>跳转到有 <code>&lt;name&gt;</code> 的行</li>
<li><code>qe^r&quot;f&gt;s&quot;: &quot;&lt;ESC&gt;f&lt;C&quot;&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>格式化一个的宏
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>格式化一个标签然后转到另外一个的宏
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qq@pjq</code></li>
</ul>
</li>
<li>执行宏到文件尾
<ul>
<li><code>999@q</code></li>
</ul>
</li>
<li>手动移除最后的 <code>,</code> 然后加上 <code>[</code> 和 <code>]</code> 分隔符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="扩展资料"><a class="header" href="#扩展资料">扩展资料</a></h1>
<ul>
<li><code>vimtutor</code> 是一个 Vim 安装时自带的教程</li>
<li><a href="https://vim-adventures.com/">Vim Adventures</a> 是一个学习使用 Vim 的游戏</li>
<li><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim Tips Wiki</a> </li>
<li><a href="https://vimways.org/2019/">Vim Advent Calendar</a> 有很多 Vim 小技巧</li>
<li><a href="http://www.vimgolf.com/">Vim Golf</a> 是用 Vim 的用户界面作为程序语言的 <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li>
<li><a href="https://vi.stackexchange.com/">Vi/Vim Stack Exchange</a> </li>
<li><a href="http://vimcasts.org/">Vim Screencasts</a></li>
<li><a href="https://pragprog.com/titles/dnvim2/">Practical Vim</a>（书籍） </li>
</ul>
<h1 id="课后练习-2"><a class="header" href="#课后练习-2">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//editors-solution">习题解答</a></p>
<ol>
<li>完成 <code>vimtutor</code>。备注：它在一个 <a href="https://en.wikipedia.org/wiki/VT100">80x24</a>（80 列，24 行） 终端窗口看起来效果最好。</li>
<li>下载我们提供的 <a href="https://missing-semester-cn.github.io/2020/files/vimrc">vimrc</a>，然后把它保存到 <code>~/.vimrc</code>。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。</li>
<li>安装和配置一个插件： <a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>.
<ol>
<li>用 <code>mkdir -p ~/.vim/pack/vendor/start</code> 创建插件文件夹</li>
<li>下载这个插件： <code>cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim</code></li>
<li>阅读这个插件的 <a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。 尝试用 CtrlP 来在一个工程文件夹里定位一个文件，打开 Vim, 然后用 Vim 命令控制行开始 <code>:CtrlP</code>.</li>
<li>自定义 CtrlP：添加 <a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a> 到你的 <code>~/.vimrc</code> 来用按 Ctrl-P 打开 CtrlP</li>
</ol>
</li>
<li>练习使用 Vim, 在你自己的机器上重做 <a href="https://missing-semester-cn.github.io/2020/editors/#demo">演示</a>。</li>
<li>下个月用 Vim 完成_所有的_文件编辑。每当不够高效的时候，或者你感觉 “一定有一个更好的方式”时， 尝试求助搜索引擎，很有可能有一个更好的方式。如果你遇到难题，可以来我们的答疑时间或者给我们发邮件。</li>
<li>在其他工具中设置 Vim 快捷键 （见上面的操作指南）。</li>
<li>进一步自定义你的 <code>~/.vimrc</code> 和安装更多插件。</li>
<li>（高阶）用 Vim 宏将 XML 转换到 JSON (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">例子文件</a>)。 尝试着先完全自己做，但是在你卡住的时候可以查看上面<a href="https://missing-semester-cn.github.io/2020/editors/#macros">宏</a> 章节。</li>
</ol>
<h1 id="solution-编辑器-vim"><a class="header" href="#solution-编辑器-vim">Solution-编辑器 (Vim)</a></h1>
<ol>
<li>
<p>完成 vimtutor。 备注： 它在一个 80x24（80 列，24 行） 终端窗口看起来最好。</p>
<pre><code>  vimtutor
</code></pre>
</li>
<li>
<p>下载我们的<a href="https://missing-semester-cn.github.io/2020/files/vimrc">vimrc</a>，然后把它保存到 <code>~/.vimrc</code>。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。</p>
</li>
<li>
<p>安装和配置一个插件： <code>ctrlp.vim</code>.</p>
<ol>
<li>
<p>用 <code>mkdir -p ~/.vim/pack/vendor/start</code> 创建插件文件夹</p>
</li>
<li>
<p>下载这个插件： <code>cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim</code><br />
下载后需要在~/.vimrc 中添加如下设置，参考<a href="http://ctrlpvim.github.io/ctrlp.vim/#installation">这里</a></p>
<pre><code> set runtimepath^=~/.vim/pack/vendor/start/ctrlp.vim 
</code></pre>
</li>
<li>
<p>请阅读这个插件的<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。 尝试用 CtrlP 来在一个工程文件夹里定位一个文件， 打开 Vim, 然后用 Vim 命令控制行开始 :CtrlP.<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/3/1.png" alt="1.png" /></p>
</li>
<li>
<p>自定义 CtrlP： 添加 <a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a> 到你的 ~/.vimrc 来用按 Ctrl-P 打开 CtrlP</p>
<pre><code> let g:ctrlp_map ='&lt;c-p&gt;' 
 let g:ctrlp_cmd = 'CtrlP'
 let g:ctrlp_working_path_mode = 'ra' #设置默认路径为当前路径
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/3/2.png" alt="1.png" /></p>
</li>
</ol>
</li>
<li>
<p>练习使用 Vim, 在你自己的机器上重做演示。</p>
</li>
<li>
<p>下个月用 Vim 完成_所有_的文件编辑。每当不够高效的时候，或者你感觉 “一定有一个更好的方式”， 尝试求助搜索引擎，很有可能有一个更好的方式。如果你遇到难题， 来我们的答疑时间或者给我们发邮件。</p>
</li>
<li>
<p>在你的其他工具中设置 Vim 快捷键 （见上面的操作指南）。</p>
</li>
<li>
<p>进一步自定义你的 ~/.vimrc 和安装更多插件。 安装插件最简单的方法是使用 Vim 的包管理器，即使用 vim-plug 安装插件：</p>
<ol>
<li>
<p>安装 vim-plug</p>
<pre><code>  curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</code></pre>
</li>
<li>
<p>修改 ~/.vimrc</p>
<pre><code> call plug#begin()
 Plug 'preservim/NERDTree' #需要安装的插件 NERDTree
 Plug 'wikitopian/hardmode'  #安装 hardmode
 ..... # 更多插件
 call plug#end()
</code></pre>
</li>
<li>
<p>在 vim 命令行中执行 <code>:PlugInstall</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//images/3/3.png" alt="1.png" /></p>
</li>
</ol>
</li>
<li>
<p>(高阶)用 Vim 宏将 XML 转换到 JSON (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">例子文件</a>)。 尝试着先完全自己做，但是在你卡住的时候可以查看上面 <a href="https://missing-semester-cn.github.io/2020/editors/#macros">宏</a> 章节。</p>
<p>可以先查看<a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/demoCode/3/example-data.json">转化后的JSON文件</a>，了解最终的转换效果。</p>
<pre><code>vim example-data.xml
</code></pre>
<p>在<code>vim</code>编辑页面中执行以下步骤：</p>
<ol>
<li>
<p>删除首尾两行</p>
<ul>
<li><code>Gdd</code>：跳转到最后一行，并删除该行</li>
<li><code>ggdd</code>： 跳转到第一行，并删除该行</li>
</ul>
</li>
<li>
<p>录制寄存器<code>e</code>，实现对<code>&lt;name&gt;</code>标签的处理</p>
<ul>
<li>
<p><code>/&lt;name&gt;</code>，再键入<code>Enter</code>，然后键入<code>N</code>：查找<code>&lt;name&gt;</code>并跳转到文件的最后一个<code>&lt;name&gt;</code></p>
</li>
<li>
<p>接下来，录制宏（即寄存器<code>e</code>）：</p>
</li>
<li>
<p><code>qe</code>：即将录制名为<code>e</code>的宏</p>
</li>
<li>
<p><code>^r&quot;</code>：<code>^</code>跳转到当前行的首个非空字符，即<code>&lt;name&gt;</code>的<code>&lt;</code>，<code>r&quot;</code>将<code>&lt;</code>替换为<code>&quot;</code></p>
</li>
<li>
<p><code>f&gt;s&quot;: &quot;</code>：<code>f&gt;</code>查找<code>&gt;</code>，此处即匹配刚才的<code>&lt;name&gt;</code>的<code>&gt;</code>；<code>s&quot;</code>将<code>&gt;</code>替换为<code>&quot;: &quot;</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code>：回到正常模式</p>
</li>
<li>
<p><code>f&lt;C&quot;</code>：查找下一个<code>&lt;</code>，由于xml文件的特征，此时匹配到的是刚才修改的<code>&lt;name&gt;</code>对应的<code>&lt;/name&gt;</code>的<code>&lt;</code>；然后，将当前位置到本行末尾的内容删除，同时插入<code>&quot;</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code>：回到正常模式</p>
</li>
<li>
<p><code>q</code>：停止录制，寄存器<code>e</code>完成</p>
<ul>
<li>寄存器<code>e</code>的效果示例：将<code>&lt;name&gt;Mike&lt;/name&gt;</code>修改为<code>&quot;name&quot;: &quot;Mike&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>录制寄存器<code>p</code>，实现对<code>&lt;person&gt;</code>标签的处理</p>
<ul>
<li>
<p><code>gg</code>：跳转到文件开头（本例中，正好处于一个<code>&lt;person&gt;</code>标签）</p>
</li>
<li>
<p>接下来，录制宏（寄存器<code>p</code>）</p>
</li>
<li>
<p><code>qp</code>：即将录制宏<code>p</code></p>
</li>
<li>
<p><code>S{</code>：将当前行删除，并替换为<code>{</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code>：回到正常模式</p>
</li>
<li>
<p><code>j@e</code>：移到下一行，并执行宏<code>e</code>（因为本例的xml文件中，<code>&lt;person&gt;</code>的下一行为<code>&lt;name&gt;</code>）</p>
</li>
<li>
<p><code>A,</code>：在本行的末尾添加上<code>,</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code></p>
</li>
<li>
<p><code>j@e</code>：移到下一行，并执行宏<code>e</code>（本例中，完成对<code>&lt;email&gt;</code>标签行的处理，其处理与<code>&lt;name&gt;</code>标签行的一致）</p>
</li>
<li>
<p><code>jS},</code>：跳转到下一行，并删除整行，同时添加上<code>},</code>（本例中该行内容为：<code>&lt;/person&gt;</code>）</p>
</li>
<li>
<p><code>&lt;Esc&gt;q</code>：回到正常模式，并停止录制，完成宏<code>p</code></p>
</li>
</ul>
</li>
<li>
<p>录制寄存器<code>q</code>，实现从一个<code>&lt;person&gt;</code>标签到另一个<code>&lt;person&gt;</code>标签的跳转</p>
<ul>
<li><code>/&lt;person&gt;</code>：从第三步的位置开始查找下一个<code>&lt;person&gt;</code>标签</li>
<li><code>qq</code>：开始录制宏<code>q</code></li>
<li><code>@p</code>：执行宏<code>p</code>，可以将这一组<code>&lt;person&gt;</code>标签包含的内容修改为json格式</li>
<li><code>jq</code>：移到下一行，并停止录制，完成宏<code>q</code>（此时，刚好处于下一个<code>&lt;person&gt;</code>标签行）</li>
</ul>
</li>
<li>
<p>执行宏<code>q</code>到文件尾</p>
<ul>
<li><code>999@q</code>：执行999次宏<code>q</code>（本文档总行数为1002行，执行999次能确保到达文件末尾）</li>
</ul>
</li>
<li>
<p>手动修改文件内容</p>
<ul>
<li>
<p><code>gg</code></p>
</li>
<li>
<p><code>O</code>：（大写的<code>o</code>）在开头插入如下内容</p>
<pre><code>{
&quot;people&quot;: {
    &quot;person&quot;: [
</code></pre>
</li>
<li>
<p><code>&lt;Esc&gt;</code></p>
</li>
<li>
<p><code>/&lt;email&gt;</code>：跳转到文件末尾唯一未处理的<code>&lt;email&gt;</code>标签行</p>
</li>
<li>
<p><code>@e</code>：对该标签行进行处理</p>
</li>
<li>
<p><code>jS}</code>：移到下一行，删除<code>&lt;/person&gt;</code>标签</p>
</li>
<li>
<p><code>&lt;Esc&gt;</code></p>
</li>
<li>
<p><code>o</code>：在文件末尾插入以下内容</p>
<pre><code>    ]
}
}
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="数据整理"><a class="header" href="#数据整理">数据整理</a></h1>
<p><a href="https://missing-semester-cn.github.io/2020/data-wrangling/">数据整理来源</a></p>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%E6%A6%82%E8%BF%B0">数据整理概述</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E5%9B%9E%E5%88%B0%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86">回到数据整理</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#awk--%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%BC%96%E8%BE%91%E5%99%A8">awk – 另外一种编辑器</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE">分析数据</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%E6%9D%A5%E7%A1%AE%E5%AE%9A%E5%8F%82%E6%95%B0">利用数据整理来确定参数</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E6%95%B4%E7%90%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE">整理二进制数据</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#solution-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97">Solution-数据清洗</a></li>
</ul>
<h2 id="数据整理概述"><a class="header" href="#数据整理概述">数据整理概述</a></h2>
<p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！ 这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p>
<p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p>
<p>例如这样一条命令 <code>journalctl | grep -i intel</code>，它会找到所有包含intel(不区分大小写)的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p>
<p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p>
<pre><code class="language-bash">ssh myserver journalctl
</code></pre>
<p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p>
<pre><code class="language-bash">ssh myserver journalctl | grep sshd
</code></pre>
<p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 <code>grep</code> 程序！ <code>ssh</code> 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 <code>ssh</code> 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p>
<pre><code>ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' | less
</code></pre>
<p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 <code>less</code> 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p>
<pre><code>$ ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' &gt; ssh.log
$ less ssh.log
</code></pre>
<p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 <code>sed</code> 这个非常强大的工具。</p>
<p><code>sed</code> 是一个基于文本编辑器<code>ed</code>构建的”流编辑器” 。在 <code>sed</code> 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 <code>s</code>，即替换命令，例如我们可以这样写：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed 's/.*Disconnected from //'
</code></pre>
<p>上面这段命令中，我们使用了一段简单的正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code> 命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中 <code>REGEX</code> 部分是我们需要使用的正则表达式，而 <code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p>
<h2 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h2>
<p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： <code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>?</code> 匹配前面字符零次或一次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<p><code>sed</code> 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加<code>\</code>才能使其具有特殊含义。或者，您也可以添加<code>-E</code>选项来支持这些匹配。</p>
<p>回过头我们再看<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含”Disconnected from “的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 “Disconnected from” 作为自己的用户名会怎样呢？</p>
<pre><code>Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]
</code></pre>
<p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code> 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p>
<pre><code>46.97.239.16 port 55920 [preauth]
</code></pre>
<p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给 <code>*</code> 或 <code>+</code> 增加一个<code>?</code> 后缀使其变成非贪婪模式，但是很可惜 <code>sed</code> 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式：</p>
<pre><code>perl -pe 's/.*?Disconnected from //'
</code></pre>
<p>让我们回到 <code>sed</code> 命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>是最常见的工具。<code>sed</code> 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code> 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p>
<p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p>
<p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配一整行：</p>
<pre><code> | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//'
</code></pre>
<p>让我们借助正则表达式在线调试工具<a href="https://regex101.com/r/qqbZqh/2">regex debugger</a> 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code> 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀<code>[preauth]</code>，最后再匹配行尾。</p>
<p>注意，这样做的话，即使用户名是“Disconnected from”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p>
<p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名保留下来。对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如<code>\1</code>、 <code>\2</code>、<code>\3</code>等等，因此可以使用如下命令：</p>
<pre><code> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章<a href="https://www.regular-expressions.info/email.html">e-mail address</a>，匹配电子邮箱可一点<a href="https://emailregex.com/">也不简单</a>。网络上还有很多关于如何匹配电子邮箱地址的<a href="https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression/1917982">讨论</a>。人们还为其编写了<a href="https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php">测试用例</a>及 <a href="https://mathiasbynens.be/demo/url-regex">测试矩阵</a>。您甚至可以编写一个用于判断一个数<a href="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">是否为质数</a>的正则表达式。</p>
<p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p>
<h2 id="回到数据整理"><a class="header" href="#回到数据整理">回到数据整理</a></h2>
<p>OK，现在我们有如下表达式：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用 <code>i</code> 命令)，打印特定的行 (使用 <code>p</code>命令)，基于索引选择特定行等等。详情请见<code>man sed</code>!</p>
<p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
</code></pre>
<p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
</code></pre>
<p><code>sort -n</code> 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序 <code>-k1,1</code> 则表示“仅基于以空格分割的第一列进行排序”。<code>,n</code> 部分表示“仅排序到第n个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p>
<p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code> 来代替<code>tail</code>。或者使用<code>sort -r</code>来进行倒序排序。</p>
<p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | awk '{print $2}' | paste -sd,
</code></pre>
<p>如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD <code>paste</code>使用。参考<a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell</a>的习题内容获取更多相关信息。</p>
<p>我们可以利用 <code>paste</code>命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割 (<code>-d</code>)，那<code>awk</code>的作用又是什么呢？</p>
<h2 id="awk--另外一种编辑器"><a class="header" href="#awk--另外一种编辑器">awk – 另外一种编辑器</a></h2>
<p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code> 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p>
<p>首先， <code>{print $2}</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p>
<p>让我们看看，还有什么炫酷的操作可以做。让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p>
<pre><code> | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l
</code></pre>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>{...}</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<pre><code>BEGIN { rows = 0 }
$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 }
END { print rows }
</code></pre>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 <code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以<a href="https://backreference.org/2010/02/10/idiomatic-awk">解决所有问题</a>。至于怎么做，就留给读者们做课后练习吧。</p>
<h2 id="分析数据"><a class="header" href="#分析数据">分析数据</a></h2>
<p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p>
<pre><code> | paste -sd+ | bc -l
</code></pre>
<p>使用bc需要执行<code>sudo apt install bc</code>命令。</p>
<p>下面这种更加复杂的表达式也可以：</p>
<pre><code>echo &quot;2*($(data | paste -sd+))&quot; | bc -l
</code></pre>
<p>您可以通过多种方式获取统计数据。如果已经安装了R语言，<a href="https://github.com/nferraz/st"><code>st</code></a>是个不错的选择：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | awk '{print $1}' | R --slave -e 'x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)'
</code></pre>
<p>R 也是一种编程语言，它非常适合被用来进行数据分析和<a href="https://ggplot2.tidyverse.org/">绘制图表</a>。这里我们不会讲的特别详细， 您只需要知道<code>summary</code> 可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用R语言就可以得到我们想要的统计数据。</p>
<p>如果您希望绘制一些简单的图表， <code>gnuplot</code> 可以帮助到您：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | gnuplot -p -e 'set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes'
</code></pre>
<h2 id="利用数据整理来确定参数"><a class="header" href="#利用数据整理来确定参数">利用数据整理来确定参数</a></h2>
<p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 <code>xargs</code> 即可实现：</p>
<pre><code>rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed 's/-x86.*//' | xargs rustup toolchain uninstall
</code></pre>
<h2 id="整理二进制数据"><a class="header" href="#整理二进制数据">整理二进制数据</a></h2>
<p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p>
<pre><code>ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -
 | convert - -colorspace gray -
 | gzip
 | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -'
</code></pre>
<h1 id="课后练习-3"><a class="header" href="#课后练习-3">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//data-wrangling-solution">习题解答</a></p>
<ol>
<li>
<p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.</p>
</li>
<li>
<p>统计words文件 (<code>/usr/share/dict/words</code>) 中包含至少三个<code>a</code> 且不以<code>'s</code> 结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code>的 <code>y</code>命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很 有挑战性的问题：哪个组合从未出现过？</p>
</li>
<li>
<p>进行原地替换听上去很有诱惑力，例如： <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题</p>
</li>
<li>
<p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：</p>
<pre><code>Logs begin at ...
</code></pre>
<p>和</p>
<pre><code>systemd[577]: Startup finished in ...
</code></pre>
<p>在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>
<pre><code>=== system boot:
</code></pre>
<p>和</p>
<pre><code>Previous shutdown cause: 5
</code></pre>
</li>
<li>
<p>查看之前三次重启启动信息中不同的部分(参见 <code>journalctl</code>的<code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code> 来删除<code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code> )。最后，删除所有出现过3次的内容（因为这些内容是三次启动日志中的重复部分）。</p>
</li>
<li>
<p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者<a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从<a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<a href="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p>
</li>
</ol>
<h1 id="solution-数据清洗"><a class="header" href="#solution-数据清洗">Solution-数据清洗</a></h1>
<ol>
<li>
<p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.</p>
</li>
<li>
<p>统计words文件 (<code>/usr/share/dict/words</code>) 中包含至少三个<code>a</code> 且不以<code>'s</code> 结尾的单词个数。</p>
<pre><code>#这里我是在树莓派上面操作的
cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | wc -l
# 850
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/1.png" alt="1.png" /></p>
<ul>
<li>
<p>大小写转换：<code>tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;</code></p>
</li>
<li>
<p><code>^([^a]*a){3}.*[^'s]$</code>：查找一个以 a 结尾的字符串三次</p>
</li>
<li>
<p><code>grep -v &quot;\'s$&quot;</code>：匹配结尾为’s 的结果，然后取反。 借助 <code>grep -v</code>主要是这里不支持 lookback，不然下面的正则就可以完成</p>
<pre><code> ^([^a]*a){3}.*(?&lt;!'s)$
</code></pre>
<p>这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code>的 <code>y</code>命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。</p>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq -c | sort | tail -n3
# 53 as
# 64 ns
# 102 an
</code></pre>
<p>共存在多少种词尾两字母组合？</p>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq | wc -l
</code></pre>
<p>还有一个很 有挑战性的问题：哪个组合从未出现过？ 为了得到没出现的组合，首先我们要生成一个包含全部组合的列表，然后再使用上面得到的出现的组合，比较二者不同即可。</p>
<pre><code>#!/bin/bash
for i in {a..z};do
 for j in {a..z};do
    echo  &quot;$i$j&quot;
 done
done
</code></pre>
<pre><code>./all.sh &gt; all.txt
</code></pre>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq &gt; occurance.txt
</code></pre>
<pre><code>diff --unchanged-group-format='' &lt;(cat occurance.txt) &lt;(cat all.txt) | wc -l
</code></pre>
<p><code>--unchanged-group-format=''</code>用于将两个文件中相同的内容设置为空字符串，剩下的内容就是差异的部分。</p>
</li>
</ul>
</li>
<li>
<p>进行原地替换听上去很有诱惑力，例如： <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题。<br />
<code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code> 表达式中后一个 <code>input.txt</code>会首先被清空，而且是发生在前的。所以前面一个<code>input.txt</code>在还没有被 <code>sed</code> 处理时已经为空了。在使用正则处理文件前最好是首先备份文件。</p>
<pre><code>sed -i.bak s/REGEX/SUBSTITUTION/ input.txt
</code></pre>
<p>可以自动创建一个后缀为 <code>.bak</code> 的备份文件。</p>
</li>
<li>
<p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：</p>
<pre><code>Logs begin at ...
</code></pre>
<p>和</p>
<pre><code>systemd[577]: Startup finished in ...
</code></pre>
<p>在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>
<pre><code>=== system boot:
</code></pre>
<p>和</p>
<pre><code>Previous shutdown cause: 5
</code></pre>
<p>为了进行这个练习，我们需要首先允许<code>journalctl</code>记录多次开机的日志，具体背景信息可以参考<a href="https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs">这里</a>和<a href="https://askubuntu.com/questions/765315/how-to-find-previous-boot-log-after-ubuntu-16-04-restarts">这里</a>否则我们看到的始终都只有本次启动的日志。</p>
<pre><code>vim /etc/systemd/journald.conf
</code></pre>
<p>设置<code>Storage=persistent</code> 执行上述命令后，重启</p>
<pre><code>pi@raspberrypi:~$ journalctl --list-boots
-1 d176984f171a4ceba353de47abd2b891 Thu 2021-05-27 15:55:36 BST—Fri 2021-05-28 02:09:50 BST
0 18c4819a536548a29def9f2b56f63dd0 Fri 2021-05-28 02:09:51 BST—Fri 2021-05-28 02:25:50 BST
</code></pre>
<p>可以看到已经可以列出多次启动信息了，然后我们进行十次重启。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/2.png" alt="1.png" />可以使用 <code>systemd-analyze</code>工具看一下启动时间都花在哪里：</p>
<pre><code>sudo systemd-analyze plot &gt; systemd.svg
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/3.svg" alt="1.png" /><br />
<em>右键图片新窗口打开查看大图</em><br />
可以看到启动时间为 14.157s。 接下来，编写脚本<code>getlog.sh</code>来获取最近十次的启动时间数据：</p>
<pre><code>#!/bin/bash
for i in {0..9}; do
   journalctl -b-$i | grep &quot;Startup finished in&quot;
done
</code></pre>
<pre><code>./getlog &gt; starttime.txt
</code></pre>
<pre><code>#获取最长时间
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort | tail -n1
#获取最短时间
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort -r | tail -n1
#平均数（注意 awk 要使用单引号）
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| paste -sd+ | bc -l | awk '{print $1/10}'
# 中位数
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort |paste -sd\  | awk '{print ($5+$6)/2}'
</code></pre>
<p>如果配合使用 R 语言脚本则更加简单：</p>
<pre><code>sudo apt-get install r-base
</code></pre>
<pre><code>cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort | R -e 'd&lt;-scan(&quot;stdin&quot;,quiet=TRUE);min(d);max(d);mean(d);median(d);'
</code></pre>
<pre><code>&gt; d&lt;-scan(&quot;stdin&quot;,quiet=TRUE);min(d);max(d);mean(d);median(d);
[1] 14.023
[1] 15.989
[1] 14.4304
[1] 14.2915
</code></pre>
</li>
<li>
<p>查看之前三次重启启动信息中不同的部分(参见 <code>journalctl</code>的<code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code> 来删除<code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code> )。最后，删除所有出现过3次的内容（因为这些内容上三次启动日志中的重复部分）。 简单修改上面使用的<code>getlog.sh</code>，获取最近三次的日志，然后使用下面的命令：</p>
<pre><code>#注意 uniq 只能过滤相邻的行，所以必须先排序
cat last3start.txt | sed -E &quot;s/.*pi\ (.*)/\1/&quot; | sort | uniq -c | sort | awk '$1!=3  { print }'
</code></pre>
</li>
<li>
<p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者<a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从<a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<a href="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p>
<pre><code>~$ curl 'https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm#wikipedians' \
    |sed -n &quot;/table1/,/&lt;\/table&gt;/p&quot; \
    |grep &quot;&lt;tr&quot; | sed &quot;1,12d&quot;|head -n -3 \
    |sed -E 's/(&lt;[^&gt;]*&gt;)+/ /g' \
    |sed 's/ &amp;nbsp;/ -/g' \
    |sed 's/&amp;nbsp;//g' &gt; data
   
~$ cat data # 处理后的数据为Jan2001截至Oct2018的
Oct2018 2642056 12641 70805 10498 48.9M - 6101 - - - - 10.3M - - - - - - 42.6M 
Sep2018 2629415 11171 66574 10004 48.7M - 6116 - - - - 10.1M - - - - - - 42.4M 
Aug2018 2618244 12058 68688 10640 48.5M - 6839 - - - - 10.2M - - - - - - 42.1M 
Jul2018 2606186 12026 68037 10305 48.3M - 6987 - - - - 9.5M - - - - - - 41.9M 
...
Jan2001 7 7 9 - 31 12 1 8.6 1352 29% 10% 267 301kB 3.0k 15 - - 2 163 
</code></pre>
<p>命令说明（建议先查看网站的源码格式，更加容易理解下面的操作）</p>
</li>
</ol>
<ul>
<li>
<p><code>|sed -n &quot;/table1/,/&lt;\/table&gt;/p&quot;</code>：观察网站的源代码，可以发现第一个表格的id为<code>table1</code>，该命令将截取匹配到的<code>table1</code>以及下一个<code>&lt;/table&gt;</code>标签行之间的内容</p>
</li>
<li>
<p><code>|grep &quot;&lt;tr&quot;</code>：html表格中，含有数据的行是以<code>&lt;tr</code>开头，匹配这样的行</p>
</li>
<li>
<p><code>|sed &quot;1,12d&quot;</code>：去掉前12行（包含表格的表头）</p>
</li>
<li>
<p><code>|head -n -3</code>：去掉最后3行（包含非数据的内容）（注意：部分操作系统可能不支持该用法，最笨拙的替换实现方式是：<code>|sed &quot;$d&quot;|sed &quot;$d&quot;|sed &quot;$d&quot;</code>，即执行3次删除最后一行的操作）</p>
</li>
<li>
<p><code>|sed -E 's/(&lt;[^&gt;]*&gt;)+/ /g'</code>：使用正则匹配，将所有相邻的多个html标签（格式行如<code>&lt; tag &gt;</code>）替换为空格</p>
</li>
<li>
<p><code>|sed 's/ &amp;nbsp;/ -/g</code>：原表格中部分没有数据的单元格是以<code>&amp;nbsp;</code>填充的，将其替换为 <code>-</code>，避免在对数据操作时发生窜列的情况</p>
</li>
<li>
<p><code>|sed 's/&amp;nbsp;//g</code>：原表格中部分单元格内的空格也是用<code>&amp;nbsp;</code>表示的，将其全部删除（不影响数据处理）</p>
<pre><code>~$ awk '{print $1,$4,$5}' data | sort --key=2n | head -n 1
Jan2001 9 -
# 从data中读取第一列（时间，用来定位后续结果）及第三、四列，并以第二行的数据以数字大小进行排序，然后显示最大值的结果；下一个命令显示最小值的结果

~$ awk '{print $1,$4,$5}' data | sort --key=2n | tail -n 1
Mar2007 91388 11506

~$ awk '{print $1,$4,$5}' data | awk '{print $2-$3}' | awk '{s+=$1} END {print s}'
10153001
# 使用第二列的数据减去第三列的数据后，将结果加总
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="command-line-environment"><a class="header" href="#command-line-environment">Command-line Environment</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="version-control-git"><a class="header" href="#version-control-git">Version Control (Git)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="debugging-and-profiling"><a class="header" href="#debugging-and-profiling">Debugging and Profiling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="metaprogramming"><a class="header" href="#metaprogramming">Metaprogramming</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="security-and-cryptography"><a class="header" href="#security-and-cryptography">Security and Cryptography</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="potpourri"><a class="header" href="#potpourri">Potpourri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="qa"><a class="header" href="#qa">Q&amp;A</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
