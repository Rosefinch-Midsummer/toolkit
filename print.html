<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mdbook Template</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">开发工具</li><li class="chapter-item expanded "><a href="Shell工具和脚本.html"><strong aria-hidden="true">1.</strong> Shell Tools and Scripting</a></li><li class="chapter-item expanded "><a href="编辑器Vim.html"><strong aria-hidden="true">2.</strong> Editors (Vim)</a></li><li class="chapter-item expanded "><a href="数据整理.html"><strong aria-hidden="true">3.</strong> Data Wrangling</a></li><li class="chapter-item expanded "><a href="命令行环境.html"><strong aria-hidden="true">4.</strong> Command-line Environment</a></li><li class="chapter-item expanded "><a href="版本控制Git.html"><strong aria-hidden="true">5.</strong> Version Control (Git)</a></li><li class="chapter-item expanded "><a href="调试及性能分析.html"><strong aria-hidden="true">6.</strong> Debugging and Profiling</a></li><li class="chapter-item expanded "><a href="元编程.html"><strong aria-hidden="true">7.</strong> Metaprogramming</a></li><li class="chapter-item expanded "><a href="安全与密码学.html"><strong aria-hidden="true">8.</strong> Security and Cryptography</a></li><li class="chapter-item expanded affix "><li class="part-title">非开发实用工具</li><li class="chapter-item expanded "><a href="大杂烩.html"><strong aria-hidden="true">9.</strong> Potpourri</a></li><li class="chapter-item expanded "><a href="问答.html"><strong aria-hidden="true">10.</strong> Q&A</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mdbook Template</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>本仓库大部分内容来自MIT<a href="https://missing.csail.mit.edu/">计算机教育中缺失的一课</a>。</p>
<p><a href="https://csdiy.wiki/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/MIT-Missing-Semester/">MIT-Missing-Semester</a> 这门课覆盖了这些工具中绝大部分，而且有相当详细的使用指导，强烈建议小白学习。不过需要注意的一点是，在课程中会不时提到一些与开发流程相关的术语。因此推荐至少在学完计算机导论级别的课程之后进行学习。</p>
<h1 id="the-missing-semester-of-your-cs-education-中文版"><a class="header" href="#the-missing-semester-of-your-cs-education-中文版">The Missing Semester of Your CS Education 中文版</a></h1>
<p><a href="https://missing-semester-cn.github.io/">中文版网址</a></p>
<p>大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何精通工具这一主题则往往会留给学生自行探索。在这个系列课程中，我们讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等。学生在他们受教育阶段就会和这些工具朝夕相处（在他们的职业生涯中更是这样）。</p>
<p>因此，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们是非常有必要的。</p>
<p>精通这些工具不仅可以帮助您更快的使用工具完成任务，并且可以帮助您解决在之前看来似乎无比复杂的问题。</p>
<p>关于 <a href="https://missing-semester-cn.github.io/about/">开设此课程的动机</a>。</p>
<h1 id="日程"><a class="header" href="#日程">日程<img src="https://img.shields.io/badge/%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4-2021--04--24-blue" alt="" /></a></h1>
<ul>
<li><strong>1/13</strong>: <a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/14</strong>: <a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//shell-tools-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/15</strong>: <a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim)</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//editors-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/16</strong>: <a href="https://missing-semester-cn.github.io/2020/data-wrangling/">数据整理</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//data-wrangling-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/21</strong>: <a href="https://missing-semester-cn.github.io/2020/command-line/">命令行环境</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//command-line-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/22</strong>: <a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git)</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//version-control-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/23</strong>: <a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//debugging-profiling-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/27</strong>: <a href="https://missing-semester-cn.github.io/2020/metaprogramming/">元编程</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//metaprogramming-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/28</strong>: <a href="https://missing-semester-cn.github.io/2020/security/">安全和密码学</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//security-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/29</strong>: <a href="https://missing-semester-cn.github.io/2020/potpourri/">大杂烩</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Solution-%E2%9C%98-orange" alt="" /></li>
<li><strong>1/30</strong>: <a href="https://missing-semester-cn.github.io/2020/qa/">提问&amp;回答</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Solution-%E2%9C%98-orange" alt="" /></li>
</ul>
<p>讲座视频可以在 <a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">YouTube</a> 上找到。</p>
<h1 id="开设此课程的动机"><a class="header" href="#开设此课程的动机">开设此课程的动机</a></h1>
<p>在传统的计算机科学课程中，从操作系统、编程语言到机器学习，这些高大上课程和主题已经非常多了。 然而有一个至关重要的主题却很少被专门讲授，而是留给学生们自己去探索。 这部分内容就是：精通工具。</p>
<p>这些年，我们在麻省理工学院参与了许多课程的助教活动，过程当中愈发意识到很多学生对于工具的了解知之甚少。 计算机设计的初衷就是任务自动化，然而学生们却常常陷在大量的重复任务中，或者无法完全发挥出诸如 版本控制、文本编辑器等工具的强大作用。效率低下和浪费时间还是其次，更糟糕的是，这还可能导致数据丢失或 无法完成某些特定任务。</p>
<p>这些主题不是大学课程的一部分：学生一直都不知道如何使用这些工具，或者说，至少是不知道如何高效 地使用，因此浪费了时间和精力在本来可以更简单的任务上。标准的计算机科学课程缺少了这门能让计算 变得更简捷的关键课程。</p>
<h1 id="the-missing-semester-of-your-cs-education"><a class="header" href="#the-missing-semester-of-your-cs-education">The missing semester of your CS education</a></h1>
<p>为了解决这个问题，我们开设了一个课程，涵盖各项对成为高效率计算机科学家或程序员至关重要的 主题。这个课程实用且具有很强的实践性，提供了各种能够立即广泛应用解决问题的趁手工具指导。 该课在 2020 年 1 月“独立活动期”开设，为期一个月，是学生开办的短期课程。虽然该课程针对 麻省理工学院，但我们公开提供了全部课程的录制视频与相关资料。</p>
<p>如果该课程适合你，那么以下还有一些具体的课程示例：</p>
<h2 id="命令行与-shell-工具"><a class="header" href="#命令行与-shell-工具">命令行与 shell 工具</a></h2>
<p>如何使用别名、脚本和构建系统来自动化执行通用重复的任务。不再总是从文档中拷贝粘贴 命令。不要再“逐个执行这 15 个命令”，不要再“你忘了执行这个命令”、“你忘了传那个 参数”，类似的对话不要再有了。</p>
<p>例如，快速搜索历史记录可以节省大量时间。在下面这个示例中，我们展示了如何通过<code>convert</code>命令 在历史记录中跳转的一些技巧。</p>
<h2 id="版本控制"><a class="header" href="#版本控制">版本控制</a></h2>
<p>如何<strong>正确地</strong>使用版本控制，利用它避免尴尬的情况发生。与他人协作，并且能够快速定位 有问题的提交 不再大量注释代码。不再为解决 bug 而找遍所有代码。不再“我去，刚才是删了有用的代码？！”。 我们将教你如何通过拉取请求来为他人的项目贡献代码。</p>
<p>下面这个示例中，我们使用<code>git bisect</code>来定位哪个提交破坏了单元测试，并且通过<code>git revert</code>来进行修复。</p>
<h2 id="文本编辑"><a class="header" href="#文本编辑">文本编辑</a></h2>
<p>不论是本地还是远程，如何通过命令行高效地编辑文件，并且充分利用编辑器特性。不再来回复制 文件。不再重复编辑文件。</p>
<p>Vim 的宏是它最好的特性之一，在下面这个示例中，我们使用嵌套的 Vim 宏快速地将 html 表格转换成了 csv 格式。</p>
<h2 id="远程服务器"><a class="header" href="#远程服务器">远程服务器</a></h2>
<p>使用 SSH 密钥连接远程机器进行工作时如何保持连接，并且让终端能够复用。不再为了仅执行个别命令 总是打开许多命令行终端。不再每次连接都总输入密码。不再因为网络断开或必须重启笔记本时 就丢失全部上下文。</p>
<p>以下示例，我们使用<code>tmux</code>来保持远程服务器的会话存在，并使用<code>mosh</code>来支持网络漫游和断开连接。</p>
<h2 id="查找文件"><a class="header" href="#查找文件">查找文件</a></h2>
<p>如何快速查找你需要的文件。不再挨个点击项目中的文件，直到找到你所需的代码。</p>
<p>以下示例，我们通过<code>fd</code>快速查找文件，通过<code>rg</code>找代码片段。我们也用到了<code>fasd</code>快速<code>cd</code>并<code>vim</code>最近/常用的文件/文件夹。</p>
<h2 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h2>
<p>如何通过命令行直接轻松快速地修改、查看、解析、绘制和计算数据和文件。不再从日志文件拷贝 粘贴。不再手动统计数据。不再用电子表格画图。</p>
<h2 id="虚拟机"><a class="header" href="#虚拟机">虚拟机</a></h2>
<p>如何使用虚拟机尝试新操作系统，隔离无关的项目，并且保持宿主机整洁。不再因为做安全实验而 意外损坏你的计算机。不再有大量随机安装的不同版本软件包。</p>
<h2 id="安全"><a class="header" href="#安全">安全</a></h2>
<p>如何在不泄露隐私的情况下畅游互联网。不再抓破脑袋想符合自己疯狂规则的密码。不再连接不安全 的开放 WiFi 网络。不再传输未加密的信息。</p>
<h1 id="结论"><a class="header" href="#结论">结论</a></h1>
<p>这 12 节课将包括但不限于以上内容，同时每堂课都提供了能帮助你熟悉这些工具的练手小测验。如果不能 等到一月，你也可以看下<a href="https://hacker-tools.github.io/lectures/">黑客工具</a>，这是我们去年的 试讲。它是本课程的前身，包含许多相同的主题。</p>
<p>无论面对面还是远程在线，欢迎你的参与。</p>
<p>Happy hacking,<br />
Anish, Jose, and Jon</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shell工具和脚本"><a class="header" href="#shell工具和脚本">Shell工具和脚本</a></h1>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell%E5%85%A5%E9%97%A8">Shell入门</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E6%98%AF%E4%BB%80%E4%B9%88">shell 是什么？</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E4%BD%BF%E7%94%A8-shell">使用 shell</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E5%9C%A8shell%E4%B8%AD%E5%AF%BC%E8%88%AA">在shell中导航</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E9%99%84%E5%BD%95%E5%A4%84%E7%90%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">附录处理目录的常用命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E9%99%84%E5%BD%95cd%E5%91%BD%E4%BB%A4">附录cd命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E9%97%B4%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5">在程序间创建连接</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%85%A8%E9%9D%A2%E5%8F%88%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%B7%A5%E5%85%B7">一个功能全面又强大的工具</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%8E%A5%E4%B8%8B%E6%9D%A5">接下来…..</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#solution-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%A7%88%E4%B8%8E-shell">Solution-课程概览与 shell</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC">Shell 工具和脚本</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E8%84%9A%E6%9C%AC">Shell 脚本</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E5%B7%A5%E5%85%B7">Shell 工具</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">查看命令如何使用</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6">查找文件</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81">查找代码</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE-shell-%E5%91%BD%E4%BB%A4">查找 shell 命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%BC%E8%88%AA">文件夹导航</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-1">课后练习</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#solution-shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC">Solution-Shell 工具和脚本</a></li>
</ul>
<h1 id="shell入门"><a class="header" href="#shell入门">Shell入门</a></h1>
<h2 id="shell-是什么"><a class="header" href="#shell-是什么">shell 是什么？</a></h2>
<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>
<p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。 这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开shell <em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>
<h2 id="使用-shell"><a class="header" href="#使用-shell">使用 shell</a></h2>
<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>
<pre><code>missing:~$ 
</code></pre>
<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（”current working directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。 <code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入命令 ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p>
<pre><code>missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
</code></pre>
<p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递参数 ：</p>
<pre><code>missing:~$ echo hello
hello
</code></pre>
<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号、双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询环境变量<code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p>
<pre><code>missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/usr/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用 <code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序。</p>
<h2 id="在shell中导航"><a class="header" href="#在shell中导航">在shell中导航</a></h2>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： <code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p>
<pre><code class="language-bash">missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
</code></pre>
<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>
<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>
<pre><code>missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
</code></pre>
<p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p>
<pre><code>  -l                         use a long listing format
</code></pre>
<pre><code>missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
</code></pre>
<p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示 <code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。 （<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。</p>
<pre><code>ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;
                               e.g., '--block-size=M'; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
  -C                         list entries by columns
      --color[=WHEN]         colorize the output; WHEN can be 'always' (default
                               if omitted), 'auto', or 'never'; more info below
  -d, --directory            list directories themselves, not their contents
  -D, --dired                generate output designed for Emacs' dired mode
  -f                         do not sort, enable -aU, disable -ls --color
  -F, --classify             append indicator (one of */=&gt;@|) to entries
      --file-type            likewise, except do not append '*'
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            like -l --time-style=full-iso
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -G, --no-group             in a long listing, don't print group names
  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.
      --si                   likewise, but use powers of 1000 not 1024
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow each command line symbolic link
                               that points to a directory
      --hide=PATTERN         do not list implied entries matching shell PATTERN
                               (overridden by -a or -A)
      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'
                               (default if omitted), 'auto', or 'never'
      --indicator-style=WORD  append indicator with style WORD to entry names:
                               none (default), slash (-p),
                               file-type (--file-type), classify (-F)
  -i, --inode                print the index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -k, --kibibytes            default to 1024-byte blocks for disk usage;
                               used only with -s and per directory totals
  -l                         use a long listing format
  -L, --dereference          when showing file information for a symbolic
                               link, show information for the file the link
                               references rather than for the link itself
  -m                         fill width with a comma separated list of entries
  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs
  -N, --literal              print entry names without quoting
  -o                         like -l, but do not list group information
  -p, --indicator-style=slash
                             append / indicator to directories
  -q, --hide-control-chars   print ? instead of nongraphic characters
      --show-control-chars   show nongraphic characters as-is (the default,
                               unless program is 'ls' and output is a terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always,
                               shell-escape, shell-escape-always, c, escape
                               (overrides QUOTING_STYLE environment variable)
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print the allocated size of each file, in blocks
  -S                         sort by file size, largest first
      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),
                               time (-t), version (-v), extension (-X)
      --time=WORD            change the default of using modification times;
                               access time (-u): atime, access, use;
                               change time (-c): ctime, status;
                               birth time: birth, creation;
                             with -l, WORD determines which time to show;
                             with --sort=time, sort by WORD (newest first)
      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE below
  -t                         sort by time, newest first; see --time
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time;
                               with -l: show access time and sort by name;
                               otherwise: sort by access time, newest first
  -U                         do not sort; list entries in directory order
  -v                         natural sort of (version) numbers within text
  -w, --width=COLS           set output width to COLS.  0 means no limit
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -Z, --context              print any security context of each file
  -1                         list one file per line.  Avoid '\n' with -q or -b
      --help     display this help and exit
      --version  output version information and exit

The SIZE argument is an integer and optional unit (example: 10K is 10*1024).
Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).
Binary prefixes can be used, too: KiB=K, MiB=M, and so on.

The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.
FORMAT is interpreted like in date(1).  If FORMAT is FORMAT1&lt;newline&gt;FORMAT2,
then FORMAT1 applies to non-recent files and FORMAT2 to recent files.
TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX locale.
Also the TIME_STYLE environment variable sets the default style to use.

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Report any translation bugs to &lt;https://translationproject.org/team/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/ls&gt;
or available locally via: info '(coreutils) ls invocation'
</code></pre>
<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <code>mv</code>（用于重命名或移动文件）、 <code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>
<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p>
<pre><code>missing:~$ man ls
</code></pre>
<h2 id="附录处理目录的常用命令"><a class="header" href="#附录处理目录的常用命令">附录处理目录的常用命令</a></h2>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <code>man [命令]</code> 来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="附录cd命令"><a class="header" href="#附录cd命令">附录cd命令</a></h2>
<p>Linux cd（英文全拼：change directory）命令用于改变当前工作目录的命令，切换到指定的路径。</p>
<p>若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p>
<p>另外，~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录， .. 则表示目前目录位置的上一层目录。</p>
<p>切换到 /usr/bin/ 目录: <code>cd /usr/bin</code></p>
<p><strong>切换到上级目录：</strong> 使用 .. 表示上级目录，可以通过连续多次使用 .. 来切换到更高级的目录。</p>
<pre><code class="language-bash">cd ..
cd ../../   // 切换到上上级目录
</code></pre>
<p><strong>切换到用户主目录（home）：</strong> 使用 ~ 表示当前用户的主目录，可以使用 cd 命令直接切换到主目录。</p>
<pre><code class="language-bash">cd ~
</code></pre>
<p><strong>切换到上次访问的目录：</strong> 使用 cd - 可以切换到上次访问的目录。</p>
<pre><code class="language-bash">cd -
</code></pre>
<p><strong>切换到环境变量指定的目录：</strong> 可以使用环境变量来指定目标目录，并使用 cd 命令切换到该目录。</p>
<pre><code class="language-bash">cd $VAR_NAME
</code></pre>
<p>以上实例都是 cd 命令的一些基本用法，它们可以帮助您在 Linux 系统中进行目录切换操作。</p>
<p>使用<code>cd --help</code>命令可以获取更多关于 cd 命令的详细信息，包括可用的选项和更高级的用法。</p>
<h2 id="在程序间创建连接"><a class="header" href="#在程序间创建连接">在程序间创建连接</a></h2>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<pre><code>missing:~$ echo hello &gt; hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat &lt; hello.txt
hello
missing:~$ cat &lt; hello.txt &gt; hello2.txt
missing:~$ cat hello2.txt
hello
</code></pre>
<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<pre><code>missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
</code></pre>
<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>
<h2 id="一个功能全面又强大的工具"><a class="header" href="#一个功能全面又强大的工具">一个功能全面又强大的工具</a></h2>
<p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。 您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。 通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。 当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>
<p>可以利用<code>sudo su</code>命令进入root用户模式，使用<code>exit</code>命令退出root用户模式。</p>
<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p>
<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p>
<pre><code>/sys/class/backlight
</code></pre>
<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>
<pre><code>$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 &gt; brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
</code></pre>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p>
<p>明白这一点后，我们可以这样操作：</p>
<pre><code>$ echo 3 | sudo tee brightness
</code></pre>
<p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。 这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p>
<pre><code>$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
</code></pre>
<h2 id="接下来"><a class="header" href="#接下来">接下来…..</a></h2>
<p>学到这里，您掌握的 shell 知识已经可以完成一些基础的任务了。您应该已经可以查找感兴趣的文件并使用大多数程序的基本功能了。 在下一场讲座中，我们会探讨如何利用 shell 及其他工具执行并自动化更复杂的任务。</p>
<h2 id="课后练习"><a class="header" href="#课后练习">课后练习</a></h2>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution">习题解答</a> 本课程中的每节课都包含一系列练习题。有些题目是有明确目的的，另外一些则是开放题，例如“尝试使用 X 和 Y”，我们强烈建议您一定要动手实践，用于尝试这些内容。 此外，我们没有为这些练习题提供答案。如果有任何困难，您可以发送邮件给我们并描述你已经做出的尝试，我们会设法帮您解答。</p>
<ol>
<li>
<p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用<a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a>或者是 Linux 虚拟机。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p>
</li>
<li>
<p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p>
</li>
<li>
<p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p>
</li>
<li>
<p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p>
</li>
<li>
<p>将以下内容一行一行地写入 <code>semester</code> 文件：</p>
<pre><code> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
</li>
</ol>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p>
<ol start="6">
<li>
<p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p>
</li>
<li>
<p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code> 命令)</p>
</li>
<li>
<p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p>
</li>
<li>
<p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p>
</li>
</ol>
<p>注：使用 <code>chmod +x semester</code> 命令改变权限，使 <code>./semester</code> 能够成功执行</p>
<h2 id="solution-课程概览与-shell"><a class="header" href="#solution-课程概览与-shell">Solution-课程概览与 shell</a></h2>
<ol>
<li>
<p>在 /tmp 下新建一个名为 missing 的文件夹。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/1.png" alt="1.png" /></p>
</li>
<li>
<p>用 man 查看程序 touch 的使用手册。 <code>man touch</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/2.png" alt="2.png" /></p>
</li>
<li>
<p>用 touch 在 missing 文件夹中新建一个叫 semester 的文件。 <code>touch semester</code></p>
</li>
<li>
<p>将以下内容一行一行地写入 semester 文件：</p>
<pre><code> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting</a>手册<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/3.png" alt="3.png" /></p>
</li>
<li>
<p>尝试执行这个文件。即，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 ls 命令来获取信息并理解其不能执行的原因。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/4.png" alt="4.png" /></p>
</li>
<li>
<p>查看 chmod 的手册(例如，使用 <code>man chmod</code> 命令)<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/5.png" alt="5.png" /></p>
</li>
<li>
<p>使用 chmod 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 sh semester 来执行该程序。您的 shell 是如何知晓这个文件需要使用 sh 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/6.png" alt="6.png" /></p>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 semester 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/7.png" alt="7.png" /></p>
</li>
<li>
<p>写一段命令来从 /sys 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。 Windows 用户可以通过以下命令查询：</p>
<p>WSL2：</p>
<pre><code> &gt; cat /sys/class/power_supply/BAT1/capacity
 100
</code></pre>
<p>Linux 用户可以通过以下命令查询：</p>
<pre><code> &gt; cat /sys/class/power_supply/BAT1/capacity
 100
</code></pre>
</li>
</ol>
<h1 id="shell-工具和脚本"><a class="header" href="#shell-工具和脚本">Shell 工具和脚本</a></h1>
<p>在这节课中，我们将会展示 bash 作为脚本语言的一些基础操作，以及几种最常用的 shell 工具。</p>
<h2 id="shell-脚本"><a class="header" href="#shell-脚本">Shell 脚本</a></h2>
<p>到目前为止，我们已经学习来如何在 shell 中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>
<p>shell 脚本是一种更加复杂度的工具。</p>
<p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。</p>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，<strong>在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</strong></p>
<p><strong>Bash中的字符串通过<code>'</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</strong></p>
<pre><code class="language-bash">foo=bar
echo &quot;$foo&quot;
# 打印 bar
echo '$foo'
# 打印 $foo
</code></pre>
<p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p>
<pre><code class="language-bash">mcd () {
    mkdir -p &quot;$1&quot;
    cd &quot;$1&quot;
}
</code></pre>
<p>这里 <code>$1</code> 是脚本的第一个参数。</p>
<p>这里可以使用vim打开一个文件写入上面的代码并执行<code>source mcd.sh</code>来加载mcd函数，再执行<code>mcd test</code>就能进入test文件夹。</p>
<p>与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p>
<pre><code class="language-bash">xx:~/missing$ echo &quot;Hello&quot;
Hello
xx:~/missing$ echo $?
0
xx:~/missing$ grep foobar mcd.sh
xx:~/missing$ echo $?
1
</code></pre>
<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">运算符</a>（short-circuiting） 同一行的多个命令可以用 <code>;</code> 分隔。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。让我们看几个例子</p>
<pre><code class="language-bash">false || echo &quot;Oops, fail&quot;
# Oops, fail

true || echo &quot;Will not be printed&quot;
#

true &amp;&amp; echo &quot;Things went well&quot;
# Things went well

false &amp;&amp; echo &quot;Will not be printed&quot;
#

false ; echo &quot;This will always run&quot;
# This will always run
</code></pre>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em>（<em>command substitution</em>）实现。</p>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。<strong>这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</strong></p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<pre><code class="language-bash">#!/bin/bash

echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间

echo &quot;Running program $0 with $# arguments with pid $$&quot;

for file in &quot;$@&quot;; do
    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null
    # 如果模式没有找到，则grep退出状态为 1
    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息
    if [[ $? -ne 0 ]]; then
        echo &quot;File $file does not have any foobar, adding one&quot;
        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;
    fi
done
</code></pre>
<p>在条件语句中，我们比较 <code>$?</code> 是否等于0。 执行<code> ./example.sh mcd.sh example.sh</code>时权限不足就执行<code>chmod 777 ./example.sh</code>赋予shell脚本足够权限再执行<code>./example.sh mcd.sh example.sh</code>。输出结果如下：</p>
<pre><code>Starting program at Mon Jan  1 19:13:58 CST 2024
Running program ./example.sh with 2 arguments with pid 144
File mcd.sh does not have any foobar, adding one
</code></pre>
<p>Bash实现了许多类似的比较操作，您可以查看 <a href="https://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。 在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见<a href="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</p>
<p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 <em>通配</em>（<em>globbing</em>）</p>
<ul>
<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
</ul>
<pre><code class="language-bash">convert image.{png,jpg}
# 会展开为
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# 会展开为
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# 也可以结合通配使用
mv *{.py,.sh} folder
# 会移动所有 *.py 和 *.sh 文件

mkdir foo bar

# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件
touch {foo,bar}/{a..h}
touch foo/x bar/y
# 比较文件夹 foo 和 bar 中包含文件的不同
diff &lt;(ls foo) &lt;(ls bar)
# 输出
# &lt; x
# ---
# &gt; y
</code></pre>
<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位sh/bash脚本中的错误。安装shellcheck可以执行<code>sudo apt install shellcheck</code>命令。</p>
<p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p>
<pre><code class="language-bash">#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
</code></pre>
<p>内核知道去用 python 解释器而不是 shell 命令来运行这段脚本，是因为脚本的开头第一行的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p>
<p>在 <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。 例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code>。</p>
<p>shell函数和脚本有如下一些不同点：</p>
<ul>
<li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ul>
<h2 id="shell-工具"><a class="header" href="#shell-工具">Shell 工具</a></h2>
<h3 id="查看命令如何使用"><a class="header" href="#查看命令如何使用">查看命令如何使用</a></h3>
<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？ 一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>
<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<a href="https://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。 事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。 <a href="https://tldr.sh/">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>
<p>例如，自己就常常在tldr上搜索<a href="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <a href="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a> 的用法。</p>
<h3 id="查找文件-1"><a class="header" href="#查找文件-1">查找文件</a></h3>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <a href="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a> 的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p>
<pre><code># 查找所有名称为src的文件夹
find . -name src -type d
# 查找所有文件夹路径中包含test的python文件
find . -path '*/test/*.py' -type f
# 查找前一天修改的所有文件
find . -mtime -1
# 查找所有大小在500k至10M的tar.gz文件
find . -size +500k -size -10M -name '*.tar.gz'
</code></pre>
<p>除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<pre><code># 删除全部扩展名为.tmp 的文件
find . -name '*.tmp' -exec rm {} \;
# 查找全部的 PNG 文件并将其转换为 JPG
find . -name '*.png' -exec convert {} {}.jpg \;
</code></pre>
<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码"><a class="header" href="#查找代码">查找代码</a></h3>
<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>
<p>为了实现这一点，很多类UNIX的系统都提供了<a href="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>
<p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p>
<p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>
<pre><code># 查找所有使用了 requests 库的文件
rg -t py 'import requests'
# 查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match &quot;^#!&quot;
# 查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
# 打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN
</code></pre>
<p>与 <code>find</code>/<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>
<h3 id="查找-shell-命令"><a class="header" href="#查找-shell-命令">查找 shell 命令</a></h3>
<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
<h3 id="文件夹导航"><a class="header" href="#文件夹导航">文件夹导航</a></h3>
<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>
<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<p>安装tree使用<code>sudo apt install tree</code>命令。</p>
<h2 id="课后练习-1"><a class="header" href="#课后练习-1">课后练习</a></h2>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//shell-tools-solution">习题解答</a></p>
<ol>
<li>
<p>阅读 <a href="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p>
<ul>
<li>所有文件（包括隐藏文件）</li>
<li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li>
<li>文件以最近访问顺序排序</li>
<li>以彩色文本显示输出结果</li>
</ul>
<p>典型输出如下：</p>
<pre><code> -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
</li>
<li>
<p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</p>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<pre><code> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
    echo &quot;Something went wrong&quot;
    &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
    exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
</li>
<li>
<p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p>
<p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>，译注：MacOS 上的 <code>xargs</code>没有<code>-d</code>，<a href="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）</p>
<p>如果您使用的是 MacOS，请注意默认的 BSD <code>find</code> 与 <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为<code>find</code>添加<code>-print0</code>选项，并为<code>xargs</code>添加<code>-0</code>选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew 来安装</a>。</p>
</li>
<li>
<p>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</p>
</li>
</ol>
<h1 id="solution-shell-工具和脚本"><a class="header" href="#solution-shell-工具和脚本">Solution-Shell 工具和脚本</a></h1>
<ol>
<li>
<p>阅读 man ls ，然后使用ls 命令进行如下操作：</p>
<ul>
<li>
<p>所有文件（包括隐藏文件） ：<code>-a</code></p>
</li>
<li>
<p>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) : <code>-h</code></p>
</li>
<li>
<p>文件以最近访问顺序排序：<code>-t</code></p>
</li>
<li>
<p>以彩色文本显示输出结果<code>--color=auto</code><br />
典型输出如下：</p>
<pre><code> -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
</li>
</ul>
</li>
<li>
<p>编写两个bash函数 marco 和 polo 执行下面的操作。 每当你执行 marco 时，当前的工作目录应当以某种形式保存，当执行 polo 时，无论现在处在什么目录下，都应当 cd 回到当时执行 marco 的目录。 为了方便debug，你可以把代码写在单独的文件 marco.sh 中，并通过 source marco.sh命令，（重新）加载函数。通过source 来加载函数，随后可以在 bash 中直接使用。</p>
<pre><code> #!/bin/bash
 marco(){
     echo &quot;$(pwd)&quot; &gt; $HOME/marco_history.log
     echo &quot;save pwd $(pwd)&quot;
 }
 polo(){
     cd &quot;$(cat &quot;$HOME/marco_history.log&quot;)&quot;
 }
</code></pre>
<p>或者</p>
<pre><code> #!/bin/bash
 marco() {
     export MARCO=$(pwd)
 }
 polo() {
     cd &quot;$MARCO&quot;
 }
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/1.png" alt="1.png" /></p>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<pre><code> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
     echo &quot;Something went wrong&quot;
     &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
     exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
<p>使用 while 循环完成</p>
<pre><code> #!/usr/bin/env bash
 count=0
 echo &gt; out.log

 while true
 do
     ./buggy.sh &amp;&gt;&gt; out.log
     if [[ $? -ne 0 ]]; then
         cat out.log
         echo &quot;failed after $count times&quot;
         break
     fi
     ((count++))

 done

</code></pre>
<p>使用 for 循环完成</p>
<pre><code> #!/usr/bin/env bash
 echo &gt; out.log
 for ((count=0;;count++))
 do
     ./buggy.sh &amp;&gt;&gt; out.log
     if [[ $? -ne 0 ]]; then
         echo &quot;failed after $count times&quot;
         break

     fi
 done

</code></pre>
<p>使用 until 完成</p>
<pre><code> #!/usr/bin/env bash
 count=0
 ./buggy.sh &amp;&gt;&gt; out.log
 until [[ &quot;$?&quot; -ne 0 ]];
 do
     count=$((count+1))
     ./buggy.sh &amp;&gt;&gt; out.log
 done

 echo &quot;failed after $count runs&quot;

</code></pre>
<p>执行测试脚本debug.sh,并验证脚本结果的正确性</p>
<pre><code> ~$ ./debug.sh
 failed after 34 times
 ~$ cat out.log | grep Everything | wc -l
 34
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/2.png" alt="1.png" /></p>
</li>
<li>
<p>本节课我们讲解的 find 命令中的 -exec 参数非常强大，它可以对我们查找的文件进行操作。 如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如tar 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html">xargs</a> 命令，它可以使用标准输入中的内容作为参数。 例如 ls | xargs rm 会删除当前目录中的所有文件。您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 xargs的参数-d）<em>译注：MacOS 上的 xargs没有-d，查看这个<a href="https://github.com/missing-semester/missing-semester/issues/93">issue</a></em></p>
<p>如果您使用的是 MacOS，请注意默认的 BSD find 与<a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为find添加-print0选项，并为xargs添加-0选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew</a> 来安装。</p>
<ol>
<li>
<p>首先创建所需的文件</p>
<pre><code>  mkdir html_root
  cd html_root
  touch {1..10}.html
  mkdir html
  cd html
  touch xxxx.html
</code></pre>
<pre><code>  ├── html_root
  │   ├── 1.html
  │   ├── 10.html
  │   ├── 2.html
  │   ├── 3.html
  │   ├── 4.html
  │   ├── 5.html
  │   ├── 6.html
  │   ├── 7.html
  │   ├── 8.html
  │   ├── 9.html
  │   └── html
  │       └── xxxx.html
</code></pre>
</li>
<li>
<p>执行 find 命令</p>
<pre><code>  #for MacOS
  find html_root -name &quot;*.html&quot; -print0 | xargs -0 tar vcf html.zip
</code></pre>
<pre><code>  #for Linux
  find . -type f -name &quot;*.html&quot; | xargs -d '\n'  tar -cvzf html.zip
</code></pre>
<pre><code>  a html_root/9.html
  a html_root/5.html
  a html_root/4.html
  a html_root/8.html
  a html_root/3.html
  a html_root/html/xxxx.html
  a html_root/2.html
  a html_root/1.html
  a html_root/10.html
  a html_root/7.html
  a html_root/6.html
</code></pre>
</li>
</ol>
</li>
<li>
<p>(进阶) 编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？ <code>find . -type f -print0 | xargs -0 ls -lt | head -1</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/4.png" alt="1.png" /></p>
</li>
</ol>
<p>当文件数量较多时，上面的解答会得出错误结果，解决办法是增加 <code>-mmin</code> 条件，先将最近修改的文件进行初步筛选再交给ls进行排序显示 <code>find . -type f -mmin -60 -print0 | xargs -0 ls -lt | head -10</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/5.png" alt="1.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="editors-vim"><a class="header" href="#editors-vim">Editors (Vim)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="data-wrangling"><a class="header" href="#data-wrangling">Data Wrangling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="command-line-environment"><a class="header" href="#command-line-environment">Command-line Environment</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="version-control-git"><a class="header" href="#version-control-git">Version Control (Git)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="debugging-and-profiling"><a class="header" href="#debugging-and-profiling">Debugging and Profiling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="metaprogramming"><a class="header" href="#metaprogramming">Metaprogramming</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="security-and-cryptography"><a class="header" href="#security-and-cryptography">Security and Cryptography</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="potpourri"><a class="header" href="#potpourri">Potpourri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="qa"><a class="header" href="#qa">Q&amp;A</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
