<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mdbook Template</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">开发工具</li><li class="chapter-item expanded "><a href="Shell工具和脚本.html"><strong aria-hidden="true">1.</strong> Shell Tools and Scripting</a></li><li class="chapter-item expanded "><a href="编辑器Vim.html"><strong aria-hidden="true">2.</strong> Editors (Vim)</a></li><li class="chapter-item expanded "><a href="数据整理.html"><strong aria-hidden="true">3.</strong> Data Wrangling</a></li><li class="chapter-item expanded "><a href="命令行环境.html"><strong aria-hidden="true">4.</strong> Command-line Environment</a></li><li class="chapter-item expanded "><a href="版本控制Git.html"><strong aria-hidden="true">5.</strong> Version Control (Git)</a></li><li class="chapter-item expanded "><a href="调试及性能分析.html"><strong aria-hidden="true">6.</strong> Debugging and Profiling</a></li><li class="chapter-item expanded "><a href="元编程.html"><strong aria-hidden="true">7.</strong> Metaprogramming</a></li><li class="chapter-item expanded "><a href="安全与密码学.html"><strong aria-hidden="true">8.</strong> Security and Cryptography</a></li><li class="chapter-item expanded affix "><li class="part-title">非开发实用工具</li><li class="chapter-item expanded "><a href="大杂烩.html"><strong aria-hidden="true">9.</strong> Potpourri</a></li><li class="chapter-item expanded "><a href="问答.html"><strong aria-hidden="true">10.</strong> Q&A</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mdbook Template</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>本仓库大部分内容来自MIT<a href="https://missing.csail.mit.edu/">计算机教育中缺失的一课</a>。</p>
<p><a href="https://csdiy.wiki/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/MIT-Missing-Semester/">MIT-Missing-Semester</a> 这门课覆盖了这些工具中绝大部分，而且有相当详细的使用指导，强烈建议小白学习。不过需要注意的一点是，在课程中会不时提到一些与开发流程相关的术语。因此推荐至少在学完计算机导论级别的课程之后进行学习。</p>
<h1 id="the-missing-semester-of-your-cs-education-中文版"><a class="header" href="#the-missing-semester-of-your-cs-education-中文版">The Missing Semester of Your CS Education 中文版</a></h1>
<p><a href="https://missing-semester-cn.github.io/">中文版网址</a></p>
<p>大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何精通工具这一主题则往往会留给学生自行探索。在这个系列课程中，我们讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等。学生在他们受教育阶段就会和这些工具朝夕相处（在他们的职业生涯中更是这样）。</p>
<p>因此，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们是非常有必要的。</p>
<p>精通这些工具不仅可以帮助您更快的使用工具完成任务，并且可以帮助您解决在之前看来似乎无比复杂的问题。</p>
<p>关于 <a href="https://missing-semester-cn.github.io/about/">开设此课程的动机</a>。</p>
<h1 id="日程"><a class="header" href="#日程">日程<img src="https://img.shields.io/badge/%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4-2021--04--24-blue" alt="" /></a></h1>
<ul>
<li><strong>1/13</strong>: <a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/14</strong>: <a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//shell-tools-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/15</strong>: <a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim)</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//editors-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/16</strong>: <a href="https://missing-semester-cn.github.io/2020/data-wrangling/">数据整理</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//data-wrangling-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/21</strong>: <a href="https://missing-semester-cn.github.io/2020/command-line/">命令行环境</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//command-line-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/22</strong>: <a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git)</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//version-control-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/23</strong>: <a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//debugging-profiling-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/27</strong>: <a href="https://missing-semester-cn.github.io/2020/metaprogramming/">元编程</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//metaprogramming-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/28</strong>: <a href="https://missing-semester-cn.github.io/2020/security/">安全和密码学</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//security-solution"><img src="https://img.shields.io/badge/Solution-%E2%9C%94-green" alt="" /></a></li>
<li><strong>1/29</strong>: <a href="https://missing-semester-cn.github.io/2020/potpourri/">大杂烩</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Solution-%E2%9C%98-orange" alt="" /></li>
<li><strong>1/30</strong>: <a href="https://missing-semester-cn.github.io/2020/qa/">提问&amp;回答</a><img src="https://img.shields.io/badge/Chinese-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Update-%E2%9C%94-green" alt="" /><img src="https://img.shields.io/badge/Solution-%E2%9C%98-orange" alt="" /></li>
</ul>
<p>讲座视频可以在 <a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">YouTube</a> 上找到。</p>
<h1 id="开设此课程的动机"><a class="header" href="#开设此课程的动机">开设此课程的动机</a></h1>
<p>在传统的计算机科学课程中，从操作系统、编程语言到机器学习，这些高大上课程和主题已经非常多了。 然而有一个至关重要的主题却很少被专门讲授，而是留给学生们自己去探索。 这部分内容就是：精通工具。</p>
<p>这些年，我们在麻省理工学院参与了许多课程的助教活动，过程当中愈发意识到很多学生对于工具的了解知之甚少。 计算机设计的初衷就是任务自动化，然而学生们却常常陷在大量的重复任务中，或者无法完全发挥出诸如 版本控制、文本编辑器等工具的强大作用。效率低下和浪费时间还是其次，更糟糕的是，这还可能导致数据丢失或 无法完成某些特定任务。</p>
<p>这些主题不是大学课程的一部分：学生一直都不知道如何使用这些工具，或者说，至少是不知道如何高效 地使用，因此浪费了时间和精力在本来可以更简单的任务上。标准的计算机科学课程缺少了这门能让计算 变得更简捷的关键课程。</p>
<h1 id="the-missing-semester-of-your-cs-education"><a class="header" href="#the-missing-semester-of-your-cs-education">The missing semester of your CS education</a></h1>
<p>为了解决这个问题，我们开设了一个课程，涵盖各项对成为高效率计算机科学家或程序员至关重要的 主题。这个课程实用且具有很强的实践性，提供了各种能够立即广泛应用解决问题的趁手工具指导。 该课在 2020 年 1 月“独立活动期”开设，为期一个月，是学生开办的短期课程。虽然该课程针对 麻省理工学院，但我们公开提供了全部课程的录制视频与相关资料。</p>
<p>如果该课程适合你，那么以下还有一些具体的课程示例：</p>
<h2 id="命令行与-shell-工具"><a class="header" href="#命令行与-shell-工具">命令行与 shell 工具</a></h2>
<p>如何使用别名、脚本和构建系统来自动化执行通用重复的任务。不再总是从文档中拷贝粘贴 命令。不要再“逐个执行这 15 个命令”，不要再“你忘了执行这个命令”、“你忘了传那个 参数”，类似的对话不要再有了。</p>
<p>例如，快速搜索历史记录可以节省大量时间。在下面这个示例中，我们展示了如何通过<code>convert</code>命令 在历史记录中跳转的一些技巧。</p>
<h2 id="版本控制"><a class="header" href="#版本控制">版本控制</a></h2>
<p>如何<strong>正确地</strong>使用版本控制，利用它避免尴尬的情况发生。与他人协作，并且能够快速定位 有问题的提交 不再大量注释代码。不再为解决 bug 而找遍所有代码。不再“我去，刚才是删了有用的代码？！”。 我们将教你如何通过拉取请求来为他人的项目贡献代码。</p>
<p>下面这个示例中，我们使用<code>git bisect</code>来定位哪个提交破坏了单元测试，并且通过<code>git revert</code>来进行修复。</p>
<h2 id="文本编辑"><a class="header" href="#文本编辑">文本编辑</a></h2>
<p>不论是本地还是远程，如何通过命令行高效地编辑文件，并且充分利用编辑器特性。不再来回复制 文件。不再重复编辑文件。</p>
<p>Vim 的宏是它最好的特性之一，在下面这个示例中，我们使用嵌套的 Vim 宏快速地将 html 表格转换成了 csv 格式。</p>
<h2 id="远程服务器"><a class="header" href="#远程服务器">远程服务器</a></h2>
<p>使用 SSH 密钥连接远程机器进行工作时如何保持连接，并且让终端能够复用。不再为了仅执行个别命令 总是打开许多命令行终端。不再每次连接都总输入密码。不再因为网络断开或必须重启笔记本时 就丢失全部上下文。</p>
<p>以下示例，我们使用<code>tmux</code>来保持远程服务器的会话存在，并使用<code>mosh</code>来支持网络漫游和断开连接。</p>
<h2 id="查找文件"><a class="header" href="#查找文件">查找文件</a></h2>
<p>如何快速查找你需要的文件。不再挨个点击项目中的文件，直到找到你所需的代码。</p>
<p>以下示例，我们通过<code>fd</code>快速查找文件，通过<code>rg</code>找代码片段。我们也用到了<code>fasd</code>快速<code>cd</code>并<code>vim</code>最近/常用的文件/文件夹。</p>
<h2 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h2>
<p>如何通过命令行直接轻松快速地修改、查看、解析、绘制和计算数据和文件。不再从日志文件拷贝 粘贴。不再手动统计数据。不再用电子表格画图。</p>
<h2 id="虚拟机"><a class="header" href="#虚拟机">虚拟机</a></h2>
<p>如何使用虚拟机尝试新操作系统，隔离无关的项目，并且保持宿主机整洁。不再因为做安全实验而 意外损坏你的计算机。不再有大量随机安装的不同版本软件包。</p>
<h2 id="安全"><a class="header" href="#安全">安全</a></h2>
<p>如何在不泄露隐私的情况下畅游互联网。不再抓破脑袋想符合自己疯狂规则的密码。不再连接不安全 的开放 WiFi 网络。不再传输未加密的信息。</p>
<h1 id="结论"><a class="header" href="#结论">结论</a></h1>
<p>这 12 节课将包括但不限于以上内容，同时每堂课都提供了能帮助你熟悉这些工具的练手小测验。如果不能 等到一月，你也可以看下<a href="https://hacker-tools.github.io/lectures/">黑客工具</a>，这是我们去年的 试讲。它是本课程的前身，包含许多相同的主题。</p>
<p>无论面对面还是远程在线，欢迎你的参与。</p>
<p>Happy hacking,<br />
Anish, Jose, and Jon</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shell工具和脚本"><a class="header" href="#shell工具和脚本">Shell工具和脚本</a></h1>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell%E5%85%A5%E9%97%A8">Shell入门</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E6%98%AF%E4%BB%80%E4%B9%88">shell 是什么？</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E4%BD%BF%E7%94%A8-shell">使用 shell</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E5%9C%A8shell%E4%B8%AD%E5%AF%BC%E8%88%AA">在shell中导航</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E9%99%84%E5%BD%95%E5%A4%84%E7%90%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">附录处理目录的常用命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E9%99%84%E5%BD%95cd%E5%91%BD%E4%BB%A4">附录cd命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E9%97%B4%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5">在程序间创建连接</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%85%A8%E9%9D%A2%E5%8F%88%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%B7%A5%E5%85%B7">一个功能全面又强大的工具</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%8E%A5%E4%B8%8B%E6%9D%A5">接下来…..</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#solution-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%A7%88%E4%B8%8E-shell">Solution-课程概览与 shell</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC">Shell 工具和脚本</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E8%84%9A%E6%9C%AC">Shell 脚本</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#shell-%E5%B7%A5%E5%85%B7">Shell 工具</a>
<ul>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">查看命令如何使用</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6">查找文件</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81">查找代码</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%9F%A5%E6%89%BE-shell-%E5%91%BD%E4%BB%A4">查找 shell 命令</a></li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%BC%E8%88%AA">文件夹导航</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-1">课后练习</a></li>
</ul>
</li>
<li><a href="Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC.html#solution-shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC">Solution-Shell 工具和脚本</a></li>
</ul>
<h1 id="shell入门"><a class="header" href="#shell入门">Shell入门</a></h1>
<h2 id="shell-是什么"><a class="header" href="#shell-是什么">shell 是什么？</a></h2>
<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>
<p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。 这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开shell <em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>
<h2 id="使用-shell"><a class="header" href="#使用-shell">使用 shell</a></h2>
<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>
<pre><code>missing:~$ 
</code></pre>
<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（”current working directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。 <code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入命令 ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p>
<pre><code>missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
</code></pre>
<p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递参数 ：</p>
<pre><code>missing:~$ echo hello
hello
</code></pre>
<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号、双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询环境变量<code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p>
<pre><code>missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/usr/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>
<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用 <code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序。</p>
<h2 id="在shell中导航"><a class="header" href="#在shell中导航">在shell中导航</a></h2>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： <code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p>
<pre><code class="language-bash">missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
</code></pre>
<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>
<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>
<pre><code>missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
</code></pre>
<p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p>
<pre><code>  -l                         use a long listing format
</code></pre>
<pre><code>missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
</code></pre>
<p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示 <code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。 （<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。</p>
<pre><code>ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;
                               e.g., '--block-size=M'; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
  -C                         list entries by columns
      --color[=WHEN]         colorize the output; WHEN can be 'always' (default
                               if omitted), 'auto', or 'never'; more info below
  -d, --directory            list directories themselves, not their contents
  -D, --dired                generate output designed for Emacs' dired mode
  -f                         do not sort, enable -aU, disable -ls --color
  -F, --classify             append indicator (one of */=&gt;@|) to entries
      --file-type            likewise, except do not append '*'
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            like -l --time-style=full-iso
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -G, --no-group             in a long listing, don't print group names
  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.
      --si                   likewise, but use powers of 1000 not 1024
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow each command line symbolic link
                               that points to a directory
      --hide=PATTERN         do not list implied entries matching shell PATTERN
                               (overridden by -a or -A)
      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'
                               (default if omitted), 'auto', or 'never'
      --indicator-style=WORD  append indicator with style WORD to entry names:
                               none (default), slash (-p),
                               file-type (--file-type), classify (-F)
  -i, --inode                print the index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -k, --kibibytes            default to 1024-byte blocks for disk usage;
                               used only with -s and per directory totals
  -l                         use a long listing format
  -L, --dereference          when showing file information for a symbolic
                               link, show information for the file the link
                               references rather than for the link itself
  -m                         fill width with a comma separated list of entries
  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs
  -N, --literal              print entry names without quoting
  -o                         like -l, but do not list group information
  -p, --indicator-style=slash
                             append / indicator to directories
  -q, --hide-control-chars   print ? instead of nongraphic characters
      --show-control-chars   show nongraphic characters as-is (the default,
                               unless program is 'ls' and output is a terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always,
                               shell-escape, shell-escape-always, c, escape
                               (overrides QUOTING_STYLE environment variable)
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print the allocated size of each file, in blocks
  -S                         sort by file size, largest first
      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),
                               time (-t), version (-v), extension (-X)
      --time=WORD            change the default of using modification times;
                               access time (-u): atime, access, use;
                               change time (-c): ctime, status;
                               birth time: birth, creation;
                             with -l, WORD determines which time to show;
                             with --sort=time, sort by WORD (newest first)
      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE below
  -t                         sort by time, newest first; see --time
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time;
                               with -l: show access time and sort by name;
                               otherwise: sort by access time, newest first
  -U                         do not sort; list entries in directory order
  -v                         natural sort of (version) numbers within text
  -w, --width=COLS           set output width to COLS.  0 means no limit
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -Z, --context              print any security context of each file
  -1                         list one file per line.  Avoid '\n' with -q or -b
      --help     display this help and exit
      --version  output version information and exit

The SIZE argument is an integer and optional unit (example: 10K is 10*1024).
Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).
Binary prefixes can be used, too: KiB=K, MiB=M, and so on.

The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.
FORMAT is interpreted like in date(1).  If FORMAT is FORMAT1&lt;newline&gt;FORMAT2,
then FORMAT1 applies to non-recent files and FORMAT2 to recent files.
TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX locale.
Also the TIME_STYLE environment variable sets the default style to use.

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Report any translation bugs to &lt;https://translationproject.org/team/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/ls&gt;
or available locally via: info '(coreutils) ls invocation'
</code></pre>
<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <code>mv</code>（用于重命名或移动文件）、 <code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>
<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p>
<pre><code>missing:~$ man ls
</code></pre>
<h2 id="附录处理目录的常用命令"><a class="header" href="#附录处理目录的常用命令">附录处理目录的常用命令</a></h2>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <code>man [命令]</code> 来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="附录cd命令"><a class="header" href="#附录cd命令">附录cd命令</a></h2>
<p>Linux cd（英文全拼：change directory）命令用于改变当前工作目录的命令，切换到指定的路径。</p>
<p>若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p>
<p>另外，~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录， .. 则表示目前目录位置的上一层目录。</p>
<p>切换到 /usr/bin/ 目录: <code>cd /usr/bin</code></p>
<p><strong>切换到上级目录：</strong> 使用 .. 表示上级目录，可以通过连续多次使用 .. 来切换到更高级的目录。</p>
<pre><code class="language-bash">cd ..
cd ../../   // 切换到上上级目录
</code></pre>
<p><strong>切换到用户主目录（home）：</strong> 使用 ~ 表示当前用户的主目录，可以使用 cd 命令直接切换到主目录。</p>
<pre><code class="language-bash">cd ~
</code></pre>
<p><strong>切换到上次访问的目录：</strong> 使用 cd - 可以切换到上次访问的目录。</p>
<pre><code class="language-bash">cd -
</code></pre>
<p><strong>切换到环境变量指定的目录：</strong> 可以使用环境变量来指定目标目录，并使用 cd 命令切换到该目录。</p>
<pre><code class="language-bash">cd $VAR_NAME
</code></pre>
<p>以上实例都是 cd 命令的一些基本用法，它们可以帮助您在 Linux 系统中进行目录切换操作。</p>
<p>使用<code>cd --help</code>命令可以获取更多关于 cd 命令的详细信息，包括可用的选项和更高级的用法。</p>
<h2 id="在程序间创建连接"><a class="header" href="#在程序间创建连接">在程序间创建连接</a></h2>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<pre><code>missing:~$ echo hello &gt; hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat &lt; hello.txt
hello
missing:~$ cat &lt; hello.txt &gt; hello2.txt
missing:~$ cat hello2.txt
hello
</code></pre>
<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<pre><code>missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
</code></pre>
<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>
<h2 id="一个功能全面又强大的工具"><a class="header" href="#一个功能全面又强大的工具">一个功能全面又强大的工具</a></h2>
<p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。 您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。 通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。 当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>
<p>可以利用<code>sudo su</code>命令进入root用户模式，使用<code>exit</code>命令退出root用户模式。</p>
<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p>
<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p>
<pre><code>/sys/class/backlight
</code></pre>
<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>
<pre><code>$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 &gt; brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
</code></pre>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p>
<p>明白这一点后，我们可以这样操作：</p>
<pre><code>$ echo 3 | sudo tee brightness
</code></pre>
<p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。 这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p>
<pre><code>$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
</code></pre>
<h2 id="接下来"><a class="header" href="#接下来">接下来…..</a></h2>
<p>学到这里，您掌握的 shell 知识已经可以完成一些基础的任务了。您应该已经可以查找感兴趣的文件并使用大多数程序的基本功能了。 在下一场讲座中，我们会探讨如何利用 shell 及其他工具执行并自动化更复杂的任务。</p>
<h2 id="课后练习"><a class="header" href="#课后练习">课后练习</a></h2>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution">习题解答</a> 本课程中的每节课都包含一系列练习题。有些题目是有明确目的的，另外一些则是开放题，例如“尝试使用 X 和 Y”，我们强烈建议您一定要动手实践，用于尝试这些内容。 此外，我们没有为这些练习题提供答案。如果有任何困难，您可以发送邮件给我们并描述你已经做出的尝试，我们会设法帮您解答。</p>
<ol>
<li>
<p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用<a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a>或者是 Linux 虚拟机。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p>
</li>
<li>
<p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p>
</li>
<li>
<p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p>
</li>
<li>
<p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p>
</li>
<li>
<p>将以下内容一行一行地写入 <code>semester</code> 文件：</p>
<pre><code> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
</li>
</ol>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p>
<ol start="6">
<li>
<p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p>
</li>
<li>
<p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code> 命令)</p>
</li>
<li>
<p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p>
</li>
<li>
<p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p>
</li>
</ol>
<p>注：使用 <code>chmod +x semester</code> 命令改变权限，使 <code>./semester</code> 能够成功执行</p>
<h2 id="solution-课程概览与-shell"><a class="header" href="#solution-课程概览与-shell">Solution-课程概览与 shell</a></h2>
<ol>
<li>
<p>在 /tmp 下新建一个名为 missing 的文件夹。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/1.png" alt="1.png" /></p>
</li>
<li>
<p>用 man 查看程序 touch 的使用手册。 <code>man touch</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/2.png" alt="2.png" /></p>
</li>
<li>
<p>用 touch 在 missing 文件夹中新建一个叫 semester 的文件。 <code>touch semester</code></p>
</li>
<li>
<p>将以下内容一行一行地写入 semester 文件：</p>
<pre><code> #!/bin/sh
 curl --head --silent https://missing.csail.mit.edu
</code></pre>
<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting</a>手册<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/3.png" alt="3.png" /></p>
</li>
<li>
<p>尝试执行这个文件。即，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 ls 命令来获取信息并理解其不能执行的原因。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/4.png" alt="4.png" /></p>
</li>
<li>
<p>查看 chmod 的手册(例如，使用 <code>man chmod</code> 命令)<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/5.png" alt="5.png" /></p>
</li>
<li>
<p>使用 chmod 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 sh semester 来执行该程序。您的 shell 是如何知晓这个文件需要使用 sh 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/6.png" alt="6.png" /></p>
</li>
<li>
<p>使用 <code>|</code> 和 <code>&gt;</code> ，将 semester 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/1/7.png" alt="7.png" /></p>
</li>
<li>
<p>写一段命令来从 /sys 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。 Windows 用户可以通过以下命令查询：</p>
<p>WSL2：</p>
<pre><code> &gt; cat /sys/class/power_supply/BAT1/capacity
 100
</code></pre>
<p>Linux 用户可以通过以下命令查询：</p>
<pre><code> &gt; cat /sys/class/power_supply/BAT1/capacity
 100
</code></pre>
</li>
</ol>
<h1 id="shell-工具和脚本"><a class="header" href="#shell-工具和脚本">Shell 工具和脚本</a></h1>
<p>在这节课中，我们将会展示 bash 作为脚本语言的一些基础操作，以及几种最常用的 shell 工具。</p>
<h2 id="shell-脚本"><a class="header" href="#shell-脚本">Shell 脚本</a></h2>
<p>到目前为止，我们已经学习来如何在 shell 中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>
<p>shell 脚本是一种更加复杂度的工具。</p>
<p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。</p>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，<strong>在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</strong></p>
<p><strong>Bash中的字符串通过<code>'</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</strong></p>
<pre><code class="language-bash">foo=bar
echo &quot;$foo&quot;
# 打印 bar
echo '$foo'
# 打印 $foo
</code></pre>
<p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p>
<pre><code class="language-bash">mcd () {
    mkdir -p &quot;$1&quot;
    cd &quot;$1&quot;
}
</code></pre>
<p>这里 <code>$1</code> 是脚本的第一个参数。</p>
<p>这里可以使用vim打开一个文件写入上面的代码并执行<code>source mcd.sh</code>来加载mcd函数，再执行<code>mcd test</code>就能进入test文件夹。</p>
<p>与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p>
<pre><code class="language-bash">xx:~/missing$ echo &quot;Hello&quot;
Hello
xx:~/missing$ echo $?
0
xx:~/missing$ grep foobar mcd.sh
xx:~/missing$ echo $?
1
</code></pre>
<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">运算符</a>（short-circuiting） 同一行的多个命令可以用 <code>;</code> 分隔。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。让我们看几个例子</p>
<pre><code class="language-bash">false || echo &quot;Oops, fail&quot;
# Oops, fail

true || echo &quot;Will not be printed&quot;
#

true &amp;&amp; echo &quot;Things went well&quot;
# Things went well

false &amp;&amp; echo &quot;Will not be printed&quot;
#

false ; echo &quot;This will always run&quot;
# This will always run
</code></pre>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em>（<em>command substitution</em>）实现。</p>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。<strong>这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</strong></p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<pre><code class="language-bash">#!/bin/bash

echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间

echo &quot;Running program $0 with $# arguments with pid $$&quot;

for file in &quot;$@&quot;; do
    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null
    # 如果模式没有找到，则grep退出状态为 1
    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息
    if [[ $? -ne 0 ]]; then
        echo &quot;File $file does not have any foobar, adding one&quot;
        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;
    fi
done
</code></pre>
<p>在条件语句中，我们比较 <code>$?</code> 是否等于0。 执行<code> ./example.sh mcd.sh example.sh</code>时权限不足就执行<code>chmod 777 ./example.sh</code>赋予shell脚本足够权限再执行<code>./example.sh mcd.sh example.sh</code>。输出结果如下：</p>
<pre><code>Starting program at Mon Jan  1 19:13:58 CST 2024
Running program ./example.sh with 2 arguments with pid 144
File mcd.sh does not have any foobar, adding one
</code></pre>
<p>Bash实现了许多类似的比较操作，您可以查看 <a href="https://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。 在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见<a href="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</p>
<p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 <em>通配</em>（<em>globbing</em>）</p>
<ul>
<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
</ul>
<pre><code class="language-bash">convert image.{png,jpg}
# 会展开为
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# 会展开为
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# 也可以结合通配使用
mv *{.py,.sh} folder
# 会移动所有 *.py 和 *.sh 文件

mkdir foo bar

# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件
touch {foo,bar}/{a..h}
touch foo/x bar/y
# 比较文件夹 foo 和 bar 中包含文件的不同
diff &lt;(ls foo) &lt;(ls bar)
# 输出
# &lt; x
# ---
# &gt; y
</code></pre>
<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位sh/bash脚本中的错误。安装shellcheck可以执行<code>sudo apt install shellcheck</code>命令。</p>
<p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p>
<pre><code class="language-bash">#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
</code></pre>
<p>内核知道去用 python 解释器而不是 shell 命令来运行这段脚本，是因为脚本的开头第一行的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p>
<p>在 <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。 例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code>。</p>
<p>shell函数和脚本有如下一些不同点：</p>
<ul>
<li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ul>
<h2 id="shell-工具"><a class="header" href="#shell-工具">Shell 工具</a></h2>
<h3 id="查看命令如何使用"><a class="header" href="#查看命令如何使用">查看命令如何使用</a></h3>
<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？ 一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>
<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<a href="https://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。 事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。 <a href="https://tldr.sh/">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>
<p>例如，自己就常常在tldr上搜索<a href="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <a href="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a> 的用法。</p>
<h3 id="查找文件-1"><a class="header" href="#查找文件-1">查找文件</a></h3>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <a href="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a> 的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p>
<pre><code># 查找所有名称为src的文件夹
find . -name src -type d
# 查找所有文件夹路径中包含test的python文件
find . -path '*/test/*.py' -type f
# 查找前一天修改的所有文件
find . -mtime -1
# 查找所有大小在500k至10M的tar.gz文件
find . -size +500k -size -10M -name '*.tar.gz'
</code></pre>
<p>除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<pre><code># 删除全部扩展名为.tmp 的文件
find . -name '*.tmp' -exec rm {} \;
# 查找全部的 PNG 文件并将其转换为 JPG
find . -name '*.png' -exec convert {} {}.jpg \;
</code></pre>
<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码"><a class="header" href="#查找代码">查找代码</a></h3>
<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>
<p>为了实现这一点，很多类UNIX的系统都提供了<a href="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>
<p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p>
<p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>
<pre><code># 查找所有使用了 requests 库的文件
rg -t py 'import requests'
# 查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match &quot;^#!&quot;
# 查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
# 打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN
</code></pre>
<p>与 <code>find</code>/<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>
<h3 id="查找-shell-命令"><a class="header" href="#查找-shell-命令">查找 shell 命令</a></h3>
<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
<h3 id="文件夹导航"><a class="header" href="#文件夹导航">文件夹导航</a></h3>
<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>
<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<p>安装tree使用<code>sudo apt install tree</code>命令。</p>
<h2 id="课后练习-1"><a class="header" href="#课后练习-1">课后练习</a></h2>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//shell-tools-solution">习题解答</a></p>
<ol>
<li>
<p>阅读 <a href="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p>
<ul>
<li>所有文件（包括隐藏文件）</li>
<li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li>
<li>文件以最近访问顺序排序</li>
<li>以彩色文本显示输出结果</li>
</ul>
<p>典型输出如下：</p>
<pre><code> -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
</li>
<li>
<p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</p>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<pre><code> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
    echo &quot;Something went wrong&quot;
    &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
    exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
</li>
<li>
<p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p>
<p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>，译注：MacOS 上的 <code>xargs</code>没有<code>-d</code>，<a href="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）</p>
<p>如果您使用的是 MacOS，请注意默认的 BSD <code>find</code> 与 <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为<code>find</code>添加<code>-print0</code>选项，并为<code>xargs</code>添加<code>-0</code>选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew 来安装</a>。</p>
</li>
<li>
<p>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</p>
</li>
</ol>
<h1 id="solution-shell-工具和脚本"><a class="header" href="#solution-shell-工具和脚本">Solution-Shell 工具和脚本</a></h1>
<ol>
<li>
<p>阅读 man ls ，然后使用ls 命令进行如下操作：</p>
<ul>
<li>
<p>所有文件（包括隐藏文件） ：<code>-a</code></p>
</li>
<li>
<p>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954) : <code>-h</code></p>
</li>
<li>
<p>文件以最近访问顺序排序：<code>-t</code></p>
</li>
<li>
<p>以彩色文本显示输出结果<code>--color=auto</code><br />
典型输出如下：</p>
<pre><code> -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
 drwxr-xr-x   5 user group  160 Jan 14 09:53 .
 -rw-r--r--   1 user group  514 Jan 14 06:42 bar
 -rw-r--r--   1 user group 106M Jan 13 12:12 foo
 drwx------+ 47 user group 1.5K Jan 12 18:08 ..
</code></pre>
</li>
</ul>
</li>
<li>
<p>编写两个bash函数 marco 和 polo 执行下面的操作。 每当你执行 marco 时，当前的工作目录应当以某种形式保存，当执行 polo 时，无论现在处在什么目录下，都应当 cd 回到当时执行 marco 的目录。 为了方便debug，你可以把代码写在单独的文件 marco.sh 中，并通过 source marco.sh命令，（重新）加载函数。通过source 来加载函数，随后可以在 bash 中直接使用。</p>
<pre><code> #!/bin/bash
 marco(){
     echo &quot;$(pwd)&quot; &gt; $HOME/marco_history.log
     echo &quot;save pwd $(pwd)&quot;
 }
 polo(){
     cd &quot;$(cat &quot;$HOME/marco_history.log&quot;)&quot;
 }
</code></pre>
<p>或者</p>
<pre><code> #!/bin/bash
 marco() {
     export MARCO=$(pwd)
 }
 polo() {
     cd &quot;$MARCO&quot;
 }
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/1.png" alt="1.png" /></p>
</li>
<li>
<p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<pre><code> #!/usr/bin/env bash

 n=$(( RANDOM % 100 ))

 if [[ n -eq 42 ]]; then
     echo &quot;Something went wrong&quot;
     &gt;&amp;2 echo &quot;The error was using magic numbers&quot;
     exit 1
 fi

 echo &quot;Everything went according to plan&quot;
</code></pre>
<p>使用 while 循环完成</p>
<pre><code> #!/usr/bin/env bash
 count=0
 echo &gt; out.log

 while true
 do
     ./buggy.sh &amp;&gt;&gt; out.log
     if [[ $? -ne 0 ]]; then
         cat out.log
         echo &quot;failed after $count times&quot;
         break
     fi
     ((count++))

 done

</code></pre>
<p>使用 for 循环完成</p>
<pre><code> #!/usr/bin/env bash
 echo &gt; out.log
 for ((count=0;;count++))
 do
     ./buggy.sh &amp;&gt;&gt; out.log
     if [[ $? -ne 0 ]]; then
         echo &quot;failed after $count times&quot;
         break

     fi
 done

</code></pre>
<p>使用 until 完成</p>
<pre><code> #!/usr/bin/env bash
 count=0
 ./buggy.sh &amp;&gt;&gt; out.log
 until [[ &quot;$?&quot; -ne 0 ]];
 do
     count=$((count+1))
     ./buggy.sh &amp;&gt;&gt; out.log
 done

 echo &quot;failed after $count runs&quot;

</code></pre>
<p>执行测试脚本debug.sh,并验证脚本结果的正确性</p>
<pre><code> ~$ ./debug.sh
 failed after 34 times
 ~$ cat out.log | grep Everything | wc -l
 34
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/2.png" alt="1.png" /></p>
</li>
<li>
<p>本节课我们讲解的 find 命令中的 -exec 参数非常强大，它可以对我们查找的文件进行操作。 如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如tar 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html">xargs</a> 命令，它可以使用标准输入中的内容作为参数。 例如 ls | xargs rm 会删除当前目录中的所有文件。您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 xargs的参数-d）<em>译注：MacOS 上的 xargs没有-d，查看这个<a href="https://github.com/missing-semester/missing-semester/issues/93">issue</a></em></p>
<p>如果您使用的是 MacOS，请注意默认的 BSD find 与<a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为find添加-print0选项，并为xargs添加-0选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew</a> 来安装。</p>
<ol>
<li>
<p>首先创建所需的文件</p>
<pre><code>  mkdir html_root
  cd html_root
  touch {1..10}.html
  mkdir html
  cd html
  touch xxxx.html
</code></pre>
<pre><code>  ├── html_root
  │   ├── 1.html
  │   ├── 10.html
  │   ├── 2.html
  │   ├── 3.html
  │   ├── 4.html
  │   ├── 5.html
  │   ├── 6.html
  │   ├── 7.html
  │   ├── 8.html
  │   ├── 9.html
  │   └── html
  │       └── xxxx.html
</code></pre>
</li>
<li>
<p>执行 find 命令</p>
<pre><code>  #for MacOS
  find html_root -name &quot;*.html&quot; -print0 | xargs -0 tar vcf html.zip
</code></pre>
<pre><code>  #for Linux
  find . -type f -name &quot;*.html&quot; | xargs -d '\n'  tar -cvzf html.zip
</code></pre>
<pre><code>  a html_root/9.html
  a html_root/5.html
  a html_root/4.html
  a html_root/8.html
  a html_root/3.html
  a html_root/html/xxxx.html
  a html_root/2.html
  a html_root/1.html
  a html_root/10.html
  a html_root/7.html
  a html_root/6.html
</code></pre>
</li>
</ol>
</li>
<li>
<p>(进阶) 编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？ <code>find . -type f -print0 | xargs -0 ls -lt | head -1</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/4.png" alt="1.png" /></p>
</li>
</ol>
<p>当文件数量较多时，上面的解答会得出错误结果，解决办法是增加 <code>-mmin</code> 条件，先将最近修改的文件进行初步筛选再交给ls进行排序显示 <code>find . -type f -mmin -60 -print0 | xargs -0 ls -lt | head -10</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/2/5.png" alt="1.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="编辑器-vim"><a class="header" href="#编辑器-vim">编辑器 (Vim)</a></h1>
<p><a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim)来源地址</a></p>
<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的 Word 与 Visual Studio Code）。</p>
<p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p>
<ul>
<li>阅读教程（比如这节课以及我们为您提供的资源）</li>
<li>坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li>
<li>随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有</li>
</ul>
<p>如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。当学习时间累计达到20个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%AF%A5%E5%AD%A6%E5%93%AA%E4%B8%AA%E7%BC%96%E8%BE%91%E5%99%A8">该学哪个编辑器？</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim">Vim</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim-%E7%9A%84%E5%93%B2%E5%AD%A6">Vim 的哲学</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F">编辑模式</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">基本操作</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC">插入文本</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%BC%93%E5%AD%98-%E6%A0%87%E7%AD%BE%E9%A1%B5-%E7%AA%97%E5%8F%A3">缓存， 标签页， 窗口</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%91%BD%E4%BB%A4%E8%A1%8C">命令行</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">Vim 的接口其实是一种编程语言</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%A7%BB%E5%8A%A8">移动</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E9%80%89%E6%8B%A9">选择</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E7%BC%96%E8%BE%91">编辑</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%AE%A1%E6%95%B0">计数</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E4%BF%AE%E9%A5%B0%E8%AF%AD">修饰语</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%BC%94%E7%A4%BA">演示</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%87%AA%E5%AE%9A%E4%B9%89-vim">自定义 Vim</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%89%A9%E5%B1%95-vim">扩展 Vim</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%9A%84-vim-%E6%A8%A1%E5%BC%8F">其他程序的 Vim 模式</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#shell">Shell</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#readline">Readline</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#vim-%E8%BF%9B%E9%98%B6">Vim 进阶</a>
<ul>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2">搜索和替换</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4">复制粘贴</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%A4%9A%E7%AA%97%E5%8F%A3">多窗口</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E5%AE%8F">宏</a></li>
</ul>
</li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99">扩展资料</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="%E7%BC%96%E8%BE%91%E5%99%A8Vim.html#solution-%E7%BC%96%E8%BE%91%E5%99%A8-vim">Solution-编辑器 (Vim)</a></li>
</ul>
<h1 id="该学哪个编辑器"><a class="header" href="#该学哪个编辑器">该学哪个编辑器？</a></h1>
<p>程序员们对自己正在使用的文本编辑器通常有着 <a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98">非常强的执念</a>。</p>
<p>现在最流行的编辑器是什么？<a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>（这个调查可能并不如我们想象的那样客观，因为 Stack Overflow 的用户并不能代表所有程序员）显示，<a href="https://code.visualstudio.com/">Visual Studio Code</a> 是目前最流行的代码编辑器。而 <a href="https://www.vim.org/">Vim</a> 则是最流行的基于命令行的编辑器。</p>
<h2 id="vim"><a class="header" href="#vim">Vim</a></h2>
<p>这门课的所有教员都使用 Vim 作为编辑器。Vim 有着悠久历史；它始于 1976 年的 Vi 编辑器，到现在还在 不断开发中。Vim 有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140 万人安装了 <a href="https://github.com/VSCodeVim/Vim">Vim emulation for VS code</a>）。即使你最后使用 其他编辑器，Vim 也值得学习。</p>
<p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim 的设计哲学，教你基础知识， 并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p>
<h1 id="vim-的哲学"><a class="header" href="#vim-的哲学">Vim 的哲学</a></h1>
<p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以，Vim 是一个_多模态_编辑 器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一种程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</p>
<p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p>
<h1 id="编辑模式"><a class="header" href="#编辑模式">编辑模式</a></h1>
<p>Vim 的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p>
<ul>
<li><strong>正常模式</strong>：在文件中四处移动光标进行修改</li>
<li><strong>插入模式</strong>：插入文本</li>
<li><strong>替换模式</strong>：替换文本</li>
<li><strong>可视化模式</strong>（一般，行，块）：选中文本块</li>
<li><strong>命令模式</strong>：用于执行命令</li>
</ul>
<p>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code> 在插入模式会插入字母 <code>x</code>，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p>
<p>在默认设置下，Vim 会在左下角显示当前的模式。Vim 启动时的默认模式是正常模式。通常你会把大部分 时间花在正常模式和插入模式。</p>
<p>你可以按下 <code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入 <code>i</code> 进入插入 模式，<code>R</code> 进入替换模式，<code>v</code> 进入可视（一般）模式，<code>V</code> 进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p>
<p>因为你会在使用 Vim 时大量使用 <code>&lt;ESC&gt;</code> 键，所以可以考虑把大小写锁定键重定义成 <code>&lt;ESC&gt;</code> 键（<a href="https://vim.fandom.com/wiki/Map_caps_lock_to_escape_in_macOS">MacOS 教程</a>）。</p>
<h1 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h1>
<h2 id="插入文本"><a class="header" href="#插入文本">插入文本</a></h2>
<p>在正常模式，键入 <code>i</code> 进入插入模式。现在 Vim 跟很多其他的编辑器一样，直到你键入 <code>&lt;ESC&gt;</code> 返回正常模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p>
<h2 id="缓存-标签页-窗口"><a class="header" href="#缓存-标签页-窗口">缓存， 标签页， 窗口</a></h2>
<p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系；窗口只是视角。一个缓存可以在多个窗口打开，甚至在同一个标签页内的多个窗口打开。这个功能其实很好用，比如在查看同一个文件的不同部分的时候。</p>
<p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p>
<h2 id="命令行"><a class="header" href="#命令行">命令行</a></h2>
<p>在正常模式下键入 <code>:</code> 进入命令行模式。 在键入 <code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能，包括打开，保存，关闭文件，以及 <a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p>
<ul>
<li><code>:q</code> 退出（关闭窗口）</li>
<li><code>:w</code> 保存（写）</li>
<li><code>:wq</code> 保存然后退出</li>
<li><code>:e {文件名}</code> 打开要编辑的文件</li>
<li><code>:ls</code> 显示打开的缓存</li>
<li><code>:help {标题}</code> 打开帮助文档
<ul>
<li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li>
<li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li>
</ul>
</li>
</ul>
<h1 id="vim-的接口其实是一种编程语言"><a class="header" href="#vim-的接口其实是一种编程语言">Vim 的接口其实是一种编程语言</a></h1>
<p>Vim 最重要的设计思想是 Vim 的界面本身是一种程序语言。键入操作（以及他们的助记名） 本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p>
<h2 id="移动"><a class="header" href="#移动">移动</a></h2>
<p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。</p>
<ul>
<li>基本移动: <code>hjkl</code> （左， 下， 上， 右）</li>
<li>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</li>
<li>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</li>
<li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</li>
<li>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻）</li>
<li>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</li>
<li>行数： <code>:{行数}&lt;CR&gt;</code> 或者 <code>{行数}G</code> ({行数}为行数)</li>
<li>杂项： <code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）</li>
<li>查找： <code>f{字符}</code>， <code>t{字符}</code>， <code>F{字符}</code>， <code>T{字符}</code>
<ul>
<li>查找/到 向前/向后 在本行的{字符}</li>
<li><code>,</code> / <code>;</code> 用于导航匹配</li>
</ul>
</li>
<li>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配</li>
</ul>
<h2 id="选择"><a class="header" href="#选择">选择</a></h2>
<p>可视化模式:</p>
<ul>
<li>可视化：<code>v</code></li>
<li>可视化行： <code>V</code></li>
<li>可视化块：<code>Ctrl+v</code></li>
</ul>
<p>可以用移动命令来选中。</p>
<h2 id="编辑"><a class="header" href="#编辑">编辑</a></h2>
<p>所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</p>
<ul>
<li><code>i</code> 进入插入模式
<ul>
<li>但是对于操纵/编辑文本，不单想用退格键完成</li>
</ul>
</li>
<li><code>O</code> / <code>o</code> 在之上/之下插入行</li>
<li><code>d{移动命令}</code> 删除 {移动命令}
<ul>
<li>例如，<code>dw</code> 删除词, <code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。</li>
</ul>
</li>
<li><code>c{移动命令}</code> 改变 {移动命令}
<ul>
<li>例如，<code>cw</code> 改变词</li>
<li>比如 <code>d{移动命令}</code> 再 <code>i</code></li>
</ul>
</li>
<li><code>x</code> 删除字符（等同于 <code>dl</code>）</li>
<li><code>s</code> 替换字符（等同于 <code>xi</code>）</li>
<li>可视化模式 + 操作
<ul>
<li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li>
</ul>
</li>
<li><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</li>
<li><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</li>
<li><code>p</code> 粘贴</li>
<li>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</li>
</ul>
<h2 id="计数"><a class="header" href="#计数">计数</a></h2>
<p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p>
<ul>
<li><code>3w</code> 向后移动三个词</li>
<li><code>5j</code> 向下移动5行</li>
<li><code>7dw</code> 删除7个词</li>
</ul>
<h2 id="修饰语"><a class="header" href="#修饰语">修饰语</a></h2>
<p>你可以用修饰语改变“名词”的意义。修饰语有 <code>i</code>，表示“内部”或者“在内”，和 <code>a</code>， 表示“周围”。</p>
<ul>
<li><code>ci(</code> 改变当前括号内的内容</li>
<li><code>ci[</code> 改变当前方括号内的内容</li>
<li><code>da'</code> 删除一个单引号字符串， 包括周围的单引号</li>
</ul>
<h1 id="演示"><a class="header" href="#演示">演示</a></h1>
<p>这里是一个有问题的 <a href="https://en.wikipedia.org/wiki/Fizz_buzz">fizz buzz</a> 实现：</p>
<pre><code class="language-python">def fizz_buzz(limit):
    for i in range(limit):
        if i % 3 == 0:
            print('fizz')
        if i % 5 == 0:
            print('fizz')
        if i % 3 and i % 5:
            print(i)

def main():
    fizz_buzz(10)
</code></pre>
<p>我们会修复以下问题：</p>
<ul>
<li>
<p>主函数没有被调用</p>
</li>
<li>
<p>从 0 而不是 1 开始</p>
</li>
<li>
<p>在 15 的整数倍的时候在不同行打印 “fizz” 和 “buzz”</p>
</li>
<li>
<p>在 5 的整数倍的时候打印 “fizz”</p>
</li>
<li>
<p>采用硬编码的参数 10 而不是从命令控制行读取参数</p>
</li>
<li>
<p>主函数没有被调用</p>
<ul>
<li><code>G</code> 文件尾</li>
<li><code>o</code> 向下打开一个新行</li>
<li>输入 “if <strong>name</strong> …”</li>
</ul>
</li>
<li>
<p>从 0 而不是 1 开始</p>
<ul>
<li>搜索 <code>/range</code></li>
<li><code>ww</code> 向后移动两个词</li>
<li><code>i</code> 插入文字， “1, “</li>
<li><code>ea</code> 在 limit 后插入， “+1”</li>
</ul>
</li>
<li>
<p>在新的一行 “fizzbuzz”</p>
<ul>
<li><code>jj$i</code> 插入文字到行尾</li>
<li>加入 “, end=’’”</li>
<li><code>jj.</code> 重复第二个打印</li>
<li><code>jjo</code> 在 if 打开一行</li>
<li>加入 “else: print()” ❗ 🔄</li>
</ul>
</li>
<li>
<p>fizz fizz</p>
<ul>
<li><code>ci'</code> 变到 fizz</li>
</ul>
</li>
<li>
<p>命令控制行参数</p>
<ul>
<li><code>ggO</code> 向上打开</li>
<li>“import sys” </li>
<li><code>/10</code></li>
<li><code>ci(</code> to “int(sys.argv[1])” </li>
</ul>
</li>
</ul>
<pre><code class="language-python">import sys
def fizz_buzz(limit):
    for i in range(limit):
        if i % 3 == 0:
            print('fizz')
        if i % 5 == 0:
            print('buzz')
        if i % 3 and i % 5:
            print(i)

def main():
    fizz_buzz(int(sys.argv[1]))

if __name__ == '__main__':
	main()
</code></pre>
<p>展示详情请观看课程视频。比较上面用 Vim 的操作和你可能使用其他程序的操作。 值得一提的是 Vim 需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p>
<h1 id="自定义-vim"><a class="header" href="#自定义-vim">自定义 Vim</a></h1>
<p>Vim 由一个位于 <code>~/.vimrc</code> 的文本配置文件（包含 Vim 脚本命令）。你可能会启用很多基本 设置。</p>
<p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。 <strong>在<a href="https://missing-semester-cn.github.io/2020/files/vimrc">这儿</a> 下载我们的设置，然后将它保存成 <code>~/.vimrc</code>.</strong></p>
<p>Vim 能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在 GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (<a href="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>, <a href="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a> (uses <a href="https://neovim.io/">neovim</a>), <a href="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。 有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它，然后采用对你有用的部分。</p>
<h1 id="扩展-vim"><a class="header" href="#扩展-vim">扩展 Vim</a></h1>
<p>Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你_不_需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。你可以使用内置的插件管理系统。只需要创建一个 <code>~/.vim/pack/vendor/start/</code> 的文件夹，然后把插件放到这里（比如通过 <code>git clone</code>）。</p>
<p>以下是一些我们最爱的插件：</p>
<ul>
<li><a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>: 模糊文件查找</li>
<li><a href="https://github.com/mileszs/ack.vim">ack.vim</a>: 代码搜索</li>
<li><a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: 文件浏览器</li>
<li><a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>: 魔术操作</li>
</ul>
<p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件 (<a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/JJGO/dotfiles">Jose</a>) 来看看我们使用的其他插件。 浏览 <a href="https://vimawesome.com/">Vim Awesome</a> 来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim plugins”。</p>
<h1 id="其他程序的-vim-模式"><a class="header" href="#其他程序的-vim-模式">其他程序的 Vim 模式</a></h1>
<p>很多工具提供了 Vim 模式。这些 Vim 模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim 功能，但是大多数对基本功能支持的很好。</p>
<h2 id="shell"><a class="header" href="#shell">Shell</a></h2>
<p>如果你是一个 Bash 用户，用 <code>set -o vi</code>。如果你用 Zsh：<code>bindkey -v</code>。Fish 用 <code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以 <code>export EDITOR=vim</code>。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如，<code>git</code> 会使用这个编辑器来编辑 commit 信息。</p>
<h2 id="readline"><a class="header" href="#readline">Readline</a></h2>
<p>很多程序使用 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a> 库来作为它们的命令控制行界面。Readline 也支持基本的 Vim 模式， 可以通过在 <code>~/.inputrc</code> 添加如下行开启：</p>
<pre><code>set editing-mode vi
</code></pre>
<p>比如，在这个设置下，Python REPL 会支持 Vim 快捷键。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<p>甚至有 Vim 的网页浏览快捷键 <a href="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>, 受欢迎的有 用于 Google Chrome 的 <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a> 和用于 Firefox 的 <a href="https://github.com/tridactyl/tridactyl">Tridactyl</a>。 你甚至可以在 <a href="https://github.com/lambdalisue/jupyter-vim-binding">Jupyter notebooks</a> 中用 Vim 快捷键。 <a href="https://reversed.top/2016-08-13/big-list-of-vim-like-software">这个列表</a> 中列举了支持类 vim 键位绑定的软件。</p>
<h1 id="vim-进阶"><a class="header" href="#vim-进阶">Vim 进阶</a></h1>
<p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你 可以在使用中学习。一个好的对策是: 当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p>
<h2 id="搜索和替换"><a class="header" href="#搜索和替换">搜索和替换</a></h2>
<p><code>:s</code> （替换）命令（<a href="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p>
<ul>
<li><code>%s/foo/bar/g</code>
<ul>
<li>在整个文件中将 foo 全局替换成 bar</li>
</ul>
</li>
<li><code>%s/\[.*\](\(.*\))/\1/g</code>
<ul>
<li>将有命名的 Markdown 链接替换成简单 URLs</li>
</ul>
</li>
</ul>
<h2 id="复制粘贴"><a class="header" href="#复制粘贴">复制粘贴</a></h2>
<p>vim中的复制和粘贴命令分别是y和p，在不需要和系统交互剪贴板数据时还好，一旦要复制外部数据到vim中或者将vim中的数据复制到外部，这两个命令就无效了，只能用鼠标选中再右键复制粘贴。虽然和windows下的Ctrl C、Ctrl V不同，但vim可以通过配置实现和系统剪贴板的“沟通”。
需要注意的是Ctrl y和Ctrl p在 vim 中有特殊含义，使用以下设置后会覆盖默认设置。</p>
<p>前提
开始前需要先查看vim是否已经支持clipboard功能，使用vim --version | grep clipboard命令查看，有+clipboard说已经支持clipboard功能。</p>
<pre><code>-clipboard         +keymap            +printer           +vertsplit
+eval              -mouse_jsbterm     -sun_workshop      -xterm_clipboard
</code></pre>
<p>如果其前为-号，执行sudo apt install vim-gtk安装vim-gtk即可（或者安装gvim，非debian系的系统不是用apt命令，根据系统变动就行，都差不多），安装完成后再执行vim --version | grep clipboard此时应该已经支持clipboard功能。</p>
<p>配置vim</p>
<p>此时如果在vim外复制了文本，要粘贴到打开的vim文件内，只需在normal模式下（如果不知道当前在哪个模式就先按一次ESC键）执行&quot;*p，注意是三个键连续输入，由于要输入双引号和星号，因此需要先按下Shift键，再分别按下&quot; *（过程中Shift不要放下），最后按下p（小写，此时不要按Shift），如果没问题应该可以将系统剪贴板数据粘贴到vim中；</p>
<p>类似的，要将vim中的数据复制到vim外，需要回到normal模式先按v进入visual模式，移动光标选中目标文本后，在visua模式下执行&quot; + y即可将vim数据复制到系统剪贴板，在vim外执行Ctrl V即可完成数据粘贴。</p>
<p>vim支持自定义快捷键，使用vim打开~/.vimrc文件这是当前用户的vim配置文件，vim会读取配置文件中的内容完成相应的配置，在这个配置文件中添加（中文前的“号是注释）</p>
<pre><code>vnoremap &lt;C-y&gt; &quot;+y   &quot;支持在Visual模式下，通过C-y复制到系统剪切板
nnoremap &lt;C-p&gt; &quot;*p   &quot;支持在normal模式下，通过C-p粘贴系统剪切板
</code></pre>
<p>添加完成后按ESC回到normal模式输入:wq保存并退出，此后就可以像Ctrl C、Ctrl V那样愉快地使用Ctrl y和Ctrl p进行复制粘贴了。</p>
<h2 id="多窗口"><a class="header" href="#多窗口">多窗口</a></h2>
<ul>
<li>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口</li>
<li>同一个缓存可以在多个窗口中显示。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/337157587">来源</a></p>
<p>Vim分屏功能是通过分割窗口来实现的，这是提高工作效率的一大利器。无论我们想同时显示两个文件，或者同时显示一个文件的两个不同的位置，又或者并排比较两个文件，等等，这些都能通过分屏来实现，这样子很方便代码的比对和复制粘贴</p>
<p><strong>水平方向分屏打开新文件</strong></p>
<p>:sp linuxmi.py</p>
<p>或者</p>
<p>:split linuxmi.py</p>
<p>这个命令把窗口横向切分为两个窗口，并把光标置于上面的窗口中。</p>
<p><strong>垂直方向分屏打开新文件</strong></p>
<p>:vsp linux.py</p>
<p>:vsplit linux.py</p>
<p>:sview linux.py -&gt;只读分屏打开文件</p>
<p>另外，要打开窗口编辑一个新的文件时，可以用以下命令：</p>
<p>:new</p>
<p><strong>从命令行直接打开多个文件且是分屏</strong></p>
<p>vim -On file1, file2 ... -&gt;垂直分屏</p>
<p>vim -on file1, file2 ... -&gt;水平分屏</p>
<p>linuxmi@linuxmi:~/<a href="https://link.zhihu.com/?target=http%3A//www.linuxmi.com">http://www.linuxmi.com</a> vim -O3 linux.py linuxmi.py linuxmi.cpp</p>
<p><img src="https://pic3.zhimg.com/80/v2-2fbea6832d96ea4ca18d8c8fc6aa76a2_1440w.webp" alt="" /></p>
<p>注：-O垂直分屏，-o水平分屏，n表示分几个屏</p>
<p><strong>实时调整当前窗口的宽度</strong><br />
ctrl-w &gt; //向右加宽，默认值为1<br />
ctrl-w N &gt; //向右加宽宽度N<br />
ctrl-w &lt; // 同理</p>
<p><strong>横屏/竖屏分屏打开当前文件</strong></p>
<p>ctrl+w s<br />
ctrl+w v</p>
<p><strong>切换分屏</strong></p>
<p>ctrl+w h,j,k,l<br />
ctrl+w 上下左右键</p>
<p>crtl+w进行分屏窗口的切换 按完以后再按一个w</p>
<p>crtl+w进行分屏窗口的切换 按完以后再按一个r 互换窗口</p>
<p>crtl+w进行分屏窗口的切换 按完以后再按一个c 关闭窗口</p>
<p><strong>关闭分屏</strong></p>
<p>关闭窗口有以下几个个命令：</p>
<p>ctrl+W c 关闭当前窗口</p>
<p>ctrl+w q 关闭当前窗口，若只有一个分屏且退出vim</p>
<p>:only 仅保留当前分屏<br />
:hide 关闭当前分屏</p>
<p><strong>调整分屏的大小（宽度与高度）</strong></p>
<p>ctrl+w = 所有分屏都统一高度<br />
ctrl+w + 增加高度，默认值为1<br />
ctrl+w - 减少高度<br />
10 ctrl+w + 增加10行高度<br />
ctrl-w N + //当前屏高度加N</p>
<p>使用指定当前屏的调整高度<br />
: resize N</p>
<p>示例：</p>
<p>:resize 30</p>
<p><strong>移动分屏</strong></p>
<p>ctrl+W H,J,K,L</p>
<p><strong>将屏幕移动到最顶端</strong><br />
ctrl-w + K</p>
<p><strong>将屏幕移动到最低端</strong><br />
ctrl-w + J</p>
<p><strong>将屏幕移动到最左边</strong><br />
ctrl-w + H</p>
<p><strong>将屏幕移动到最右边</strong><br />
ctrl-w + L</p>
<h2 id="宏"><a class="header" href="#宏">宏</a></h2>
<ul>
<li><code>q{字符}</code> 来开始在寄存器<code>{字符}</code>中录制宏</li>
<li><code>q</code>停止录制</li>
<li><code>@{字符}</code> 重放宏</li>
<li>宏的执行遇错误会停止</li>
<li><code>{计数}@{字符}</code>执行一个宏{计数}次</li>
<li>宏可以递归
<ul>
<li>首先用<code>q{字符}q</code>清除宏</li>
<li>录制该宏，用 <code>@{字符}</code> 来递归调用该宏 （在录制完成之前不会有任何操作）</li>
</ul>
</li>
<li>例子：将 xml 转成 json (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">file</a>)
<ul>
<li>一个有 “name” / “email” 键对象的数组</li>
<li>用一个 Python 程序？</li>
<li>用 sed / 正则表达式
<ul>
<li><code>g/people/d</code></li>
<li><code>%s/&lt;person&gt;/{/g</code></li>
<li><code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/&quot;name&quot;: &quot;\1&quot;,/g</code></li>
<li>…</li>
</ul>
</li>
<li>Vim 命令 / 宏
<ul>
<li><code>ggdd</code>, <code>Gdd</code> 删除第一行和最后一行</li>
<li>格式化最后一个元素的宏 （寄存器 <code>e</code>）
<ul>
<li>跳转到有 <code>&lt;name&gt;</code> 的行</li>
<li><code>qe^r&quot;f&gt;s&quot;: &quot;&lt;ESC&gt;f&lt;C&quot;&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>格式化一个的宏
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q</code></li>
</ul>
</li>
<li>格式化一个标签然后转到另外一个的宏
<ul>
<li>跳转到有 <code>&lt;person&gt;</code> 的行</li>
<li><code>qq@pjq</code></li>
</ul>
</li>
<li>执行宏到文件尾
<ul>
<li><code>999@q</code></li>
</ul>
</li>
<li>手动移除最后的 <code>,</code> 然后加上 <code>[</code> 和 <code>]</code> 分隔符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="扩展资料"><a class="header" href="#扩展资料">扩展资料</a></h1>
<ul>
<li><code>vimtutor</code> 是一个 Vim 安装时自带的教程</li>
<li><a href="https://vim-adventures.com/">Vim Adventures</a> 是一个学习使用 Vim 的游戏</li>
<li><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim Tips Wiki</a> </li>
<li><a href="https://vimways.org/2019/">Vim Advent Calendar</a> 有很多 Vim 小技巧</li>
<li><a href="http://www.vimgolf.com/">Vim Golf</a> 是用 Vim 的用户界面作为程序语言的 <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li>
<li><a href="https://vi.stackexchange.com/">Vi/Vim Stack Exchange</a> </li>
<li><a href="http://vimcasts.org/">Vim Screencasts</a></li>
<li><a href="https://pragprog.com/titles/dnvim2/">Practical Vim</a>（书籍） </li>
</ul>
<h1 id="课后练习-2"><a class="header" href="#课后练习-2">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//editors-solution">习题解答</a></p>
<ol>
<li>完成 <code>vimtutor</code>。备注：它在一个 <a href="https://en.wikipedia.org/wiki/VT100">80x24</a>（80 列，24 行） 终端窗口看起来效果最好。</li>
<li>下载我们提供的 <a href="https://missing-semester-cn.github.io/2020/files/vimrc">vimrc</a>，然后把它保存到 <code>~/.vimrc</code>。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。</li>
<li>安装和配置一个插件： <a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>.
<ol>
<li>用 <code>mkdir -p ~/.vim/pack/vendor/start</code> 创建插件文件夹</li>
<li>下载这个插件： <code>cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim</code></li>
<li>阅读这个插件的 <a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。 尝试用 CtrlP 来在一个工程文件夹里定位一个文件，打开 Vim, 然后用 Vim 命令控制行开始 <code>:CtrlP</code>.</li>
<li>自定义 CtrlP：添加 <a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a> 到你的 <code>~/.vimrc</code> 来用按 Ctrl-P 打开 CtrlP</li>
</ol>
</li>
<li>练习使用 Vim, 在你自己的机器上重做 <a href="https://missing-semester-cn.github.io/2020/editors/#demo">演示</a>。</li>
<li>下个月用 Vim 完成_所有的_文件编辑。每当不够高效的时候，或者你感觉 “一定有一个更好的方式”时， 尝试求助搜索引擎，很有可能有一个更好的方式。如果你遇到难题，可以来我们的答疑时间或者给我们发邮件。</li>
<li>在其他工具中设置 Vim 快捷键 （见上面的操作指南）。</li>
<li>进一步自定义你的 <code>~/.vimrc</code> 和安装更多插件。</li>
<li>（高阶）用 Vim 宏将 XML 转换到 JSON (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">例子文件</a>)。 尝试着先完全自己做，但是在你卡住的时候可以查看上面<a href="https://missing-semester-cn.github.io/2020/editors/#macros">宏</a> 章节。</li>
</ol>
<h1 id="solution-编辑器-vim"><a class="header" href="#solution-编辑器-vim">Solution-编辑器 (Vim)</a></h1>
<ol>
<li>
<p>完成 vimtutor。 备注： 它在一个 80x24（80 列，24 行） 终端窗口看起来最好。</p>
<pre><code>  vimtutor
</code></pre>
</li>
<li>
<p>下载我们的<a href="https://missing-semester-cn.github.io/2020/files/vimrc">vimrc</a>，然后把它保存到 <code>~/.vimrc</code>。 通读这个注释详细的文件 （用 Vim!）， 然后观察 Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。</p>
</li>
<li>
<p>安装和配置一个插件： <code>ctrlp.vim</code>.</p>
<ol>
<li>
<p>用 <code>mkdir -p ~/.vim/pack/vendor/start</code> 创建插件文件夹</p>
</li>
<li>
<p>下载这个插件： <code>cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim</code><br />
下载后需要在~/.vimrc 中添加如下设置，参考<a href="http://ctrlpvim.github.io/ctrlp.vim/#installation">这里</a></p>
<pre><code> set runtimepath^=~/.vim/pack/vendor/start/ctrlp.vim 
</code></pre>
</li>
<li>
<p>请阅读这个插件的<a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。 尝试用 CtrlP 来在一个工程文件夹里定位一个文件， 打开 Vim, 然后用 Vim 命令控制行开始 :CtrlP.<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/3/1.png" alt="1.png" /></p>
</li>
<li>
<p>自定义 CtrlP： 添加 <a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a> 到你的 ~/.vimrc 来用按 Ctrl-P 打开 CtrlP</p>
<pre><code> let g:ctrlp_map ='&lt;c-p&gt;' 
 let g:ctrlp_cmd = 'CtrlP'
 let g:ctrlp_working_path_mode = 'ra' #设置默认路径为当前路径
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/3/2.png" alt="1.png" /></p>
</li>
</ol>
</li>
<li>
<p>练习使用 Vim, 在你自己的机器上重做演示。</p>
</li>
<li>
<p>下个月用 Vim 完成_所有_的文件编辑。每当不够高效的时候，或者你感觉 “一定有一个更好的方式”， 尝试求助搜索引擎，很有可能有一个更好的方式。如果你遇到难题， 来我们的答疑时间或者给我们发邮件。</p>
</li>
<li>
<p>在你的其他工具中设置 Vim 快捷键 （见上面的操作指南）。</p>
</li>
<li>
<p>进一步自定义你的 ~/.vimrc 和安装更多插件。 安装插件最简单的方法是使用 Vim 的包管理器，即使用 vim-plug 安装插件：</p>
<ol>
<li>
<p>安装 vim-plug</p>
<pre><code>  curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</code></pre>
</li>
<li>
<p>修改 ~/.vimrc</p>
<pre><code> call plug#begin()
 Plug 'preservim/NERDTree' #需要安装的插件 NERDTree
 Plug 'wikitopian/hardmode'  #安装 hardmode
 ..... # 更多插件
 call plug#end()
</code></pre>
</li>
<li>
<p>在 vim 命令行中执行 <code>:PlugInstall</code><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//images/3/3.png" alt="1.png" /></p>
</li>
</ol>
</li>
<li>
<p>(高阶)用 Vim 宏将 XML 转换到 JSON (<a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">例子文件</a>)。 尝试着先完全自己做，但是在你卡住的时候可以查看上面 <a href="https://missing-semester-cn.github.io/2020/editors/#macros">宏</a> 章节。</p>
<p>可以先查看<a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/demoCode/3/example-data.json">转化后的JSON文件</a>，了解最终的转换效果。</p>
<pre><code>vim example-data.xml
</code></pre>
<p>在<code>vim</code>编辑页面中执行以下步骤：</p>
<ol>
<li>
<p>删除首尾两行</p>
<ul>
<li><code>Gdd</code>：跳转到最后一行，并删除该行</li>
<li><code>ggdd</code>： 跳转到第一行，并删除该行</li>
</ul>
</li>
<li>
<p>录制寄存器<code>e</code>，实现对<code>&lt;name&gt;</code>标签的处理</p>
<ul>
<li>
<p><code>/&lt;name&gt;</code>，再键入<code>Enter</code>，然后键入<code>N</code>：查找<code>&lt;name&gt;</code>并跳转到文件的最后一个<code>&lt;name&gt;</code></p>
</li>
<li>
<p>接下来，录制宏（即寄存器<code>e</code>）：</p>
</li>
<li>
<p><code>qe</code>：即将录制名为<code>e</code>的宏</p>
</li>
<li>
<p><code>^r&quot;</code>：<code>^</code>跳转到当前行的首个非空字符，即<code>&lt;name&gt;</code>的<code>&lt;</code>，<code>r&quot;</code>将<code>&lt;</code>替换为<code>&quot;</code></p>
</li>
<li>
<p><code>f&gt;s&quot;: &quot;</code>：<code>f&gt;</code>查找<code>&gt;</code>，此处即匹配刚才的<code>&lt;name&gt;</code>的<code>&gt;</code>；<code>s&quot;</code>将<code>&gt;</code>替换为<code>&quot;: &quot;</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code>：回到正常模式</p>
</li>
<li>
<p><code>f&lt;C&quot;</code>：查找下一个<code>&lt;</code>，由于xml文件的特征，此时匹配到的是刚才修改的<code>&lt;name&gt;</code>对应的<code>&lt;/name&gt;</code>的<code>&lt;</code>；然后，将当前位置到本行末尾的内容删除，同时插入<code>&quot;</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code>：回到正常模式</p>
</li>
<li>
<p><code>q</code>：停止录制，寄存器<code>e</code>完成</p>
<ul>
<li>寄存器<code>e</code>的效果示例：将<code>&lt;name&gt;Mike&lt;/name&gt;</code>修改为<code>&quot;name&quot;: &quot;Mike&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>录制寄存器<code>p</code>，实现对<code>&lt;person&gt;</code>标签的处理</p>
<ul>
<li>
<p><code>gg</code>：跳转到文件开头（本例中，正好处于一个<code>&lt;person&gt;</code>标签）</p>
</li>
<li>
<p>接下来，录制宏（寄存器<code>p</code>）</p>
</li>
<li>
<p><code>qp</code>：即将录制宏<code>p</code></p>
</li>
<li>
<p><code>S{</code>：将当前行删除，并替换为<code>{</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code>：回到正常模式</p>
</li>
<li>
<p><code>j@e</code>：移到下一行，并执行宏<code>e</code>（因为本例的xml文件中，<code>&lt;person&gt;</code>的下一行为<code>&lt;name&gt;</code>）</p>
</li>
<li>
<p><code>A,</code>：在本行的末尾添加上<code>,</code></p>
</li>
<li>
<p><code>&lt;Esc&gt;</code></p>
</li>
<li>
<p><code>j@e</code>：移到下一行，并执行宏<code>e</code>（本例中，完成对<code>&lt;email&gt;</code>标签行的处理，其处理与<code>&lt;name&gt;</code>标签行的一致）</p>
</li>
<li>
<p><code>jS},</code>：跳转到下一行，并删除整行，同时添加上<code>},</code>（本例中该行内容为：<code>&lt;/person&gt;</code>）</p>
</li>
<li>
<p><code>&lt;Esc&gt;q</code>：回到正常模式，并停止录制，完成宏<code>p</code></p>
</li>
</ul>
</li>
<li>
<p>录制寄存器<code>q</code>，实现从一个<code>&lt;person&gt;</code>标签到另一个<code>&lt;person&gt;</code>标签的跳转</p>
<ul>
<li><code>/&lt;person&gt;</code>：从第三步的位置开始查找下一个<code>&lt;person&gt;</code>标签</li>
<li><code>qq</code>：开始录制宏<code>q</code></li>
<li><code>@p</code>：执行宏<code>p</code>，可以将这一组<code>&lt;person&gt;</code>标签包含的内容修改为json格式</li>
<li><code>jq</code>：移到下一行，并停止录制，完成宏<code>q</code>（此时，刚好处于下一个<code>&lt;person&gt;</code>标签行）</li>
</ul>
</li>
<li>
<p>执行宏<code>q</code>到文件尾</p>
<ul>
<li><code>999@q</code>：执行999次宏<code>q</code>（本文档总行数为1002行，执行999次能确保到达文件末尾）</li>
</ul>
</li>
<li>
<p>手动修改文件内容</p>
<ul>
<li>
<p><code>gg</code></p>
</li>
<li>
<p><code>O</code>：（大写的<code>o</code>）在开头插入如下内容</p>
<pre><code>{
&quot;people&quot;: {
    &quot;person&quot;: [
</code></pre>
</li>
<li>
<p><code>&lt;Esc&gt;</code></p>
</li>
<li>
<p><code>/&lt;email&gt;</code>：跳转到文件末尾唯一未处理的<code>&lt;email&gt;</code>标签行</p>
</li>
<li>
<p><code>@e</code>：对该标签行进行处理</p>
</li>
<li>
<p><code>jS}</code>：移到下一行，删除<code>&lt;/person&gt;</code>标签</p>
</li>
<li>
<p><code>&lt;Esc&gt;</code></p>
</li>
<li>
<p><code>o</code>：在文件末尾插入以下内容</p>
<pre><code>    ]
}
}
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="数据整理"><a class="header" href="#数据整理">数据整理</a></h1>
<p><a href="https://missing-semester-cn.github.io/2020/data-wrangling/">数据整理来源</a></p>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%E6%A6%82%E8%BF%B0">数据整理概述</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E5%9B%9E%E5%88%B0%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86">回到数据整理</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#awk--%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%BC%96%E8%BE%91%E5%99%A8">awk – 另外一种编辑器</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE">分析数据</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%E6%9D%A5%E7%A1%AE%E5%AE%9A%E5%8F%82%E6%95%B0">利用数据整理来确定参数</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E6%95%B4%E7%90%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE">整理二进制数据</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html#solution-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97">Solution-数据清洗</a></li>
</ul>
<h2 id="数据整理概述"><a class="header" href="#数据整理概述">数据整理概述</a></h2>
<p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！ 这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p>
<p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p>
<p>例如这样一条命令 <code>journalctl | grep -i intel</code>，它会找到所有包含intel(不区分大小写)的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p>
<p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p>
<pre><code class="language-bash">ssh myserver journalctl
</code></pre>
<p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p>
<pre><code class="language-bash">ssh myserver journalctl | grep sshd
</code></pre>
<p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 <code>grep</code> 程序！ <code>ssh</code> 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 <code>ssh</code> 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p>
<pre><code>ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' | less
</code></pre>
<p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 <code>less</code> 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p>
<pre><code>$ ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' &gt; ssh.log
$ less ssh.log
</code></pre>
<p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 <code>sed</code> 这个非常强大的工具。</p>
<p><code>sed</code> 是一个基于文本编辑器<code>ed</code>构建的”流编辑器” 。在 <code>sed</code> 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 <code>s</code>，即替换命令，例如我们可以这样写：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed 's/.*Disconnected from //'
</code></pre>
<p>上面这段命令中，我们使用了一段简单的正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code> 命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中 <code>REGEX</code> 部分是我们需要使用的正则表达式，而 <code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p>
<h2 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h2>
<p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： <code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>?</code> 匹配前面字符零次或一次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<p><code>sed</code> 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加<code>\</code>才能使其具有特殊含义。或者，您也可以添加<code>-E</code>选项来支持这些匹配。</p>
<p>回过头我们再看<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含”Disconnected from “的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 “Disconnected from” 作为自己的用户名会怎样呢？</p>
<pre><code>Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]
</code></pre>
<p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code> 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p>
<pre><code>46.97.239.16 port 55920 [preauth]
</code></pre>
<p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给 <code>*</code> 或 <code>+</code> 增加一个<code>?</code> 后缀使其变成非贪婪模式，但是很可惜 <code>sed</code> 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式：</p>
<pre><code>perl -pe 's/.*?Disconnected from //'
</code></pre>
<p>让我们回到 <code>sed</code> 命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>是最常见的工具。<code>sed</code> 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code> 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p>
<p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p>
<p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配一整行：</p>
<pre><code> | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//'
</code></pre>
<p>让我们借助正则表达式在线调试工具<a href="https://regex101.com/r/qqbZqh/2">regex debugger</a> 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code> 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀<code>[preauth]</code>，最后再匹配行尾。</p>
<p>注意，这样做的话，即使用户名是“Disconnected from”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p>
<p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名保留下来。对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如<code>\1</code>、 <code>\2</code>、<code>\3</code>等等，因此可以使用如下命令：</p>
<pre><code> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章<a href="https://www.regular-expressions.info/email.html">e-mail address</a>，匹配电子邮箱可一点<a href="https://emailregex.com/">也不简单</a>。网络上还有很多关于如何匹配电子邮箱地址的<a href="https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression/1917982">讨论</a>。人们还为其编写了<a href="https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php">测试用例</a>及 <a href="https://mathiasbynens.be/demo/url-regex">测试矩阵</a>。您甚至可以编写一个用于判断一个数<a href="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">是否为质数</a>的正则表达式。</p>
<p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p>
<h2 id="回到数据整理"><a class="header" href="#回到数据整理">回到数据整理</a></h2>
<p>OK，现在我们有如下表达式：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用 <code>i</code> 命令)，打印特定的行 (使用 <code>p</code>命令)，基于索引选择特定行等等。详情请见<code>man sed</code>!</p>
<p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
</code></pre>
<p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
</code></pre>
<p><code>sort -n</code> 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序 <code>-k1,1</code> 则表示“仅基于以空格分割的第一列进行排序”。<code>,n</code> 部分表示“仅排序到第n个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p>
<p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code> 来代替<code>tail</code>。或者使用<code>sort -r</code>来进行倒序排序。</p>
<p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | awk '{print $2}' | paste -sd,
</code></pre>
<p>如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD <code>paste</code>使用。参考<a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell</a>的习题内容获取更多相关信息。</p>
<p>我们可以利用 <code>paste</code>命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割 (<code>-d</code>)，那<code>awk</code>的作用又是什么呢？</p>
<h2 id="awk--另外一种编辑器"><a class="header" href="#awk--另外一种编辑器">awk – 另外一种编辑器</a></h2>
<p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code> 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p>
<p>首先， <code>{print $2}</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p>
<p>让我们看看，还有什么炫酷的操作可以做。让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p>
<pre><code> | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l
</code></pre>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>{...}</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<pre><code>BEGIN { rows = 0 }
$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 }
END { print rows }
</code></pre>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 <code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以<a href="https://backreference.org/2010/02/10/idiomatic-awk">解决所有问题</a>。至于怎么做，就留给读者们做课后练习吧。</p>
<h2 id="分析数据"><a class="header" href="#分析数据">分析数据</a></h2>
<p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p>
<pre><code> | paste -sd+ | bc -l
</code></pre>
<p>使用bc需要执行<code>sudo apt install bc</code>命令。</p>
<p>下面这种更加复杂的表达式也可以：</p>
<pre><code>echo &quot;2*($(data | paste -sd+))&quot; | bc -l
</code></pre>
<p>您可以通过多种方式获取统计数据。如果已经安装了R语言，<a href="https://github.com/nferraz/st"><code>st</code></a>是个不错的选择：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | awk '{print $1}' | R --slave -e 'x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)'
</code></pre>
<p>R 也是一种编程语言，它非常适合被用来进行数据分析和<a href="https://ggplot2.tidyverse.org/">绘制图表</a>。这里我们不会讲的特别详细， 您只需要知道<code>summary</code> 可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用R语言就可以得到我们想要的统计数据。</p>
<p>如果您希望绘制一些简单的图表， <code>gnuplot</code> 可以帮助到您：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | gnuplot -p -e 'set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes'
</code></pre>
<h2 id="利用数据整理来确定参数"><a class="header" href="#利用数据整理来确定参数">利用数据整理来确定参数</a></h2>
<p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 <code>xargs</code> 即可实现：</p>
<pre><code>rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed 's/-x86.*//' | xargs rustup toolchain uninstall
</code></pre>
<h2 id="整理二进制数据"><a class="header" href="#整理二进制数据">整理二进制数据</a></h2>
<p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p>
<pre><code>ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -
 | convert - -colorspace gray -
 | gzip
 | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -'
</code></pre>
<h1 id="课后练习-3"><a class="header" href="#课后练习-3">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//data-wrangling-solution">习题解答</a></p>
<ol>
<li>
<p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.</p>
</li>
<li>
<p>统计words文件 (<code>/usr/share/dict/words</code>) 中包含至少三个<code>a</code> 且不以<code>'s</code> 结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code>的 <code>y</code>命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很 有挑战性的问题：哪个组合从未出现过？</p>
</li>
<li>
<p>进行原地替换听上去很有诱惑力，例如： <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题</p>
</li>
<li>
<p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：</p>
<pre><code>Logs begin at ...
</code></pre>
<p>和</p>
<pre><code>systemd[577]: Startup finished in ...
</code></pre>
<p>在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>
<pre><code>=== system boot:
</code></pre>
<p>和</p>
<pre><code>Previous shutdown cause: 5
</code></pre>
</li>
<li>
<p>查看之前三次重启启动信息中不同的部分(参见 <code>journalctl</code>的<code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code> 来删除<code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code> )。最后，删除所有出现过3次的内容（因为这些内容是三次启动日志中的重复部分）。</p>
</li>
<li>
<p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者<a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从<a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<a href="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p>
</li>
</ol>
<h1 id="solution-数据清洗"><a class="header" href="#solution-数据清洗">Solution-数据清洗</a></h1>
<ol>
<li>
<p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.</p>
</li>
<li>
<p>统计words文件 (<code>/usr/share/dict/words</code>) 中包含至少三个<code>a</code> 且不以<code>'s</code> 结尾的单词个数。</p>
<pre><code>#这里我是在树莓派上面操作的
cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | wc -l
# 850
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/1.png" alt="1.png" /></p>
<ul>
<li>
<p>大小写转换：<code>tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;</code></p>
</li>
<li>
<p><code>^([^a]*a){3}.*[^'s]$</code>：查找一个以 a 结尾的字符串三次</p>
</li>
<li>
<p><code>grep -v &quot;\'s$&quot;</code>：匹配结尾为’s 的结果，然后取反。 借助 <code>grep -v</code>主要是这里不支持 lookback，不然下面的正则就可以完成</p>
<pre><code> ^([^a]*a){3}.*(?&lt;!'s)$
</code></pre>
<p>这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code>的 <code>y</code>命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。</p>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq -c | sort | tail -n3
# 53 as
# 64 ns
# 102 an
</code></pre>
<p>共存在多少种词尾两字母组合？</p>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq | wc -l
</code></pre>
<p>还有一个很 有挑战性的问题：哪个组合从未出现过？ 为了得到没出现的组合，首先我们要生成一个包含全部组合的列表，然后再使用上面得到的出现的组合，比较二者不同即可。</p>
<pre><code>#!/bin/bash
for i in {a..z};do
 for j in {a..z};do
    echo  &quot;$i$j&quot;
 done
done
</code></pre>
<pre><code>./all.sh &gt; all.txt
</code></pre>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq &gt; occurance.txt
</code></pre>
<pre><code>diff --unchanged-group-format='' &lt;(cat occurance.txt) &lt;(cat all.txt) | wc -l
</code></pre>
<p><code>--unchanged-group-format=''</code>用于将两个文件中相同的内容设置为空字符串，剩下的内容就是差异的部分。</p>
</li>
</ul>
</li>
<li>
<p>进行原地替换听上去很有诱惑力，例如： <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题。<br />
<code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code> 表达式中后一个 <code>input.txt</code>会首先被清空，而且是发生在前的。所以前面一个<code>input.txt</code>在还没有被 <code>sed</code> 处理时已经为空了。在使用正则处理文件前最好是首先备份文件。</p>
<pre><code>sed -i.bak s/REGEX/SUBSTITUTION/ input.txt
</code></pre>
<p>可以自动创建一个后缀为 <code>.bak</code> 的备份文件。</p>
</li>
<li>
<p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：</p>
<pre><code>Logs begin at ...
</code></pre>
<p>和</p>
<pre><code>systemd[577]: Startup finished in ...
</code></pre>
<p>在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>
<pre><code>=== system boot:
</code></pre>
<p>和</p>
<pre><code>Previous shutdown cause: 5
</code></pre>
<p>为了进行这个练习，我们需要首先允许<code>journalctl</code>记录多次开机的日志，具体背景信息可以参考<a href="https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs">这里</a>和<a href="https://askubuntu.com/questions/765315/how-to-find-previous-boot-log-after-ubuntu-16-04-restarts">这里</a>否则我们看到的始终都只有本次启动的日志。</p>
<pre><code>vim /etc/systemd/journald.conf
</code></pre>
<p>设置<code>Storage=persistent</code> 执行上述命令后，重启</p>
<pre><code>pi@raspberrypi:~$ journalctl --list-boots
-1 d176984f171a4ceba353de47abd2b891 Thu 2021-05-27 15:55:36 BST—Fri 2021-05-28 02:09:50 BST
0 18c4819a536548a29def9f2b56f63dd0 Fri 2021-05-28 02:09:51 BST—Fri 2021-05-28 02:25:50 BST
</code></pre>
<p>可以看到已经可以列出多次启动信息了，然后我们进行十次重启。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/2.png" alt="1.png" />可以使用 <code>systemd-analyze</code>工具看一下启动时间都花在哪里：</p>
<pre><code>sudo systemd-analyze plot &gt; systemd.svg
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/3.svg" alt="1.png" /><br />
<em>右键图片新窗口打开查看大图</em><br />
可以看到启动时间为 14.157s。 接下来，编写脚本<code>getlog.sh</code>来获取最近十次的启动时间数据：</p>
<pre><code>#!/bin/bash
for i in {0..9}; do
   journalctl -b-$i | grep &quot;Startup finished in&quot;
done
</code></pre>
<pre><code>./getlog &gt; starttime.txt
</code></pre>
<pre><code>#获取最长时间
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort | tail -n1
#获取最短时间
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort -r | tail -n1
#平均数（注意 awk 要使用单引号）
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| paste -sd+ | bc -l | awk '{print $1/10}'
# 中位数
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort |paste -sd\  | awk '{print ($5+$6)/2}'
</code></pre>
<p>如果配合使用 R 语言脚本则更加简单：</p>
<pre><code>sudo apt-get install r-base
</code></pre>
<pre><code>cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort | R -e 'd&lt;-scan(&quot;stdin&quot;,quiet=TRUE);min(d);max(d);mean(d);median(d);'
</code></pre>
<pre><code>&gt; d&lt;-scan(&quot;stdin&quot;,quiet=TRUE);min(d);max(d);mean(d);median(d);
[1] 14.023
[1] 15.989
[1] 14.4304
[1] 14.2915
</code></pre>
</li>
<li>
<p>查看之前三次重启启动信息中不同的部分(参见 <code>journalctl</code>的<code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code> 来删除<code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code> )。最后，删除所有出现过3次的内容（因为这些内容上三次启动日志中的重复部分）。 简单修改上面使用的<code>getlog.sh</code>，获取最近三次的日志，然后使用下面的命令：</p>
<pre><code>#注意 uniq 只能过滤相邻的行，所以必须先排序
cat last3start.txt | sed -E &quot;s/.*pi\ (.*)/\1/&quot; | sort | uniq -c | sort | awk '$1!=3  { print }'
</code></pre>
</li>
<li>
<p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者<a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从<a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<a href="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p>
<pre><code>~$ curl 'https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm#wikipedians' \
    |sed -n &quot;/table1/,/&lt;\/table&gt;/p&quot; \
    |grep &quot;&lt;tr&quot; | sed &quot;1,12d&quot;|head -n -3 \
    |sed -E 's/(&lt;[^&gt;]*&gt;)+/ /g' \
    |sed 's/ &amp;nbsp;/ -/g' \
    |sed 's/&amp;nbsp;//g' &gt; data
   
~$ cat data # 处理后的数据为Jan2001截至Oct2018的
Oct2018 2642056 12641 70805 10498 48.9M - 6101 - - - - 10.3M - - - - - - 42.6M 
Sep2018 2629415 11171 66574 10004 48.7M - 6116 - - - - 10.1M - - - - - - 42.4M 
Aug2018 2618244 12058 68688 10640 48.5M - 6839 - - - - 10.2M - - - - - - 42.1M 
Jul2018 2606186 12026 68037 10305 48.3M - 6987 - - - - 9.5M - - - - - - 41.9M 
...
Jan2001 7 7 9 - 31 12 1 8.6 1352 29% 10% 267 301kB 3.0k 15 - - 2 163 
</code></pre>
<p>命令说明（建议先查看网站的源码格式，更加容易理解下面的操作）</p>
</li>
</ol>
<ul>
<li>
<p><code>|sed -n &quot;/table1/,/&lt;\/table&gt;/p&quot;</code>：观察网站的源代码，可以发现第一个表格的id为<code>table1</code>，该命令将截取匹配到的<code>table1</code>以及下一个<code>&lt;/table&gt;</code>标签行之间的内容</p>
</li>
<li>
<p><code>|grep &quot;&lt;tr&quot;</code>：html表格中，含有数据的行是以<code>&lt;tr</code>开头，匹配这样的行</p>
</li>
<li>
<p><code>|sed &quot;1,12d&quot;</code>：去掉前12行（包含表格的表头）</p>
</li>
<li>
<p><code>|head -n -3</code>：去掉最后3行（包含非数据的内容）（注意：部分操作系统可能不支持该用法，最笨拙的替换实现方式是：<code>|sed &quot;$d&quot;|sed &quot;$d&quot;|sed &quot;$d&quot;</code>，即执行3次删除最后一行的操作）</p>
</li>
<li>
<p><code>|sed -E 's/(&lt;[^&gt;]*&gt;)+/ /g'</code>：使用正则匹配，将所有相邻的多个html标签（格式行如<code>&lt; tag &gt;</code>）替换为空格</p>
</li>
<li>
<p><code>|sed 's/ &amp;nbsp;/ -/g</code>：原表格中部分没有数据的单元格是以<code>&amp;nbsp;</code>填充的，将其替换为 <code>-</code>，避免在对数据操作时发生窜列的情况</p>
</li>
<li>
<p><code>|sed 's/&amp;nbsp;//g</code>：原表格中部分单元格内的空格也是用<code>&amp;nbsp;</code>表示的，将其全部删除（不影响数据处理）</p>
<pre><code>~$ awk '{print $1,$4,$5}' data | sort --key=2n | head -n 1
Jan2001 9 -
# 从data中读取第一列（时间，用来定位后续结果）及第三、四列，并以第二行的数据以数字大小进行排序，然后显示最大值的结果；下一个命令显示最小值的结果

~$ awk '{print $1,$4,$5}' data | sort --key=2n | tail -n 1
Mar2007 91388 11506

~$ awk '{print $1,$4,$5}' data | awk '{print $2-$3}' | awk '{s+=$1} END {print s}'
10153001
# 使用第二列的数据减去第三列的数据后，将结果加总
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="命令行环境"><a class="header" href="#命令行环境">命令行环境</a></h1>
<p><a href="https://missing-semester-cn.github.io/2020/command-line/">命令行环境来源</a></p>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6">任务控制</a>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B">结束进程</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E6%9A%82%E5%81%9C%E5%92%8C%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B">暂停和后台执行进程</a></li>
</ul>
</li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E7%BB%88%E7%AB%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">终端多路复用</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E5%88%AB%E5%90%8D">别名</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6dotfiles">配置文件（Dotfiles）</a>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7">可移植性</a></li>
</ul>
</li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E8%BF%9C%E7%AB%AF%E8%AE%BE%E5%A4%87">远端设备</a>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4">执行命令</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#ssh-%E5%AF%86%E9%92%A5">SSH 密钥</a>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90">密钥生成</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E5%9F%BA%E4%BA%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6">基于密钥的认证机制</a></li>
</ul>
</li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E9%80%9A%E8%BF%87-ssh-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6">通过 SSH 复制文件</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">端口转发</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#ssh-%E9%85%8D%E7%BD%AE">SSH 配置</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E6%9D%82%E9%A1%B9">杂项</a></li>
</ul>
</li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#shell--%E6%A1%86%E6%9E%B6">Shell &amp; 框架</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8">终端模拟器</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6-1">任务控制</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E7%BB%88%E7%AB%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1">终端多路复用</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E5%88%AB%E5%90%8D-1">别名</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E8%BF%9C%E7%AB%AF%E8%AE%BE%E5%A4%87-1">远端设备</a></li>
</ul>
</li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#solution-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83">Solution-命令行环境</a>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6-2">任务控制</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E7%BB%88%E7%AB%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-2">终端多路复用</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E5%88%AB%E5%90%8D-2">别名</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1">配置文件</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#%E8%BF%9C%E7%AB%AF%E8%AE%BE%E5%A4%87-2">远端设备</a></li>
</ul>
</li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#ssh%E5%BC%80%E5%90%AFwin10">SSH开启（win10）</a>
<ul>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#0-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">0 应用场景</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%90%AF">1 服务端开启</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5">2 客户端连接</a></li>
<li><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html#3-%E5%85%B3%E9%97%AD%E5%AE%A2%E6%88%B7%E7%AB%AF">3 关闭客户端</a></li>
</ul>
</li>
</ul>
<p>当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p>
<p>我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p>
<p>我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。</p>
<h1 id="任务控制"><a class="header" href="#任务控制">任务控制</a></h1>
<p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用 <code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用 <code>Ctrl-C</code> 来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p>
<h2 id="结束进程"><a class="header" href="#结束进程">结束进程</a></h2>
<p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code> 信号，通过输入<code>Ctrl-\</code>可以发送该信号。</p>
<pre><code class="language-python">#!/usr/bin/env python
import signal, time

def handler(signum, time):
    print(&quot;\nI got a SIGINT, but I am not stopping&quot;)

signal.signal(signal.SIGINT, handler)
i = 0
while True:
    time.sleep(.1)
    print(&quot;\r{}&quot;.format(i), end=&quot;&quot;)
    i += 1
</code></pre>
<p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次 <code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code> 是我们在终端输入<code>Ctrl</code> 时的表示形式：</p>
<pre><code class="language-bash">$ python sigint.py
24^C
I got a SIGINT, but I am not stopping
26^C
I got a SIGINT, but I am not stopping
30^\[1]    39913 quit       python sigint.pyƒ
</code></pre>
<p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p>
<h2 id="暂停和后台执行进程"><a class="header" href="#暂停和后台执行进程">暂停和后台执行进程</a></h2>
<p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p>
<p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p>
<p>下面这个简单的会话中展示来了些概念的应用。</p>
<pre><code class="language-bash">$ sleep 1000
^Z
[1]  + 18653 suspended  sleep 1000

$ nohup sleep 2000 &amp;
[2] 18745
appending output to nohup.out

$ jobs
[1]  + suspended  sleep 1000
[2]  - running    nohup sleep 2000

$ bg %1
[1]  - 18653 continued  sleep 1000

$ jobs
[1]  - running    sleep 1000
[2]  + running    nohup sleep 2000

$ kill -STOP %1
[1]  + 18653 suspended (signal)  sleep 1000

$ jobs
[1]  + suspended (signal)  sleep 1000
[2]  - running    nohup sleep 2000

$ kill -SIGHUP %1
[1]  + 18653 hangup     sleep 1000

$ jobs
[2]  + running    nohup sleep 2000

$ kill -SIGHUP %2

$ jobs
[2]  + running    nohup sleep 2000

$ kill %2
[2]  + 18745 terminated  nohup sleep 2000

$ jobs

</code></pre>
<p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<p>您可以在 <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">这里</a> 或输入 <a href="https://www.man7.org/linux/man-pages/man7/signal.7.html"><code>man signal</code></a> 或使用 <code>kill -l</code> 来获取更多关于信号的信息。</p>
<h1 id="终端多路复用"><a class="header" href="#终端多路复用">终端多路复用</a></h1>
<p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p>
<ul>
<li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口
<ul>
<li><code>tmux</code> 开始一个新的会话</li>
<li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li>
<li><code>tmux ls</code> 列出当前所有会话</li>
<li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li>
<li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li>
</ul>
</li>
<li><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分
<ul>
<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code>关闭</li>
<li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li>
<li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li>
<li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li>
<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>
<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>
</ul>
</li>
<li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell
<ul>
<li><code>&lt;C-b&gt; &quot;</code> 水平分割</li>
<li><code>&lt;C-b&gt; %</code> 垂直分割</li>
<li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li>
<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>
<li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li>
<li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li>
</ul>
</li>
</ul>
<p>扩展阅读： <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">这里</a> 是一份 <code>tmux</code> 快速入门教程， <a href="http://linuxcommand.org/lc3_adv_termmux.php">而这一篇</a> 文章则更加详细，它包含了 <code>screen</code> 命令。您也许想要掌握 <a href="https://www.man7.org/linux/man-pages/man1/screen.1.html"><code>screen</code></a> 命令，因为在大多数 UNIX 系统中都默认安装有该程序。</p>
<h1 id="别名"><a class="header" href="#别名">别名</a></h1>
<p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<pre><code>alias alias_name=&quot;command_to_alias arg1 arg2&quot;
</code></pre>
<p>注意， <code>=</code>两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<pre><code class="language-bash"># 创建常用命令的缩写
alias ll=&quot;ls -lh&quot;

# 能够少输入很多
alias gs=&quot;git status&quot;
alias gc=&quot;git commit&quot;
alias v=&quot;vim&quot;

# 手误打错命令也没关系
alias sl=ls

# 重新定义一些命令行的默认行为
alias mv=&quot;mv -i&quot;           # -i prompts before overwrite
alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed
alias df=&quot;df -h&quot;           # -h prints human readable format

# 别名可以组合使用
alias la=&quot;ls -A&quot;
alias lla=&quot;la -l&quot;

# 在忽略某个别名
\ls
# 或者禁用别名
unalias la

# 获取别名的定义
alias ll
# 会打印 ll='ls -lh'
</code></pre>
<p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code> 或 <code>.zshrc</code>，下一节我们就会讲到。</p>
<h1 id="配置文件dotfiles"><a class="header" href="#配置文件dotfiles">配置文件（Dotfiles）</a></h1>
<p>很多程序的配置都是通过纯文本格式的被称作点文件的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源。</p>
<p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过点文件进行配置：</p>
<ul>
<li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>
<li><code>git</code> - <code>~/.gitconfig</code></li>
<li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li>
<li><code>ssh</code> - <code>~/.ssh/config</code></li>
<li><code>tmux</code> - <code>~/.tmux.conf</code></li>
</ul>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>
<ul>
<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>
<li><strong>可移植性</strong>: 您的工具在任何地方都以相同的配置工作</li>
<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>
<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>
</ul>
<p>配置文件中需要放些什么？您可以通过在线文档和<a href="https://en.wikipedia.org/wiki/Man_page">帮助手册</a>了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的<a href="https://github.com/search?o=desc&amp;q=dotfiles&amp;s=stars&amp;type=Repositories">dotfiles 仓库</a> —— 其中最受欢迎的那些可以在<a href="https://github.com/mathiasbynens/dotfiles">这里</a>找到（我们建议您不要直接复制别人的配置）。<a href="https://dotfiles.github.io/">这里</a> 也有一些非常有用的资源。</p>
<p>本课程的老师们也在 GitHub 上开源了他们的配置文件： <a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/jjgo/dotfiles">Jose</a>.</p>
<h2 id="可移植性"><a class="header" href="#可移植性">可移植性</a></h2>
<p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p>
<pre><code>if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi

# 使用和 shell 相关的配置时先检查当前 shell 类型
if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi

# 您也可以针对特定的设备进行配置
if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi
</code></pre>
<p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p>
<pre><code>[include]
    path = ~/.gitconfig_local
</code></pre>
<p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>
<pre><code># Test if ~/.aliases exists and source it
if [ -f ~/.aliases ]; then
    source ~/.aliases
fi
</code></pre>
<h1 id="远端设备"><a class="header" href="#远端设备">远端设备</a></h1>
<p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p>
<p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<pre><code>ssh foo@bar.mit.edu
</code></pre>
<p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p>
<h2 id="执行命令"><a class="header" href="#执行命令">执行命令</a></h2>
<p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。 <code>ssh foobar@server ls</code> 可以直接在用foobar的命令下执行 <code>ls</code> 命令。 想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p>
<h2 id="ssh-密钥"><a class="header" href="#ssh-密钥">SSH 密钥</a></h2>
<p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p>
<h3 id="密钥生成"><a class="header" href="#密钥生成">密钥生成</a></h3>
<p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<pre><code>ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519
</code></pre>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h3 id="基于密钥的认证机制"><a class="header" href="#基于密钥的认证机制">基于密钥的认证机制</a></h3>
<p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<pre><code>cat .ssh/id_ed25519.pub | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys'
</code></pre>
<p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p>
<pre><code>ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote
</code></pre>
<h2 id="通过-ssh-复制文件"><a class="header" href="#通过-ssh-复制文件">通过 SSH 复制文件</a></h2>
<p>使用 ssh 复制文件有很多方法：</p>
<ul>
<li><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code> 命令，然后通过这样的方法利用标准输入实现 <code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a> 命令会将标准输出写入到一个文件；</li>
<li><a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a> ：当需要拷贝大量的文件或目录时，使用<code>scp</code> 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li>
<li><a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a> 对 <code>scp</code> 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 <code>--partial</code>标记实现断点续传。<code>rsync</code> 的语法和<code>scp</code>类似；</li>
</ul>
<h2 id="端口转发"><a class="header" href="#端口转发">端口转发</a></h2>
<p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行 <em>端口转发</em>。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p>
<p><strong>本地端口转发</strong><img src="https://i.stack.imgur.com/a28N8.png%C2%A0" alt="Local Port Forwarding" title="本地端口转发" /></p>
<p><strong>远程端口转发</strong><img src="https://i.stack.imgur.com/4iK3b.png%C2%A0" alt="Remote Port Forwarding" title="远程端口转发" /></p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h2 id="ssh-配置"><a class="header" href="#ssh-配置">SSH 配置</a></h2>
<p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p>
<pre><code>alias my_server=&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server
</code></pre>
<p>不过，更好的方法是使用 <code>~/.ssh/config</code>.</p>
<pre><code>Host vm
    User foobar
    HostName 172.16.174.141
    Port 2222
    IdentityFile ~/.ssh/id_ed25519
    LocalForward 9999 localhost:8888

# 在配置文件中也可以使用通配符
Host *.mit.edu
    User foobaz
</code></pre>
<p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似 <code>scp</code>、<code>rsync</code>和<code>mosh</code>的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p>
<p>注意，<code>~/.ssh/config</code> 文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p>
<p>服务器侧的配置通常放在 <code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh 端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p>
<h2 id="杂项"><a class="header" href="#杂项">杂项</a></h2>
<p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<a href="https://mosh.org/">Mosh</a>（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p>
<p>有时将一个远端文件夹挂载到本地会比较方便， <a href="https://github.com/libfuse/sshfs">sshfs</a> 可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p>
<h1 id="shell--框架"><a class="header" href="#shell--框架">Shell &amp; 框架</a></h1>
<p>在 shell 工具和脚本那节课中我们已经介绍了 <code>bash</code> shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。</p>
<p>例如，<code>zsh</code> shell 是 <code>bash</code> 的超集并提供了一些方便的功能：</p>
<ul>
<li>智能替换, <code>**</code></li>
<li>行内替换/通配符扩展</li>
<li>拼写纠错</li>
<li>更好的 tab 补全和选择</li>
<li>路径展开 (<code>cd /u/lo/b</code> 会被展开为 <code>/usr/local/bin</code>)</li>
</ul>
<p><strong>框架</strong> 也可以改进您的 shell。比较流行的通用框架包括<a href="https://github.com/sorin-ionescu/prezto">prezto</a> 或 <a href="https://ohmyz.sh/">oh-my-zsh</a>。还有一些更精简的框架，它们往往专注于某一个特定功能，例如<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh 语法高亮</a> 或 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh 历史子串查询</a>。 像 <a href="https://fishshell.com/">fish</a> 这样的 shell 包含了很多用户友好的功能，其中一些特性包括：</p>
<ul>
<li>向右对齐</li>
<li>命令语法高亮</li>
<li>历史子串查询</li>
<li>基于手册页面的选项补全</li>
<li>更智能的自动补全</li>
<li>提示符主题</li>
</ul>
<p>需要注意的是，使用这些框架可能会降低您 shell 的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p>
<h1 id="终端模拟器"><a class="header" href="#终端模拟器">终端模拟器</a></h1>
<p>和自定义 shell 一样，花点时间选择适合您的 <strong>终端模拟器</strong>并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间<a href="https://anarc.at/blog/2018-04-12-terminal-emulators-1/">比较</a>的信息）</p>
<p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p>
<ul>
<li>字体选择</li>
<li>彩色主题</li>
<li>快捷键</li>
<li>标签页/面板支持</li>
<li>回退配置</li>
<li>性能（像 <a href="https://github.com/jwilm/alacritty">Alacritty</a> 或者 <a href="https://sw.kovidgoyal.net/kitty/">kitty</a> 这种比较新的终端，它们支持GPU加速）。</li>
</ul>
<h1 id="课后练习-4"><a class="header" href="#课后练习-4">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//command-line-solution">习题解答</a></p>
<h2 id="任务控制-1"><a class="header" href="#任务控制-1">任务控制</a></h2>
<ol>
<li>
<p>我们可以使用类似 <code>ps aux | grep</code> 这样的命令来获取任务的 pid ，然后您可以基于pid 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 <code>sleep 10000</code> 这个任务。然后用 <code>Ctrl-Z</code> 将其切换到后台并使用 <code>bg</code>来继续允许它。现在，使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 来查找 pid 并使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pkill</code></a> 结束进程而不需要手动输入pid。(提示： 使用 <code>-af</code> 标记)。</p>
</li>
<li>
<p>如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？在这个练习中，我们使用 <code>sleep 60 &amp;</code> 作为先执行的程序。一种方法是使用 <a href="http://man7.org/linux/man-pages/man1/wait.1p.html"><code>wait</code></a> 命令。尝试启动这个休眠命令，然后待其结束后再执行 <code>ls</code> 命令。</p>
<p>但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 <code>wait</code> 只能对子进程起作用。之前我们没有提过的一个特性是，<code>kill</code> 命令成功退出时其状态码为 0 ，其他状态则是非0。<code>kill -0</code> 则不会发送信号，但是会在进程不存在时返回一个不为0的状态码。请编写一个 bash 函数 <code>pidwait</code> ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 <code>sleep</code> 来避免浪费 CPU 性能。</p>
</li>
</ol>
<h2 id="终端多路复用-1"><a class="header" href="#终端多路复用-1">终端多路复用</a></h2>
<ol>
<li>请完成这个 <code>tmux</code> <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">教程</a> 参考<a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">这些步骤</a>来学习如何自定义 <code>tmux</code>。</li>
</ol>
<h2 id="别名-1"><a class="header" href="#别名-1">别名</a></h2>
<ol>
<li>创建一个 <code>dc</code> 别名，它的功能是当我们错误的将 <code>cd</code> 输入为 <code>dc</code> 时也能正确执行。</li>
<li>执行 <code>history | awk '{$1=&quot;&quot;;print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用<code>history 1</code> 替换 <code>history</code>。</li>
</ol>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<p>让我们帮助您进一步学习配置文件：</p>
<ol>
<li>为您的配置文件新建一个文件夹，并设置好版本控制</li>
<li>在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 <code>$PS1</code> 开始）。</li>
<li>建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个 shell 脚本对每个文件使用 <code>ln -s</code>，也可以使用<a href="https://dotfiles.github.io/utilities/">专用工具</a></li>
<li>在新的虚拟机上测试该安装脚本。</li>
<li>将您现有的所有配置文件移动到项目仓库里。</li>
<li>将项目发布到GitHub。</li>
</ol>
<h2 id="远端设备-1"><a class="header" href="#远端设备-1">远端设备</a></h2>
<p>进行下面的练习需要您先安装一个 Linux 虚拟机（如果已经安装过则可以直接使用），如果您对虚拟机尚不熟悉，可以参考<a href="https://hibbard.eu/install-ubuntu-virtual-box/">这篇教程</a> 来进行安装。</p>
<ol>
<li>前往 <code>~/.ssh/</code> 并查看是否已经存在 SSH 密钥对。如果不存在，请使用<code>ssh-keygen -o -a 100 -t ed25519</code>来创建一个。建议为密钥设置密码然后使用<code>ssh-agent</code>，更多信息可以参考 <a href="https://www.ssh.com/ssh/agent">这里</a>；</li>
<li>在<code>.ssh/config</code>加入下面内容：</li>
</ol>
<pre><code>Host vm
    User username_goes_here
    HostName ip_goes_here
    IdentityFile ~/.ssh/id_ed25519
    LocalForward 9999 localhost:8888
</code></pre>
<ol>
<li>使用 <code>ssh-copy-id vm</code> 将您的 ssh 密钥拷贝到服务器。</li>
<li>使用<code>python -m http.server 8888</code> 在您的虚拟机中启动一个 Web 服务器并通过本机的<code>http://localhost:9999</code> 访问虚拟机上的 Web 服务器</li>
<li>使用<code>sudo vim /etc/ssh/sshd_config</code> 编辑 SSH 服务器配置，通过修改<code>PasswordAuthentication</code>的值来禁用密码验证。通过修改<code>PermitRootLogin</code>的值来禁用 root 登录。然后使用<code>sudo service sshd restart</code>重启 <code>ssh</code> 服务器，然后重新尝试。</li>
<li>(附加题) 在虚拟机中安装 <a href="https://mosh.org/"><code>mosh</code></a> 并启动连接。然后断开服务器/虚拟机的网络适配器。mosh可以恢复连接吗？</li>
<li>(附加题) 查看<code>ssh</code>的<code>-N</code> 和 <code>-f</code> 选项的作用，找出在后台进行端口转发的命令是什么？</li>
</ol>
<h1 id="solution-命令行环境"><a class="header" href="#solution-命令行环境">Solution-命令行环境</a></h1>
<h2 id="任务控制-2"><a class="header" href="#任务控制-2">任务控制</a></h2>
<ol>
<li>
<p>我们可以使用类似 ps aux | grep 这样的命令来获取任务的 pid ，然后您可以基于pid 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 sleep 10000 这个任务。然后用 Ctrl-Z 将其切换到后台并使用 bg来继续允许它。现在，使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html">pgrep</a> 来查找 pid 并使用 <a href="http://man7.org/linux/man-pages/man1/pgrep.1.html">pkill</a> 结束进程而不需要手动输入pid。(提示：: 使用 -af 标记)。</p>
<pre><code>sleep 10000
Ctrl-Z
bg
</code></pre>
<pre><code>pgrep sleep #列出包含关键字 sleep 的进程的 pid
&gt;
# 76560
# 81186
# 81292
</code></pre>
<pre><code>pgrep sleep 10000 #列出包含关键字 sleep 的进程的 pid
&gt;
# 76560
# 81186
# 81292
</code></pre>
<pre><code>-a  Include process ancestors in the match list.  By default, the current pgrep or pkill process and all of its ancestors are excluded (unless -v is used).

-f  Match against full argument lists. The default is to match against process names.
</code></pre>
<p>使用<code>pkill --ns &lt;PID&gt;</code>来结束进程</p>
<pre><code>pkill  -af sleep
</code></pre>
</li>
<li>
<p>如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？ 在这个练习中，我们使用 sleep 60 &amp; 作为先执行的程序。一种方法是使用 wait 命令。尝试启动这个休眠命令，然后待其结束后再执行 ls 命令。</p>
<pre><code>sleep 60 &amp;
pgrep sleep | wait; ls
</code></pre>
<p>但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 <a href="https://www.man7.org/linux/man-pages/man1/wait.1p.html">wait</a> 只能对子进程起作用。之前我们没有提过的一个特性是，kill 命令成功退出时其状态码为 0 ，其他状态则是非0。kill -0 则不会发送信号，但是会在进程不存在时返回一个不为0的状态码。请编写一个 bash 函数 pidwait ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 sleep 来避免浪费 CPU 性能。</p>
<pre><code>pidwait()
{
   while kill -0 $1 #循环直到进程结束
   do
   sleep 1 
   done
   ls
}
</code></pre>
<p>需要注意的是，这里 while 判断的是命令行的返回值而不是布尔值，这个和其他语言有所区别。返回值 0 表示成功所以能够进入循环，参考<a href="https://unix.stackexchange.com/questions/185793/why-is-it-while-kill-0-pid-and-not-until-kill-0-pid">这个问题</a></p>
<pre><code>sleep 60 &amp; pidwait $(pgrep sleep 60)
[1] 554
[1]  + 554 done       sleep 60
pidwait:kill:2: kill 554 failed: no such process
buggy.sh     debug_for.sh html_root    out.log
debug.sh     html.zip     marco.sh
</code></pre>
</li>
</ol>
<h2 id="终端多路复用-2"><a class="header" href="#终端多路复用-2">终端多路复用</a></h2>
<ol>
<li>请完成这个 <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">tmux</a> 教程，并参考<a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">这些步骤</a>来学习如何自定义 tmux。</li>
</ol>
<h2 id="别名-2"><a class="header" href="#别名-2">别名</a></h2>
<ol>
<li>
<p>创建一个 dc 别名，它的功能是当我们错误的将 cd 输入为 dc 时也能正确执行。</p>
<pre><code>alias dc=cd
</code></pre>
</li>
<li>
<p>执行 <code>history | awk '{$1=&quot;&quot;;print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用history 1 替换 history。</p>
<pre><code>history | awk '{$1=&quot;&quot;;print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10
62 g++ -std=c++11 tests.cpp
64 npm run src:build
68 git pull
80 ./a.out
118 git status
186 ll
258 cd ..
263 git push
376 git add .
1066 ls
</code></pre>
</li>
</ol>
<h2 id="配置文件-1"><a class="header" href="#配置文件-1">配置文件</a></h2>
<p>让我们帮助您进一步学习配置文件：</p>
<p>为您的配置文件新建一个文件夹，并设置好版本控制 在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mord">1</span><span class="mord cjk_fallback">开始）。建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord cjk_fallback">脚本对每个文件使用</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">，也可以使用专用工具在新的虚拟机上测试该安装脚本。将您现有的所有配置文件移动到项目仓库里。将项目发布到</span><span class="mord mathnormal">G</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">。</span><span class="mord">‘‘‘</span><span class="mspace nobreak"> </span></span></span></span> mkdir ~/gits/dotfiles   # gits目录是创建用来存放所有git及github仓库的目录
~  git init ~/gits/dotfiles</p>
<h1 id="将本机的配置文件如-vimrcbashrctmuxconf-等复制进该目录"><a class="header" href="#将本机的配置文件如-vimrcbashrctmuxconf-等复制进该目录">将本机的配置文件，如 .vimrc/.bashrc/.tmux.conf 等复制进该目录</a></h1>
<p>~  ls -a ~/gits/dotfiles
.  ..  .bashrc  .git  .profile  .tmux.conf  .vimrc  .zshrc</p>
<h1 id="其中-分别表示本目录及上级目录git为git仓库的配置文件其他文件为存放在仓库中的系统配置文件"><a class="header" href="#其中-分别表示本目录及上级目录git为git仓库的配置文件其他文件为存放在仓库中的系统配置文件">其中，&quot;. ..&quot;分别表示本目录及上级目录，&quot;.git&quot;为git仓库的配置文件，其他文件为存放在仓库中的系统配置文件</a></h1>
<pre><code>
- 学习下一讲的git操作后，可以创建Github帐号，将这个仓库push到Github上
- 在另一台机器，或虚拟机上，将上面的Github仓库复制下来
    
    ```
     ~ &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8889em;vertical-align:-0.1944em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace nobreak&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; vim autoconfig.sh   # 创建脚本
     ~  cat autoconfig.sh
     #!/bin/bash
     files=(ls -a 1 | grep -E '.[^.]+' |grep -v .git)
     # 去掉 ls -a 返回结果中的 &quot;. .. .git&quot;
     for file in `echo files`; do
         ln -s $1/$file ~/$file # 创建软链接
     done
    
     ~ $ source autoconfig.sh 
     # 执行脚本，为dotfiles中的配置文件创建在主目录 ~ 下的软链接
    ```
    

## 远端设备

进行下面的练习需要您先安装一个 Linux 虚拟机（如果已经安装过则可以直接使用），如果您对虚拟机尚不熟悉，可以参考这篇教程 来进行安装。

1. 前往 ~/.ssh/ 并查看是否已经存在 SSH 密钥对。如果不存在，请使用`ssh-keygen -o -a 100 -t ed25519`来创建一个。建议为密钥设置密码然后使用ssh-agent，更多信息可以参考 这里；
    
    ```
    ssh-keygen -o -a 100 -t ed25519
    
    ls ~/.ssh
    config         id_ed25519     id_ed25519.pub known_hosts
    ```
    
2. 在.ssh/config加入下面内容：
    
    ```
    Host vm
       User username_goes_here
       HostName ip_goes_here
       IdentityFile ~/.ssh/id_ed25519
       LocalForward 9999 localhost:8888
    ```
    
    这里我的远端设备是树莓派，ssh 配置如下
    
    ```
    Host pi
       User pi
       HostName 192.168.50.56
       IdentityFile ~/.ssh/id_ed25519
       LocalForward 9999 localhost:8888
    ```
    
3. 使用 `ssh-copy-id vm` 将您的 ssh 密钥拷贝到服务器。
    
    ```
    ssh-copy-pi pi #拷贝秘钥
    ```
    
    随后可以直接使用`ssh pi`进行免密登录
    
4. 使用`python -m http.server 8888`在您的虚拟机中启动一个 Web 服务器并通过本机的`http://localhost:9999` 访问虚拟机上的 Web 服务器 这里我在树莓派上启动一个服务，并在 MacOS 上通过 ssh 端口转发进行访问。
    
    ```
    pi@raspberrypi:~$ python -m http.server 8888
    Serving HTTP on 0.0.0.0 port 8888 (http://0.0.0.0:8888/) ...
    ```
    
    ```
    curl localhost:9999
    ```
    
    ```
    pi@raspberrypi:~$ python -m http.server 8888
    Serving HTTP on 0.0.0.0 port 8888 (http://0.0.0.0:8888/) ...
    127.0.0.1 - - [15/May/2021 02:45:53] &quot;GET / HTTP/1.1&quot; 200 -
    ```
    
    ![1.png](https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/5/1.png)
    
5. 使用`sudo vim /etc/ssh/sshd_config` 编辑 SSH 服务器配置，通过修改`PasswordAuthentication`的值来禁用密码验证。通过修改`PermitRootLogin`的值来禁用 root 登录。然后使用`sudo service sshd restart`重启 ssh 服务器，然后重新尝试。
    
    ```
    #注意是服务器的 sshd 配置
    pi@raspberrypi:~$ vim /etc/ssh/sshd_config
    ```
    
    修改：
    
    - `PasswordAuthentication`的值为 no
    - `PermitRootLogin`的值为 no 然后重启服务
        
        ```
        #for MacOS
         sudo launchctl stop com.openssh.sshd
         sudo launchctl start com.openssh.sshd
        ```
        
    
    下面提供的是虚拟机上的操作示例。
    
    - 在虚拟机上创建**root登录帐号** ([login as root](https://help.ubuntu.com/community/RootSudo#root_account))。注意：root登录 和 root用户 是不一样的
    
    ```
    ~ $ VBoxManage startvm &quot;ubuntu_server&quot; --type headless
    ~ $ ssh my_server
    # 使用ssh连接成功，跳转到虚拟机的终端
    my_server@myserver:~$ sudo su
    root@myserver:~# passwd root    # 输入密码，创建root登录帐号
    root@myserver:~# vim ~/etc/ssh/sshd_config
    # 查找到行&quot;#PermitRootLogin prohibit-password&quot;，使用 o 在下方新增一行
    # 输入&quot;PermitRootLogin yes&quot;
    
    root@myserver:~# service sshd restart   
    # 重启sshd服务，使刚才的修改生效
    root@myserver:~# exit
    my_server@myserver:~$ exit
    # 断开与虚拟机的ssh连接
    ```
    
    - 备注：sshd服务可能需要重启虚拟机，才能生效（可以直接在终端重启虚拟机，如下）
    
    ```
    ~ $ VBoxManage controlvm &quot;ubuntu_server&quot; poweroff
    ~ $ VBoxManage startvm &quot;ubuntu_server&quot; --type headless
    ```
    
    - 使用 root登陆 连接虚拟机
    
    ```
    ~ $ ssh root@192.168.1.9
    # 输入刚才设置的密码
    root@myserver:~# 
    ```
    
    - 重新配置sshd，禁用 root登录
    
    ```
    root@myserver:~# vim /etc/ssh/sshd_config
    # 查找到行&quot;#PasswordAuthentication yes&quot;，使用`o`在其下方新增一行
    # 输入&quot;PasswordAuthentication no&quot;
    # 查找到行&quot;PermitRootLogin yes&quot;，将 yes 修改为 no
    
    root@myserver:~# service sshd restart    
    root@myserver:~# exit
    my_server@myserver:~$ exit
    
    ~ $
    ```
    
    - 再次尝试 root登录
    
    ```
    ~ $ ssh root@192.168.1.9
    # 要求输入密码，可是输入密码后，仍会显示
    Permission denied, please try again.
    # 显示 3 次或更多次要求输入密码后，输出
    Permission denied (publickey,password)
    ~ $ 
    ~ $ ssh my_server
    my_server@myserver:~$   
    ```
    
    - 以上对于`PermitRootLogin`及`PasswordAuthentication`的修改，只影响 root登录方式，前面使用的`ssh my_server`登录方式不受影响
    - 总体而言，允许root登录，是有安全风险的，一般不建议使用。对于已创建的root登录方式，可删除：
    
    ```
    my_server@myserver:~$ sudo passwd -dl root
    ```
    
6. 附加题：在虚拟机中安装 mosh 并启动连接。然后断开服务器/虚拟机的网络适配器。mosh可以恢复连接吗？
    
    - 在虚拟机上安装mosh
        
        ```
        my_server@myserver:~$ sudo apt-get install mosh
        my_server@myserver:~$ mosh-server
        ```
        
    - 在终端使用mosh连接虚拟机
        
        ```
        ~ $ sudo apt install mosh
        ~ $ mosh my_server@196.168.1.9
        ```
        
    - 在VirtualBox管理器的最上方，“控制(M)”中选择“设置”，在“网络”选项中，将“连接方式”（默认是“桥接网卡”）改为“未指定”，即可断开网络适配器
    - 断开网络适配器后，无论使用ssh，还是mosh连接，都不能主动恢复连接（需要重新修改虚拟机的网络连接方式）
        - mosh在断开连接后，会有提示，告知：连接断开，在尝试重连
        - 重新连上网络适配器后，ssh或mosh连接都能恢复（而且断开后连接虚拟机输入的内容能继续显示），只是mosh的延迟稍微小一些
7. 附加题：查看ssh的-N 和 -f 选项的作用，找出在后台进行端口转发的命令是什么？
    
    ```
       -N      Do not execute a remote command.  This is useful for just forwarding ports.
    
       -f      Requests ssh to go to background just before command execution.  This is useful if ssh is going to ask for passwords or passphrases, but the user wants it in the background.  This implies -n.  The recommended way to start X11 programs at a remote site is with something like ssh -f host xterm.
    
       If the ExitOnForwardFailure configuration option is set to ``yes'', then a client started with -f will wait for all remote port forwards to be successfully established before placing itself in the background.
    ```
    
    - -N 就是不执行远端命令，适用于端口转发的情况
    - -f 是让 ssh 在执行命令前切换到后台运行
    
    后台进行端口转发
    
    ```
    ssh -fN -L 9999:localhost:8888 pi
    ```











# SSH开启（win10）

[SSH开启（win10）](https://zhuanlan.zhihu.com/p/391373172)


## 0 应用场景

一台win10电脑，在局域网下，通过ssh连接到另一台win10电脑

## 1 服务端开启

**1.1 开启开发人员模式**

开始 → 设置 → 更新和安全 →开发者选项 ，把开发人员模式的开关调到“开”

![](https://pic4.zhimg.com/80/v2-6edbfaf5c7f1671848a3050b674e44ab_1440w.webp)

**1.2 安装 OpenSSH服务器**

开始 → 设置 → 系统 →可选功能，确保已经装好OpenSSH服务器，一般来说默认安装OpenSSH客户端。如果没有安装，则需要在“添加功能”里搜到并安装。

![](https://pic4.zhimg.com/80/v2-51457a21a50298b0b51e7ed2462a8f13_1440w.webp)

打开此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;到path里面添加C:\Windows\System32\OpenSSH  
 
![](https://img-blog.csdnimg.cn/bcaa28517e264e8e850f87b43c2b426d.png)

![](https://img-blog.csdnimg.cn/ce0ebb6928a4477ca6c57dc59cb232b3.png)

 至此SSH环境变量在windows添加完成，最后重启电脑即可。


**1.3 检查SSH**

按下快捷键“win + R”，输入“cmd”

![](https://pic3.zhimg.com/80/v2-8e9b4b993be66aba37f89c6d34dfc882_1440w.webp)

在命令行中输入“ssh”,如果得到以下画面，代表成功安装。

```text
ssh
</code></pre>
<p><img src="https://pic1.zhimg.com/80/v2-9c52bb268a7dcbd5c5a119967a90016c_1440w.webp" alt="" /></p>
<p><strong>1.4 开启SSH服务</strong></p>
<p>在命令行中输入&quot;net start sshd&quot;</p>
<pre><code class="language-text">net start sshd
</code></pre>
<p>如果成功开启，则有</p>
<p><img src="https://pic1.zhimg.com/80/v2-f3b242108ae94d7f8f3f0069da95df2c_1440w.webp" alt="" /></p>
<p>也有可能开启失败，例如</p>
<p><img src="https://pic2.zhimg.com/80/v2-4a7f4b37c26d8849d60396e866a99f7d_1440w.webp" alt="" /></p>
<p>这是权限的问题，以管理员的身份操作即可。</p>
<p>右键屏幕左下方的“开始”，点击“Windows PowerShell(管理员)”</p>
<p>再输入&quot;net start sshd&quot;即可</p>
<p><img src="https://pic4.zhimg.com/80/v2-2984b97d7f061e86470e621b07a4515f_1440w.webp" alt="" /></p>
<p><strong>1.5 获取用户名和IP</strong></p>
<p>客服端通过SSH连接服务器，需要用到服务器的用户名和IP。</p>
<p>用户名获取：在CMD命令行上输入：“echo %username%”</p>
<pre><code class="language-text">echo %username%
</code></pre>
<p><img src="https://pic3.zhimg.com/80/v2-e13b257442a351b15b46e28ded839f0e_1440w.webp" alt="" /></p>
<p>获取IP：在CMD命令行上输入：&quot;ipconfig&quot;</p>
<pre><code class="language-text">ipconfig
</code></pre>
<p><img src="https://pic4.zhimg.com/80/v2-797c77b545f142025eefd6f735bc5ae3_1440w.webp" alt="" /></p>
<h2 id="2-客户端连接"><a class="header" href="#2-客户端连接">2 客户端连接</a></h2>
<p>在另一台win10电脑，在CMD命令行上输入：ssh 服务器用户名 @服务器IP，例如</p>
<p>用户名假如查到的是：Administrator</p>
<p>IP假如查到的是：192.168.0.177</p>
<pre><code class="language-text">ssh Administrator@192.168.0.177
</code></pre>
<p><img src="https://pic4.zhimg.com/80/v2-3695f9008bba0d60483817e2b6fca2ab_1440w.webp" alt="" /></p>
<p>输入服务器（win10电脑）的密码即可。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ba109e8c6f63ea8c7799f139bb4de892_1440w.webp" alt="" /></p>
<h2 id="3-关闭客户端"><a class="header" href="#3-关闭客户端">3 关闭客户端</a></h2>
<p>服务的开启和关闭不影响你使用ssh连接,只要你有OpenSSH客户端</p>
<pre><code class="language-bash">net start sshd # 开启ssh服务  (windows中)
net stop sshd # 关闭ssh服务  (windows中)   

logout             # linux中退出系统 (不想输入,直接Ctrl+D组合键也可)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="版本控制git"><a class="header" href="#版本控制git">版本控制(Git)</a></h1>
<p>版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p>
<p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p>
<p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p>
<ul>
<li>当前模块是谁编写的？</li>
<li>这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li>
<li>最近的1000个版本中，何时/为什么导致了单元测试失败？</li>
</ul>
<p>尽管版本控制系统有很多， 其事实上的标准则是 <strong>Git</strong> 。而这篇 <a href="https://xkcd.com/1597/">XKCD 漫画</a> 则反映出了人们对 Git 的评价：</p>
<p><img src="https://imgs.xkcd.com/comics/git.png" alt="xkcd 1597" /></p>
<p>因为 Git 接口的抽象泄漏（leaky abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git 可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p>
<p>尽管 Git 的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍 Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git 的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p>
<p><a href="https://missing-semester-cn.github.io/2020/version-control/">Git版本控制来源</a></p>
<ul>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#git-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">Git 的数据模型</a>
<ul>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E5%BF%AB%E7%85%A7snapshot">快照（Snapshot）</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E5%BB%BA%E6%A8%A1%E5%85%B3%E8%81%94%E5%BF%AB%E7%85%A7">历史记录建模：关联快照</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA">数据模型及其伪代码表示</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80">对象和内存寻址</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E5%BC%95%E7%94%A8">引用</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E4%BB%93%E5%BA%93">仓库</a></li>
</ul>
</li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E6%9A%82%E5%AD%98%E5%8C%BA">暂存区</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#git-%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%8F%A3">Git 的命令行接口</a>
<ul>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E5%9F%BA%E7%A1%80">基础</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6">分支和合并</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E8%BF%9C%E7%AB%AF%E6%93%8D%E4%BD%9C">远端操作</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E6%92%A4%E9%94%80">撤销</a></li>
</ul>
</li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#git-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C">Git 高级操作</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E6%9D%82%E9%A1%B9">杂项</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E8%B5%84%E6%BA%90">资源</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6Git.html#solution-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">Solution-版本控制</a></li>
</ul>
<h1 id="git-的数据模型"><a class="header" href="#git-的数据模型">Git 的数据模型</a></h1>
<p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p>
<h2 id="快照snapshot"><a class="header" href="#快照snapshot">快照（Snapshot）</a></h2>
<p>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p>
<pre><code>&lt;root&gt; (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = &quot;hello world&quot;)
|
+- baz.txt (blob, contents = &quot;git is wonderful&quot;)
</code></pre>
<p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p>
<h2 id="历史记录建模关联快照"><a class="header" href="#历史记录建模关联快照">历史记录建模：关联快照</a></h2>
<p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，Git 并没有采用这样的模型。</p>
<p>在 Git 中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p>
<p>在 Git 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p>
<pre><code>o &lt;-- o &lt;-- o &lt;-- o
            ^  
             \
              --- o &lt;-- o
</code></pre>
<p>上面是一个 ASCII 码构成的简图，其中的 <code>o</code> 表示一次提交（快照）。</p>
<p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p>
<pre><code>
o &lt;-- o &lt;-- o &lt;-- o &lt;---- o
            ^            /
             \          v
              --- o &lt;-- o
</code></pre>
<p>Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p>
<h2 id="数据模型及其伪代码表示"><a class="header" href="#数据模型及其伪代码表示">数据模型及其伪代码表示</a></h2>
<p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p>
<pre><code>// 文件就是一组数据
type blob = array&lt;byte&gt;

// 一个包含文件和目录的目录
type tree = map&lt;string, tree | blob&gt;

// 每个提交都包含一个父辈，元数据和顶层树
type commit = struct {
    parent: array&lt;commit&gt;
    author: string
    message: string
    snapshot: tree
}
</code></pre>
<p>这是一种简洁的历史模型。</p>
<h2 id="对象和内存寻址"><a class="header" href="#对象和内存寻址">对象和内存寻址</a></h2>
<p>Git 中的对象可以是 blob、树或提交：</p>
<pre><code>type object = blob | tree | commit
</code></pre>
<p>Git 在储存数据时，所有的对象都会基于它们的 <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p>
<pre><code>objects = map&lt;string, object&gt;

def store(object):
    id = sha1(object)
    objects[id] = object

def load(id):
    return objects[id]
</code></pre>
<p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p>
<p>例如，<a href="https://missing-semester-cn.github.io/2020/version-control/#snapshots">上面</a>例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化），看上去是这样的：</p>
<pre><code>100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt
040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo
</code></pre>
<p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> (blob) 和 <code>foo</code> (树)。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p>
<pre><code>git is wonderful
</code></pre>
<h2 id="引用"><a class="header" href="#引用">引用</a></h2>
<p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p>
<p>针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code> 引用通常会指向主分支的最新一次提交。</p>
<pre><code>references = map&lt;string, string&gt;

def update_reference(name, id):
    references[name] = id

def read_reference(name):
    return references[name]

def load_reference(name_or_id):
    if name_or_id in references:
        return load(references[name_or_id])
    else:
        return load(name_or_id)
</code></pre>
<p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p>
<p>有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p>
<h2 id="仓库"><a class="header" href="#仓库">仓库</a></h2>
<p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和 <code>引用</code>。</p>
<p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>
<p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交 <code>5d83f9e</code> 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p>
<h1 id="暂存区"><a class="header" href="#暂存区">暂存区</a></h1>
<p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p>
<p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p>
<p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。</p>
<h1 id="git-的命令行接口"><a class="header" href="#git-的命令行接口">Git 的命令行接口</a></h1>
<p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 <a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>或可以观看本讲座的视频来学习。</p>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<ul>
<li><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li>
<li><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</li>
<li><code>git status</code>: 显示当前的仓库状态</li>
<li><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li>
<li><code>git commit</code>: 创建一个新的提交
<ul>
<li>如何编写 <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li>
<li>为何要 <a href="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li>
</ul>
</li>
<li><code>git log</code>: 显示历史日志</li>
<li><code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</li>
<li><code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li>
<li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</li>
<li><code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</li>
</ul>
<h2 id="分支和合并"><a class="header" href="#分支和合并">分支和合并</a></h2>
<ul>
<li><code>git branch</code>: 显示分支</li>
<li><code>git branch &lt;name&gt;</code>: 创建分支</li>
<li><code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支
<ul>
<li>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li>
</ul>
</li>
<li><code>git merge &lt;revision&gt;</code>: 合并到当前分支</li>
<li><code>git mergetool</code>: 使用工具来处理合并冲突</li>
<li><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</li>
</ul>
<h2 id="远端操作"><a class="header" href="#远端操作">远端操作</a></h2>
<ul>
<li><code>git remote</code>: 列出远端</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li>
<li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li>
<li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li>
<li><code>git fetch</code>: 从远端获取对象/索引</li>
<li><code>git pull</code>: 相当于 <code>git fetch; git merge</code></li>
<li><code>git clone</code>: 从远端下载仓库</li>
</ul>
<h2 id="撤销"><a class="header" href="#撤销">撤销</a></h2>
<ul>
<li><code>git commit --amend</code>: 编辑提交的内容或信息</li>
<li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li>
<li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li>
<li><code>git restore</code>: git2.32版本后取代git reset 进行许多撤销操作</li>
</ul>
<h1 id="git-高级操作"><a class="header" href="#git-高级操作">Git 高级操作</a></h1>
<ul>
<li><code>git config</code>: Git 是一个 <a href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li>
<li><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li>
<li><code>git add -p</code>: 交互式暂存</li>
<li><code>git rebase -i</code>: 交互式变基</li>
<li><code>git blame</code>: 查看最后修改某行的人</li>
<li><code>git stash</code>: 暂时移除工作目录下的修改内容</li>
<li><code>git bisect</code>: 通过二分查找搜索历史记录</li>
<li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">指定</a> 故意不追踪的文件</li>
</ul>
<h1 id="杂项-1"><a class="header" href="#杂项-1">杂项</a></h1>
<ul>
<li><strong>图形用户界面</strong>: Git 的 <a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a> 有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</li>
<li><strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>这样的框架中一般以及集成了这一功能</li>
<li><strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> 是 Vim 中集成 GIt 的常用插件</li>
<li><strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有<a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a> <a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a> <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</li>
<li><strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub 中您需要使用一个被称作<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>的方法来向其他项目贡献代码</li>
<li><strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像 <a href="https://about.gitlab.com/">GitLab</a> 和 <a href="https://bitbucket.org/">BitBucket</a> 这样的平台。</li>
</ul>
<h1 id="资源"><a class="header" href="#资源">资源</a></h1>
<ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git</a> ，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li>
<li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> ，简短的介绍了如何从 Git 错误中恢复；</li>
<li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> ，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li>
<li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li>
<li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> 通过基于浏览器的游戏来学习 Git ；</li>
</ul>
<h1 id="课后练习-5"><a class="header" href="#课后练习-5">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//version-control-solution">习题解答</a></p>
<ol>
<li>如果您之前从来没有用过 Git，推荐您阅读 <a href="https://git-scm.com/book/en/v2">Pro Git</a> 的前几章，或者完成像 <a href="https://learngitbranching.js.org/">Learn Git Branching</a>这样的教程。重点关注 Git 命令和数据模型相关内容；</li>
<li>Fork <a href="https://github.com/missing-semester-cn/missing-semester-cn.github.io.git">本课程网站的仓库</a>
<ol>
<li>将版本历史可视化并进行探索</li>
<li>是谁最后修改了 <code>README.md</code>文件？（提示：使用 <code>git log</code> 命令并添加合适的参数）</li>
<li>最后一次修改<code>_config.yml</code> 文件中 <code>collections:</code> 行时的提交信息是什么？（提示：使用 <code>git blame</code> 和 <code>git show</code>）</li>
</ol>
</li>
<li>使用 Git 时的一个常见错误是提交本不应该由 Git 管理的大文件，或是将含有敏感信息的文件提交给 Git 。尝试向仓库中添加一个文件并添加提交信息，然后将其从历史中删除 ( <a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">这篇文章也许会有帮助</a>)；</li>
<li>从 GitHub 上克隆某个仓库，修改一些文件。当您使用 <code>git stash</code> 会发生什么？当您执行 <code>git log --all --oneline</code> 时会显示什么？通过 <code>git stash pop</code> 命令来撤销 <code>git stash</code> 操作，什么时候会用到这一技巧？</li>
<li>与其他的命令行工具一样，Git 也提供了一个名为 <code>~/.gitconfig</code> 配置文件 (或 dotfile)。请在 <code>~/.gitconfig</code> 中创建一个别名，使您在运行 <code>git graph</code> 时，您可以得到 <code>git log --all --graph --decorate --oneline</code> 的输出结果；</li>
<li>您可以通过执行 <code>git config --global core.excludesfile ~/.gitignore_global</code> 在 <code>~/.gitignore_global</code> 中创建全局忽略规则。配置您的全局 gitignore 文件来自动忽略系统或编辑器的临时文件，例如 <code>.DS_Store</code>；</li>
<li>克隆 <a href="https://github.com/missing-semester-cn/missing-semester-cn.github.io.git">本课程网站的仓库</a>，找找有没有错别字或其他可以改进的地方，在 GitHub 上发起拉取请求（Pull Request）；</li>
</ol>
<h1 id="solution-版本控制"><a class="header" href="#solution-版本控制">Solution-版本控制</a></h1>
<ol>
<li>
<p>如果您之前从来没有用过 Git，推荐您阅读 Pro Git 的前几章，或者完成像 Learn Git Branching这样的教程。重点关注 Git 命令和数据模型相关内容；</p>
</li>
<li>
<p>Fork 本课程网站的仓库</p>
</li>
<li>
<p>将版本历史可视化并进行探索（按q退出git log）</p>
<pre><code> git log --all --graph --decorate
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/1.png" alt="1.png" /></p>
</li>
<li>
<p>是谁最后修改了 README.md文件？（提示：使用 git log 命令并添加合适的参数）</p>
<pre><code>git log -1 README.md
</code></pre>
<ul>
<li>-x 选项：查看最新的 x 次提交或特定文件的版本信息<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/2.png" alt="1.png" /></li>
</ul>
</li>
<li>
<p>最后一次修改_config.yml 文件中 collections: 行时的提交信息是什么？（提示：使用 git blame 和 git show）</p>
<pre><code> git blame _config.yml | grep collections
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/3.png" alt="1.png" /></p>
<pre><code> git show --pretty=format:&quot;%s&quot; a88b4eac | head -1
</code></pre>
<p>或者，使用git log命令</p>
<pre><code> git log --pretty=format:&quot;%s&quot; a88b4eac -1
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/4.png" alt="1.png" /></p>
</li>
<li>
<p>使用 Git 时的一个常见错误是提交本不应该由 Git 管理的大文件，或是将含有敏感信息的文件提交给 Git 。尝试向仓库中添加一个文件并添加提交信息，然后将其从历史中删除 ( 这篇文章也许会有帮助)；</p>
</li>
<li>
<p>首先提交一些敏感信息</p>
<pre><code> echo &quot;password123&quot;&gt;my_password
 git add .
 git commit -m &quot;add password123 to file&quot;
 git log HEAD
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/5.png" alt="1.png" /></p>
</li>
<li>
<p>使用<code>git filter-branch</code>清除提交记录</p>
<pre><code> git filter-branch --force --index-filter\
 'git rm --cached --ignore-unmatch ./my_password' \
 --prune-empty --tag-name-filter cat -- --all
</code></pre>
<p>文件已经删除<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/6.png" alt="1.png" />提交记录已经删除<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/7.png" alt="1.png" />
这里会报如下的Warning：<code>git-filter-branch has a glut of gotchas generating mangled history rewrites.  Hit Ctrl-C before proceeding to abort, then use an alternative filtering tool such as 'git filter-repo'(https://github.com/newren/git-filter-repo/) instead.  See the filter-branch manual page for more details; to squelch this warning, set FILTER_BRANCH_SQUELCH_WARNING=1.</code></p>
</li>
<li>
<p>从 GitHub 上克隆某个仓库，修改一些文件。当您使用 git stash 会发生什么？当您执行 git log –all –oneline 时会显示什么？通过 git stash pop 命令来撤销 git stash 操作，什么时候会用到这一技巧？<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/8.png" alt="1.png" /><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/9.png" alt="1.png" /><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/10.png" alt="1.png" /><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/11.png" alt="1.png" /></p>
<ul>
<li>接下来，将在视频展示的demo仓库上展示stash操作（注意：Git Graph是可视化版本控制插件，GitLens是源代码管理插件，不是git的命令。）</li>
</ul>
<pre><code> ~/gits/demo (main?) $ git graph
 * a735daf (HEAD -&gt; main) Change the print functions
 - 9d983c7 Merge branch 'dog'
 |\
 | * aa83cee (dog) Add dog functionality
 * | 077e2a0 (cat) Add cat functionality
 |/
 * ce1d2f0 Add animal.py
 * ba821e1 Add another line
 * 1547103 Create demo for learning git commands
</code></pre>
<ul>
<li>创建新文件，添加到暂存区后，将其存入stash存储列表</li>
</ul>
<pre><code> ~/gits/demo (main?) $ echo 'new file' &gt; file.txt
 ~/gits/demo (main?) $ git add file.txt
 ~/gits/demo (main+?) $ git status
 On branch main
 Changes to be committed:
   (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
         new file:   file.txt

  # 将暂存区的file.txt存到stash 
 ~/gits/demo (main+) $ git stash save &quot;create file.txt&quot;
 Saved working directory and index state On main: create file.txt
</code></pre>
<ul>
<li>查看stash存储的内容</li>
</ul>
<pre><code>  # 列出所有的存储，按照git stash的执行顺序依次从0开始编号
  # 每份存储对应的编号，就是stash@{}中的数字
 ~/gits/demo (main) $ git stash list
 stash@{0}: On main: create file.txt

  # git stash show默认显示第一份存储，也可以指定要显示的存储
 ~/gits/demo (main) $ git stash show
  file.txt | 1 +
  1 file changed, 1 insertion(+)
 ~/gits/demo (main) $ git stash show stash@{0}
  file.txt | 1 +
  1 file changed, 1 insertion(+)
</code></pre>
<ul>
<li>执行<code>git stash</code>后，添加到暂存区的内容不会再提示需要提交(Changes to be committed)。而且，尽管执行<code>git stash</code>使得提交记录新增了两项，但是可以发现<code>HEAD</code>引用并没有变动。</li>
</ul>
<pre><code> ~/gits/demo (main) $ git status
 On branch main
 nothing to commit, working tree clean

 ~/gits/demo (main) $ git graph
 - 27e9528 (refs/stash) On main: create file.txt
 |\
 | * 108018a index on main: a735daf Change the print functions
 |/
 * a735daf (HEAD -&gt; main) Change the print functions
 - 9d983c7 Merge branch 'dog'
 |\
 | * aa83cee (dog) Add dog functionality
 * | 077e2a0 (cat) Add cat functionality
 |/
 * ce1d2f0 Add animal.py
 * ba821e1 Add another line
 * 1547103 Create demo for learning git commands
</code></pre>
<ul>
<li>从main分支切换到dog分支，再将存储恢复，然后提交，这时，我们刚才新建的file.txt,变成了dog分支下的一次新提交。</li>
</ul>
<pre><code> ~/gits/demo (main) $ git checkout dog
 Switched to branch 'dog'
 ~/gits/demo (dog) $ git stash pop
 On branch dog
 Changes to be committed:
   (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
         new file:   file.txt
    
 Dropped refs/stash@{0} (27e95285da3d0bad0c2a452238628dd893e623b7)
  # 该命令会删除原来的存储stash@{0}，并在当前分支dog下恢复暂存区文件file.txt
 ~/gits/demo (dog+) $ git status
 On branch dog
 Changes to be committed:
   (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
         new file:   file.txt
    
 ~/gits/demo (dog+) $ git commit -m 'Add file.txt on branch dog'
 [dog 19b71ce] Add file.txt on branch dog
  1 file changed, 1 insertion(+)
  create mode 100644 file.txt

 ~/gits/demo (dog) $ git graph
 * 19b71ce (HEAD -&gt; dog) Add file.txt on branch dog
 | * a735daf (main) Change the print functions
 | - 9d983c7 Merge branch 'dog'
 | |\
 | |/
 |/|
 * | aa83cee Add dog functionality
 | * 077e2a0 (cat) Add cat functionality
 |/
 * ce1d2f0 Add animal.py
 * ba821e1 Add another line
 * 1547103 Create demo for learning git commands
</code></pre>
<ul>
<li>当我们将改动添加到暂存区（<code>git add</code>）后，通过执行<code>git stash</code>后，可以自由地切换到其他分支（注意：在暂存区存有改动时，切换分支(<code>checkout</code>)是不被允许的）</li>
<li>另外，运用<code>stash</code>和<code>stash pop</code>，可以自由选择 <em>stash存储的改动</em> 即将提交到的分支（本例中，将原本应该在main分支下提交的记录移动到了dog分支下进行提交）</li>
</ul>
</li>
<li>
<p>与其他的命令行工具一样，Git 也提供了一个名为 ~/.gitconfig 配置文件 (或 dotfile)。请在 ~/.gitconfig 中创建一个别名，使您在运行 git graph 时，您可以得到 git log –all –graph –decorate –oneline 的输出结果；</p>
<pre><code>[alias]
    graph = log --all --graph --decorate --oneline
</code></pre>
</li>
<li>
<p>您可以通过执行 git config –global core.excludesfile ~/.gitignore_global 在 ~/.gitignore_global 中创建全局忽略规则。配置您的全局 gitignore 文件来自动忽略系统或编辑器的临时文件，例如 .DS_Store；</p>
<pre><code>git config --global core.excludesfile ~/.gitignore .DS_Store
</code></pre>
</li>
<li>
<p>克隆 本课程网站的仓库，找找有没有错别字或其他可以改进的地方，在 GitHub 上发起拉取请求（Pull Request）； 首先 fork 本网站仓库，然后克隆 fork 后的仓库</p>
<pre><code>git clone https://github.com/hanxiaomax/missing-semester.git
</code></pre>
<p>在本地进行修改后，提交到 fork 后的仓库，然后<a href="https://github.com/missing-semester/missing-semester/pulls">发起 PR</a></p>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/12.png" alt="1.png" /></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="调试及性能分析"><a class="header" href="#调试及性能分析">调试及性能分析</a></h1>
<p>代码不能完全按照您的想法运行，它只能完全按照您的写法运行，这是编程界的一条金科玉律。</p>
<p>让您的写法符合您的想法是非常困难的。在这节课中，我们会传授给您一些非常有用技术，帮您处理代码中的 bug 和程序性能问题。</p>
<ul>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81">调试代码</a>
<ul>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E6%89%93%E5%8D%B0%E8%B0%83%E8%AF%95%E6%B3%95%E4%B8%8E%E6%97%A5%E5%BF%97">打印调试法与日志</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F">第三方日志系统</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E8%B0%83%E8%AF%95%E5%99%A8">调试器</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E4%B8%93%E9%97%A8%E5%B7%A5%E5%85%B7">专门工具</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90">静态分析</a></li>
</ul>
</li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">性能分析</a>
<ul>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E8%AE%A1%E6%97%B6">计时</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7profilers">性能分析工具（profilers）</a>
<ul>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#cpu">CPU</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E5%86%85%E5%AD%98">内存</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90">事件分析</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E5%8F%AF%E8%A7%86%E5%8C%96">可视化</a></li>
</ul>
</li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7">资源监控</a>
<ul>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E4%B8%93%E7%94%A8%E5%B7%A5%E5%85%B7">专用工具</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a>
<ul>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E8%B0%83%E8%AF%95">调试</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-1">性能分析</a></li>
</ul>
</li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#solution-%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">Solution-调试与性能分析</a>
<ul>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#1-%E8%B0%83%E8%AF%95">1. 调试</a></li>
<li><a href="%E8%B0%83%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html#2-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">2. 性能分析</a></li>
</ul>
</li>
</ul>
<p><a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析来源</a></p>
<h1 id="调试代码"><a class="header" href="#调试代码">调试代码</a></h1>
<h2 id="打印调试法与日志"><a class="header" href="#打印调试法与日志">打印调试法与日志</a></h2>
<p>“最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句” — Brian Kernighan, <em>Unix 新手入门</em>。</p>
<p>调试代码的第一种方法往往是在您发现问题的地方添加一些打印语句，然后不断重复此过程直到您获取了足够的信息并找到问题的根本原因。</p>
<p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p>
<ul>
<li>您可以将日志写入文件、socket 或者甚至是发送到远端服务器而不仅仅是标准输出；</li>
<li>日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR等)，这使您可以根据需要过滤日志；</li>
<li>对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。</li>
</ul>
<p><a href="https://missing-semester-cn.github.io/static/files/logger.py">这里</a> 是一个包含日志的例程序：</p>
<pre><code class="language-python">import logging
import sys

class CustomFormatter(logging.Formatter):
    &quot;&quot;&quot;Logging Formatter to add colors and count warning / errors&quot;&quot;&quot;

    grey = &quot;\x1b[38;21m&quot;
    yellow = &quot;\x1b[33;21m&quot;
    red = &quot;\x1b[31;21m&quot;
    bold_red = &quot;\x1b[31;1m&quot;
    reset = &quot;\x1b[0m&quot;
    format = &quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)&quot;

    FORMATS = {
        logging.DEBUG: grey + format + reset,
        logging.INFO: grey + format + reset,
        logging.WARNING: yellow + format + reset,
        logging.ERROR: red + format + reset,
        logging.CRITICAL: bold_red + format + reset
    }

    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)

# create logger with 'spam_application'
logger = logging.getLogger(&quot;Sample&quot;)

# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

if len(sys.argv)&gt; 1:
    if sys.argv[1] == 'log':
        ch.setFormatter(logging.Formatter('%(asctime)s : %(levelname)s : %(name)s : %(message)s'))
    elif sys.argv[1] == 'color':
        ch.setFormatter(CustomFormatter())

if len(sys.argv) &gt; 2:
    logger.setLevel(logging.__getattribute__(sys.argv[2]))
else:
    logger.setLevel(logging.DEBUG)

logger.addHandler(ch)

# logger.debug(&quot;debug message&quot;)
# logger.info(&quot;info message&quot;)
# logger.warning(&quot;warning message&quot;)
# logger.error(&quot;error message&quot;)
# logger.critical(&quot;critical message&quot;)

import random
import time
for _ in range(100):
    i = random.randint(0, 10)
    if i &lt;= 4:
        logger.info(&quot;Value is {} - Everything is fine&quot;.format(i))
    elif i &lt;= 6:
        logger.warning(&quot;Value is {} - System is getting hot&quot;.format(i))
    elif i &lt;= 8:
        logger.error(&quot;Value is {} - Dangerous region&quot;.format(i))
    else:
        logger.critical(&quot;Maximum value reached&quot;)
    time.sleep(0.3)

</code></pre>
<pre><code>$ python logger.py
# Raw output as with just prints
$ python logger.py log
# Log formatted output
$ python logger.py log ERROR
# Print only ERROR levels and above
$ python logger.py color
# Color formatted output
</code></pre>
<p>有很多技巧可以使日志的可读性变得更好，我最喜欢的一个是技巧是对其进行着色。到目前为止，您应该已经知道，以彩色文本显示终端信息时可读性更好。但是应该如何设置呢？</p>
<p><code>ls</code> 和 <code>grep</code> 这样的程序会使用 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>，它是一系列的特殊字符，可以使您的 shell 改变输出结果的颜色。例如，执行 <code>echo -e &quot;\e[38;2;255;0;0mThis is red\e[0m&quot;</code> 会打印红色的字符串：<code>This is red</code> 。只要您的终端支持<a href="https://gist.github.com/XVilka/8346728#terminals--true-color">真彩色</a>。如果您的终端不支持真彩色（例如 MacOS 的 Terminal.app），您可以使用支持更加广泛的 16 色，例如：”\e[31;1mThis is red\e[0m”。</p>
<p>下面这个脚本向您展示了如何在终端中打印多种颜色（只要您的终端支持真彩色）</p>
<pre><code>#!/usr/bin/env bash
for R in $(seq 0 20 255); do
    for G in $(seq 0 20 255); do
        for B in $(seq 0 20 255); do
            printf &quot;\e[38;2;${R};${G};${B}m█\e[0m&quot;;
        done
    done
done
</code></pre>
<h2 id="第三方日志系统"><a class="header" href="#第三方日志系统">第三方日志系统</a></h2>
<p>如果您正在构建大型软件系统，您很可能会使用到一些依赖，有些依赖会作为程序单独运行。如 Web 服务器、数据库或消息代理都是此类常见的第三方依赖。</p>
<p>和这些系统交互的时候，阅读它们的日志是非常必要的，因为仅靠客户端侧的错误信息可能并不足以定位问题。</p>
<p>幸运的是，大多数的程序都会将日志保存在您的系统中的某个地方。对于 UNIX 系统来说，程序的日志通常存放在 <code>/var/log</code>。例如， <a href="https://www.nginx.com/">NGINX</a> web 服务器就将其日志存放于<code>/var/log/nginx</code>。</p>
<p>目前，系统开始使用 <strong>system log</strong>，您所有的日志都会保存在这里。大多数（但不是全部的）Linux 系统都会使用 <code>systemd</code>，这是一个系统守护进程，它会控制您系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code> 会将日志以某种特殊格式存放于<code>/var/log/journal</code>，您可以使用 <a href="http://man7.org/linux/man-pages/man1/journalctl.1.html"><code>journalctl</code></a> 命令显示这些消息。</p>
<p>类似地，在 macOS 系统中是 <code>/var/log/system.log</code>，但是有更多的工具会使用系统日志，它的内容可以使用 <a href="https://www.manpagez.com/man/1/log/"><code>log show</code></a> 显示。</p>
<p>对于大多数的 UNIX 系统，您也可以使用<a href="http://man7.org/linux/man-pages/man1/dmesg.1.html"><code>dmesg</code></a> 命令来读取内核的日志。</p>
<p>如果您希望将日志加入到系统日志中，您可以使用 <a href="http://man7.org/linux/man-pages/man1/logger.1.html"><code>logger</code></a> 这个 shell 程序。下面这个例子显示了如何使用 <code>logger</code>并且如何找到能够将其存入系统日志的条目。</p>
<p>不仅如此，大多数的编程语言都支持向系统日志中写日志。</p>
<pre><code>logger &quot;Hello Logs&quot;
# On macOS
log show --last 1m | grep Hello
# On Linux
journalctl --since &quot;1m ago&quot; | grep Hello
</code></pre>
<p>正如我们在数据整理那节课上看到的那样，日志的内容可以非常的多，我们需要对其进行处理和过滤才能得到我们想要的信息。</p>
<p>如果您发现您需要对 <code>journalctl</code> 和 <code>log show</code> 的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出。还有一些像 <a href="http://lnav.org/"><code>lnav</code></a> 这样的工具，它为日志文件提供了更好的展现和浏览方式。</p>
<h2 id="调试器"><a class="header" href="#调试器">调试器</a></h2>
<p>当通过打印已经不能满足您的调试需求时，您应该使用调试器。</p>
<p>调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到：</p>
<ul>
<li>当到达某一行时将程序暂停；</li>
<li>一次一条指令地逐步执行程序；</li>
<li>程序崩溃后查看变量的值；</li>
<li>满足特定条件时暂停程序；</li>
<li>其他高级功能。</li>
</ul>
<p>很多编程语言都有自己的调试器。Python 的调试器是<a href="https://docs.python.org/3/library/pdb.html"><code>pdb</code></a>.</p>
<p>下面对<code>pdb</code> 支持的命令进行简单的介绍：</p>
<ul>
<li><strong>l</strong>(ist) - 显示当前行附近的11行或继续执行之前的显示；</li>
<li><strong>s</strong>(tep) - 执行当前行，并在第一个可能的地方停止；</li>
<li><strong>n</strong>(ext) - 继续执行直到当前函数的下一条语句或者 return 语句；</li>
<li><strong>b</strong>(reak) - 设置断点（基于传入的参数）；</li>
<li><strong>p</strong>(rint) - 在当前上下文对表达式求值并打印结果。还有一个命令是<strong>pp</strong> ，它使用 <a href="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a> 打印；</li>
<li><strong>r</strong>(eturn) - 继续执行直到当前函数返回；</li>
<li><strong>q</strong>(uit) - 退出调试器。</li>
</ul>
<p>让我们使用<code>pdb</code> 来修复下面的 Python 代码（参考讲座视频）</p>
<pre><code>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n):
            if arr[j] &gt; arr[j+1]:
                arr[j] = arr[j+1]
                arr[j+1] = arr[j]
    return arr

print(bubble_sort([4, 2, 1, 8, 7, 6]))
</code></pre>
<p>执行<code>python3 -m pdb bubble_sort.py</code>进入pdb调试环境。</p>
<p>注意，因为 Python 是一种解释型语言，所以我们可以通过 <code>pdb</code> shell 执行命令。 <a href="https://pypi.org/project/ipdb/"><code>ipdb</code></a> 是一种增强型的 <code>pdb</code> ，它使用<a href="https://ipython.org/"><code>IPython</code></a> 作为 REPL并开启了 tab 补全、语法高亮、更好的回溯和更好的内省，同时还保留了<code>pdb</code> 模块相同的接口。</p>
<p>对于更底层的编程语言，您可能需要了解一下 <a href="https://www.gnu.org/software/gdb/"><code>gdb</code></a> ( 以及它的改进版 <a href="https://github.com/pwndbg/pwndbg"><code>pwndbg</code></a>) 和 <a href="https://lldb.llvm.org/"><code>lldb</code></a>。</p>
<p>它们都对类 C 语言的调试进行了优化，它允许您探索任意进程及其机器状态：寄存器、堆栈、程序计数器等。</p>
<h2 id="专门工具"><a class="header" href="#专门工具">专门工具</a></h2>
<p>即使您需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到您。当您的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用 <a href="https://en.wikipedia.org/wiki/System_call">系统调用</a>。有一些命令可以帮助您追踪您的程序执行的系统调用。在 Linux 中可以使用<a href="http://man7.org/linux/man-pages/man1/strace.1.html"><code>strace</code></a> ，在 macOS 和 BSD 中可以使用 <a href="http://dtrace.org/blogs/about/"><code>dtrace</code></a>。<code>dtrace</code> 用起来可能有些别扭，因为它使用的是它自有的 <code>D</code> 语言，但是我们可以使用一个叫做 <a href="https://www.manpagez.com/man/1/dtruss/"><code>dtruss</code></a> 的封装使其具有和 <code>strace</code> (更多信息参考 <a href="https://8thlight.com/blog/colin-jones/2015/11/06/dtrace-even-better-than-strace-for-osx.html">这里</a>)类似的接口</p>
<p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code> 来显示<code>ls</code> 执行时，对<a href="http://man7.org/linux/man-pages/man2/stat.2.html"><code>stat</code></a> 系统调用进行追踪对结果。若需要深入了解 <code>strace</code>，<a href="https://blogs.oracle.com/linux/strace-the-sysadmins-microscope-v2">这篇文章</a> 值得一读。</p>
<pre><code># On Linux
sudo strace -e lstat ls -l &gt; /dev/null
4
# On macOS
sudo dtruss -t lstat64_extended ls -l &gt; /dev/null
</code></pre>
<p>有些情况下，我们需要查看网络数据包才能定位问题。像 <a href="http://man7.org/linux/man-pages/man1/tcpdump.1.html"><code>tcpdump</code></a> 和 <a href="https://www.wireshark.org/">Wireshark</a> 这样的网络数据包分析工具可以帮助您获取网络数据包的内容并基于不同的条件进行过滤。</p>
<p>对于 web 开发， Chrome/Firefox 的开发者工具非常方便，功能也很强大：</p>
<ul>
<li>源码 -查看任意站点的 HTML/CSS/JS 源码；</li>
<li>实时地修改 HTML, CSS, JS 代码 - 修改网站的内容、样式和行为用于测试（从这一点您也能看出来，网页截图是不可靠的）；</li>
<li>Javascript shell - 在 JS REPL中执行命令；</li>
<li>网络 - 分析请求的时间线；</li>
<li>存储 - 查看 Cookies 和本地应用存储。</li>
</ul>
<h2 id="静态分析"><a class="header" href="#静态分析">静态分析</a></h2>
<p>有些问题是您不需要执行代码就能发现的。例如，仔细观察一段代码，您就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。 这种情况下 <a href="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a> 工具就可以帮我们找到问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</p>
<p>下面这段 Python 代码中存在几个问题。 首先，我们的循环变量<code>foo</code> 覆盖了之前定义的函数<code>foo</code>。最后一行，我们还把 <code>bar</code> 错写成了<code>baz</code>，因此当程序完成<code>sleep</code> (一分钟)后，执行到这一行的时候便会崩溃。</p>
<pre><code>import time

def foo():
    return 42

for foo in range(5):
    print(foo)
bar = 1
bar *= 0.2
time.sleep(60)
print(baz)
</code></pre>
<p>静态分析工具可以发现此类的问题。当我们使用<a href="https://pypi.org/project/pyflakes"><code>pyflakes</code></a> 分析代码的时候，我们会得到与这两处 bug 相关的错误信息。<a href="http://mypy-lang.org/"><code>mypy</code></a> 则是另外一个工具，它可以对代码进行类型检查。这里，<code>mypy</code> 会经过我们<code>bar</code> 起初是一个 <code>int</code> ，然后变成了 <code>float</code>。这些问题都可以在不运行代码的情况下被发现。</p>
<p>安装pip命令：<code>sudo apt install python3-pip</code></p>
<p>安装pyflakes命令：<code>pip3 install pyflakes</code></p>
<pre><code>$ pyflakes foobar.py
foobar.py:6: redefinition of unused 'foo' from line 3
foobar.py:11: undefined name 'baz'

$ mypy foobar.py
foobar.py:6: error: Incompatible types in assignment (expression has type &quot;int&quot;, variable has type &quot;Callable[[], Any]&quot;)
foobar.py:9: error: Incompatible types in assignment (expression has type &quot;float&quot;, variable has type &quot;int&quot;)
foobar.py:11: error: Name 'baz' is not defined
Found 3 errors in 1 file (checked 1 source file)
</code></pre>
<p>在 shell 工具那一节课的时候，我们介绍了 <a href="https://www.shellcheck.net/"><code>shellcheck</code></a>，这是一个类似的工具，但它是应用于 shell 脚本的。</p>
<p>大多数的编辑器和 IDE 都支持在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置。 这个过程通常称为 <strong>code linting</strong> 。风格检查或安全检查的结果同样也可以进行相应的显示。</p>
<p>在 vim 中，有 <a href="https://vimawesome.com/plugin/ale"><code>ale</code></a> 或 <a href="https://vimawesome.com/plugin/syntastic"><code>syntastic</code></a> 可以帮助您做同样的事情。 在 Python 中， <a href="https://www.pylint.org/"><code>pylint</code></a> 和 <a href="https://pypi.org/project/pep8/"><code>pep8</code></a> 是两种用于进行风格检查的工具，而 <a href="https://pypi.org/project/bandit/"><code>bandit</code></a> 工具则用于检查安全相关的问题。</p>
<p>对于其他语言的开发者来说，静态分析工具可以参考这个列表：<a href="https://github.com/mre/awesome-static-analysis">Awesome Static Analysis</a> (您也许会对 <em>Writing</em> 一节感兴趣) 。对于 linters 则可以参考这个列表： <a href="https://github.com/caramelomartins/awesome-linters">Awesome Linters</a>。</p>
<p>对于风格检查和代码格式化，还有以下一些工具可以作为补充：用于 Python 的 <a href="https://github.com/psf/black"><code>black</code></a>、用于 Go 语言的 <code>gofmt</code>、用于 Rust 的 <code>rustfmt</code> 或是用于 JavaScript, HTML 和 CSS 的 <a href="https://prettier.io/"><code>prettier</code></a> 。这些工具可以自动格式化您的代码，这样代码风格就可以与常见的风格保持一致。 尽管您可能并不想对代码进行风格控制，标准的代码风格有助于方便别人阅读您的代码，也可以方便您阅读它的代码。</p>
<h1 id="性能分析"><a class="header" href="#性能分析">性能分析</a></h1>
<p>即使您的代码能够像您期望的一样运行，但是如果它消耗了您全部的 CPU 和内存，那么它显然也不是个好程序。算法课上我们通常会介绍大O标记法，但却没教给我们如何找到程序中的热点。 鉴于 <a href="http://wiki.c2.com/?PrematureOptimization">过早的优化是万恶之源</a>，您需要学习性能分析和监控工具，它们会帮助您找到程序中最耗时、最耗资源的部分，这样您就可以有针对性的进行性能优化。</p>
<h2 id="计时"><a class="header" href="#计时">计时</a></h2>
<p>和调试代码类似，大多数情况下我们只需要打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了 Python 的 <a href="https://docs.python.org/3/library/time.html"><code>time</code></a>模块。</p>
<pre><code>import time, random
n = random.randint(1, 10) * 100

# 获取当前时间 
start = time.time()

# 执行一些操作
print(&quot;Sleeping for {} ms&quot;.format(n))
time.sleep(n/1000)

# 比较当前时间和起始时间
print(time.time() - start)

# Output
# Sleeping for 500 ms
# 0.5713930130004883
</code></pre>
<p>不过，执行时间（wall clock time）也可能会误导您，因为您的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。 对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间+系统时间代表了您的进程所消耗的实际 CPU （更详细的解释可以参照<a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">这篇文章</a>）。</p>
<ul>
<li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O或网络）；</li>
<li><em>User</em> - CPU 执行用户代码所花费的时间；</li>
<li><em>Sys</em> - CPU 执行系统内核代码所花费的时间。</li>
</ul>
<p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加 <a href="http://man7.org/linux/man-pages/man1/time.1.html"><code>time</code></a> 前缀。网络不好的情况下您可能会看到下面的输出结果。请求花费了 2s 才完成，但是进程仅花费了 15ms 的 CPU 用户时间和 12ms 的 CPU 内核时间。</p>
<pre><code>$ time curl https://missing.csail.mit.edu &amp;&gt; /dev/null
real    0m2.561s
user    0m0.015s
sys     0m0.012s
</code></pre>
<h2 id="性能分析工具profilers"><a class="header" href="#性能分析工具profilers">性能分析工具（profilers）</a></h2>
<h3 id="cpu"><a class="header" href="#cpu">CPU</a></h3>
<p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU 性能分析工具。 CPU 性能分析工具有两种： 追踪分析器（<em>tracing</em>）及采样分析器（<em>sampling</em>）。 追踪分析器 会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果您希望了解更多相关信息，可以参考<a href="https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-">这篇</a> 介绍性的文章。</p>
<p>大多数的编程语言都有一些基于命令行的分析器，我们可以使用它们来分析代码。它们通常可以集成在 IDE 中，但是本节课我们会专注于这些命令行工具本身。</p>
<p>在 Python 中，我们使用 <code>cProfile</code> 模块来分析每次函数调用所消耗的时间。 在下面的例子中，我们实现了一个基础的 grep 命令：</p>
<pre><code>#!/usr/bin/env python

import sys, re

def grep(pattern, file):
    with open(file, 'r') as f:
        print(file)
        for i, line in enumerate(f.readlines()):
            pattern = re.compile(pattern)
            match = pattern.search(line)
            if match is not None:
                print(&quot;{}: {}&quot;.format(i, line), end=&quot;&quot;)

if __name__ == '__main__':
    times = int(sys.argv[1])
    pattern = sys.argv[2]
    for i in range(times):
        for file in sys.argv[3:]:
            grep(pattern, file)
</code></pre>
<p>我们可以使用下面的命令来对这段代码进行分析。通过它的输出我们可以知道，IO 消耗了大量的时间，编译正则表达式也比较耗费时间。因为正则表达式只需要编译一次，我们可以将其移动到 for 循环外面来改进性能。</p>
<pre><code>$ python -m cProfile -s tottime grep.py 1000 '^(import|\s*def)[^,]*$' *.py

[omitted program output]

 ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8000    0.266    0.000    0.292    0.000 {built-in method io.open}
   8000    0.153    0.000    0.894    0.000 grep.py:5(grep)
  17000    0.101    0.000    0.101    0.000 {built-in method builtins.print}
   8000    0.100    0.000    0.129    0.000 {method 'readlines' of '_io._IOBase' objects}
  93000    0.097    0.000    0.111    0.000 re.py:286(_compile)
  93000    0.069    0.000    0.069    0.000 {method 'search' of '_sre.SRE_Pattern' objects}
  93000    0.030    0.000    0.141    0.000 re.py:231(compile)
  17000    0.019    0.000    0.029    0.000 codecs.py:318(decode)
      1    0.017    0.017    0.911    0.911 grep.py:3(&lt;module&gt;)

[omitted lines]
</code></pre>
<p>关于 Python 的 <code>cProfile</code> 分析器（以及其他一些类似的分析器），需要注意的是它显示的是每次函数调用的时间。看上去可能快到反直觉，尤其是如果您在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用。</p>
<p>更加符合直觉的显示分析信息的方式是包括每行代码的执行时间，这也是_行分析器_的工作。例如，下面这段 Python 代码会向本课程的网站发起一个请求，然后解析响应返回的页面中的全部 URL：</p>
<pre><code>#!/usr/bin/env python
import requests
from bs4 import BeautifulSoup

# 这个装饰器会告诉行分析器 
# 我们想要分析这个函数
@profile
def get_urls():
    response = requests.get('https://missing.csail.mit.edu')
    s = BeautifulSoup(response.content, 'lxml')
    urls = []
    for url in s.find_all('a'):
        urls.append(url['href'])

if __name__ == '__main__':
    get_urls()
</code></pre>
<p>如果我们使用 Python 的 <code>cProfile</code> 分析器，我们会得到超过2500行的输出结果，即使对其进行排序，我仍然搞不懂时间到底都花在哪了。如果我们使用 <a href="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a>，它会基于行来显示时间：</p>
<pre><code>$ kernprof -l -v a.py
Wrote profile results to urls.py.lprof
Timer unit: 1e-06 s

Total time: 0.636188 s
File: a.py
Function: get_urls at line 5

Line #  Hits         Time  Per Hit   % Time  Line Contents
==============================================================
 5                                           @profile
 6                                           def get_urls():
 7         1     613909.0 613909.0     96.5      response = requests.get('https://missing.csail.mit.edu')
 8         1      21559.0  21559.0      3.4      s = BeautifulSoup(response.content, 'lxml')
 9         1          2.0      2.0      0.0      urls = []
10        25        685.0     27.4      0.1      for url in s.find_all('a'):
11        24         33.0      1.4      0.0          urls.append(url['href'])
</code></pre>
<h3 id="内存"><a class="header" href="#内存">内存</a></h3>
<p>像 C 或者 C++ 这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。为了应对内存类的 Bug，我们可以使用类似 <a href="https://valgrind.org/">Valgrind</a> 这样的工具来检查内存泄漏问题。</p>
<p>对于 Python 这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。</p>
<p>下面这个例子及其输出，展示了 <a href="https://pypi.org/project/memory-profiler/">memory-profiler</a> 是如何工作的（注意装饰器和 <code>line-profiler</code> 类似）。</p>
<pre><code>@profile
def my_func():
    a = [1] * (10 ** 6)
    b = [2] * (2 * 10 ** 7)
    del b
    return a

if __name__ == '__main__':
    my_func()
</code></pre>
<pre><code>$ python -m memory_profiler example.py
Line #    Mem usage  Increment   Line Contents
==============================================
     3                           @profile
     4      5.97 MB    0.00 MB   def my_func():
     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)
     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)
     7     13.61 MB -152.59 MB       del b
     8     13.61 MB    0.00 MB       return a
</code></pre>
<h3 id="事件分析"><a class="header" href="#事件分析">事件分析</a></h3>
<p>在我们使用<code>strace</code>调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介：</p>
<ul>
<li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li>
<li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li>
<li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li>
<li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li>
</ul>
<h3 id="可视化"><a class="header" href="#可视化">可视化</a></h3>
<p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p>
<p>对于采样分析器来说，常见的显示 CPU 分析数据的形式是 <a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，火焰图会在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例。火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪（您可以尝试点击下面的图片）。</p>
<p><a href="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg"><img src="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg" alt="FlameGraph" /></a></p>
<p>调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。 在 Python 中您可以使用 <a href="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a> 来生成这些图片。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/2/2f/A_Call_Graph_generated_by_pycallgraph.png" alt="Call Graph" /></p>
<h2 id="资源监控"><a class="header" href="#资源监控">资源监控</a></h2>
<p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p>
<ul>
<li><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a>,了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a>的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。 还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等；</li>
<li><strong>I/O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li>
<li><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li>
<li><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</li>
<li><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li>
<li><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</li>
<li><strong>网络使用</strong> - <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对网络占用进行监控的交互式命令行工具。</li>
</ul>
<p>如果您希望测试一下这些工具，您可以使用 <a href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p>
<h3 id="专用工具"><a class="header" href="#专用工具">专用工具</a></h3>
<p>有时候，您只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。 类似 <a href="https://github.com/sharkdp/hyperfine"><code>hyperfine</code></a> 这样的命令行可以帮您快速进行基准测试。例如，我们在 shell 工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替 <code>find</code>。我们这里可以用<code>hyperfine</code>来比较一下它们。</p>
<p>例如，下面的例子中，我们可以看到<code>fd</code> 比 <code>find</code> 要快20倍。</p>
<pre><code>$ hyperfine --warmup 3 'fd -e jpg' 'find . -iname &quot;*.jpg&quot;'
Benchmark #1: fd -e jpg
  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]
  Range (min … max):    44.2 ms …  60.1 ms    56 runs

Benchmark #2: find . -iname &quot;*.jpg&quot;
  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]
  Range (min … max):    0.975 s …  1.287 s    10 runs

Summary
  'fd -e jpg' ran
   21.89 ± 2.33 times faster than 'find . -iname &quot;*.jpg&quot;'
</code></pre>
<p>和 debug 一样，浏览器也包含了很多不错的性能分析工具，可以用来分析页面加载，让我们可以搞清楚时间都消耗在什么地方（加载、渲染、脚本等等）。 更多关于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler">Firefox</a> 和 <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools">Chrome</a>的信息可以点击链接。</p>
<h1 id="课后练习-6"><a class="header" href="#课后练习-6">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//debugging-profiling-solution">习题解答</a></p>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<ol>
<li>
<p>使用 Linux 上的 <code>journalctl</code> 或 macOS 上的 <code>log show</code> 命令来获取最近一天中超级用户的登录信息及其所执行的指令。如果找不到相关信息，您可以执行一些无害的命令，例如<code>sudo ls</code> 然后再次查看。</p>
</li>
<li>
<p>学习 <a href="https://github.com/spiside/pdb-tutorial">这份</a> <code>pdb</code> 实践教程并熟悉相关的命令。更深入的信息您可以参考<a href="https://realpython.com/python-debugging-pdb">这份</a>教程。</p>
</li>
<li>
<p>安装 <a href="https://www.shellcheck.net/"><code>shellcheck</code></a> 并尝试对下面的脚本进行检查。这段代码有什么问题吗？请修复相关问题。在您的编辑器中安装一个linter插件，这样它就可以自动地显示相关警告信息。</p>
<pre><code>#!/bin/sh
## Example: a typical script with several problems
for f in $(ls *.m3u)
do
  grep -qi hq.*mp3 $f \
    &amp;&amp; echo -e 'Playlist $f contains a HQ file in mp3 format'
done
</code></pre>
</li>
<li>
<p>(进阶题) 请阅读 <a href="https://undo.io/resources/reverse-debugging-whitepaper/">可逆调试</a> 并尝试创建一个可以工作的例子（使用 <a href="https://rr-project.org/"><code>rr</code></a> 或 <a href="https://morepypy.blogspot.com/2016/07/reverse-debugging-for-python.html"><code>RevPDB</code></a>）。</p>
</li>
</ol>
<h2 id="性能分析-1"><a class="header" href="#性能分析-1">性能分析</a></h2>
<ol>
<li>
<p><a href="https://missing-semester-cn.github.io/static/files/sorts.py">这里</a> 有一些排序算法的实现。请使用 <a href="https://docs.python.org/3/library/profile.html"><code>cProfile</code></a> 和 <a href="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a> 来比较插入排序和快速排序的性能。两种算法的瓶颈分别在哪里？然后使用 <code>memory_profiler</code> 来检查内存消耗，为什么插入排序更好一些？然后再看看原地排序版本的快排。附加题：使用 <code>perf</code> 来查看不同算法的循环次数及缓存命中及丢失情况。</p>
</li>
<li>
<p>这里有一些用于计算斐波那契数列 Python 代码，它为计算每个数字都定义了一个函数：</p>
<pre><code>#!/usr/bin/env python
def fib0(): return 0

def fib1(): return 1

s = &quot;&quot;&quot;def fib{}(): return fib{}() + fib{}()&quot;&quot;&quot;

if __name__ == '__main__':

    for n in range(2, 10):
        exec(s.format(n, n-1, n-2))
    # from functools import lru_cache
    # for n in range(10):
    #     exec(&quot;fib{} = lru_cache(1)(fib{})&quot;.format(n, n))
    print(eval(&quot;fib9()&quot;))
</code></pre>
<p>将代码拷贝到文件中使其变为一个可执行的程序。首先安装 <a href="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a>和<a href="http://graphviz.org/"><code>graphviz</code></a>(如果您能够执行<code>dot</code>, 则说明已经安装了 GraphViz.)。并使用 <code>pycallgraph graphviz -- ./fib.py</code> 来执行代码并查看<code>pycallgraph.png</code> 这个文件。<code>fib0</code> 被调用了多少次？我们可以通过记忆法来对其进行优化。将注释掉的部分放开，然后重新生成图片。这回每个<code>fibN</code> 函数被调用了多少次？</p>
</li>
<li>
<p>我们经常会遇到的情况是某个我们希望去监听的端口已经被其他进程占用了。让我们通过进程的PID查找相应的进程。首先执行 <code>python -m http.server 4444</code> 启动一个最简单的 web 服务器来监听 <code>4444</code> 端口。在另外一个终端中，执行 <code>lsof | grep LISTEN</code> 打印出所有监听端口的进程及相应的端口。找到对应的 PID 然后使用 <code>kill &lt;PID&gt;</code> 停止该进程。</p>
</li>
<li>
<p>限制进程资源也是一个非常有用的技术。执行 <code>stress -c 3</code> 并使用<code>htop</code> 对 CPU 消耗进行可视化。现在，执行<code>taskset --cpu-list 0,2 stress -c 3</code> 并可视化。<code>stress</code> 占用了3个 CPU 吗？为什么没有？阅读<a href="http://man7.org/linux/man-pages/man1/taskset.1.html"><code>man taskset</code></a>来寻找答案。附加题：使用 <a href="http://man7.org/linux/man-pages/man7/cgroups.7.html"><code>cgroups</code></a>来实现相同的操作，限制<code>stress -m</code>的内存使用。</p>
</li>
<li>
<p>(进阶题) <code>curl ipinfo.io</code> 命令或执行 HTTP 请求并获取关于您 IP 的信息。打开 <a href="https://www.wireshark.org/">Wireshark</a> 并抓取 <code>curl</code> 发起的请求和收到的回复报文。（提示：可以使用<code>http</code>进行过滤，只显示 HTTP 报文）</p>
</li>
</ol>
<h1 id="solution-调试与性能分析"><a class="header" href="#solution-调试与性能分析">Solution-调试与性能分析</a></h1>
<h2 id="1-调试"><a class="header" href="#1-调试">1. 调试</a></h2>
<ol>
<li>
<p>使用 Linux 上的 <code>journalctl</code> 或 macOS 上的 <code>log show</code> 命令来获取最近一天中超级用户的登录信息及其所执行的指令。如果找不到相关信息，您可以执行一些无害的命令，例如<code>sudo ls</code> 然后再次查看。 这里我在树莓派上查询相关日志</p>
<pre><code> pi@raspberrypi:~$ journalctl | grep sudo
 pi@raspberrypi:~$ sudo ls
 Bookshelf  myconfig  project  proxy
 pi@raspberrypi:~$ journalctl | grep sudo
 May 16 03:06:04 raspberrypi sudo[799]:       pi : TTY=pts/0 ; PWD=/home/pi ; USER=root ; COMMAND=/usr/bin/ls
 May 16 03:06:04 raspberrypi sudo[799]: pam_unix(sudo:session): session opened for user root by pi(uid=0)
 May 16 03:06:04 raspberrypi sudo[799]: pam_unix(sudo:session): session closed for user root
 pi@raspberrypi:~$
</code></pre>
<p>在 Mac 上面使用下面的命令</p>
<pre><code> log show --last 1h | grep sudo
</code></pre>
</li>
<li>
<p>学习 <a href="https://github.com/spiside/pdb-tutorial">这份</a> <code>pdb</code> 实践教程并熟悉相关的命令。更深入的信息您可以参考<a href="https://realpython.com/python-debugging-pdb">这份</a>教程。</p>
</li>
<li>
<p>安装 <a href="https://www.shellcheck.net/"><code>shellcheck</code></a> 并尝试对下面的脚本进行检查。这段代码有什么问题吗？请修复相关问题。在您的编辑器中安装一个linter插件，这样它就可以自动地显示相关警告信息。</p>
<pre><code>#!/bin/sh
## Example: a typical script with several problems
for f in $(ls *.m3u)
do
  grep -qi hq.*mp3 $f \
    &amp;&amp; echo -e 'Playlist $f contains a HQ file in mp3 format'
done
</code></pre>
<p>在 Vim 中可以通过<a href="https://github.com/neomake/neomake">neomake</a>插件来集成 shellcheck，在<code>~/.vimrc</code>中添加 <code>Plug 'neomake/neomake'</code></p>
<pre><code> call plug#begin()
 Plug 'neomake/neomake'
 call plug#end()
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/1.png" alt="1.png" />然后在 vim 执行<code>:PlugInstall</code>安装插件<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/2.png" alt="1.png" />在需要检查的 shell 脚本中，执行<code>:Neomake</code> 即可进行 shellcheck 检查。然后光标移动到对应行时可以看到告警或错误。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/3.png" alt="1.png" /></p>
</li>
<li>
<p>(进阶题) 请阅读 <a href="https://undo.io/resources/reverse-debugging-whitepaper/">可逆调试</a> 并尝试创建一个可以工作的例子（使用 <a href="https://rr-project.org/"><code>rr</code></a> 或 <a href="https://morepypy.blogspot.com/2016/07/reverse-debugging-for-python.html"><code>RevPDB</code></a>）。</p>
<p>此例主要参考了<a href="https://developers.redhat.com/blog/2021/05/03/instant-replay-debugging-c-and-c-programs-with-rr#requirements_and_setup">debug-c-and-c++-programs-with-rr</a>，使用的代码是<a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/demoCode/7/demo.c">demo.c</a></p>
<pre><code> # perf内置在linux-tools中，使用rr需要先安装perf
 ~/debug $ sudo apt install linux-tools-common linux-tools-generic linux-tools-`uname -r`
 ~/debug $ sudo apt install rr
 ~/debug $ echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid
 ~/debug $ gcc -g demo.c -o demo
 ~/debug $ ./demo
 f(0)=0
 f(1)=0
 f(2)=0
 f(3)=0
 # 预期输出结果为[0, 2, 4, 6]
</code></pre>
<pre><code> # -n选项：输出./demo的运行结果
 ~/debug $ sudo rr record -n ./demo
 rr: Saving execution to trace directory `/root/.local/share/rr/deom-1'.
 f(0)=0
 f(1)=0
 f(2)=0
 f(3)=0

 # 进入rr-debugger中调试代码
 ~/debug $ sudo rr replay
</code></pre>
<ul>
<li>在demo.c中，print_array只是打印出stru.a数组的内容，所以出错的地方应该在打印之前，即可能是multiply函数的调用，在此设置断点。</li>
</ul>
<pre><code> (rr) b multiply # break简写为b
 Breakpoint 1 at 0x5568214c818c: file demorr.c, line 16.
 (rr) c  # continue简写为c
 Continuing.

 Breakpoint 1, multiply (a=0x5568214cb018 &lt;stru&gt; &quot;&quot;, size=4, num=0) at demorr.c:16
 16              for (i=0; i&lt;size; i++)
</code></pre>
<ul>
<li>注意到multiply中传入num的值为 0,正常应该是stru.num的初始值 2，使用watch来查看stru.num的值什么时候被改变的。</li>
</ul>
<pre><code> (rr) watch -l stru.num
 Hardware watchpoint 2: -location stru.num
 # reverse-continue简写为rc,回退到watchpoint的值被更改的地方
 (rr) rc
 Continuing.

 Hardware watchpoint 2: -location stru.num
 # stru.num的值从 2 变为了 0（注意现在是使用rc反向调试）
 # stru.num的值的变更发生在initialize函数的调用中
 Old value = 0
 New value = 2
 initialize (a=0x5568214cb018 &lt;stru&gt; &quot;&quot;, size=3) at demorr.c:10
 10                      a[size--] = 0;
 (rr) q
</code></pre>
<ul>
<li>观察initialize函数中的语句，发现<code>size--</code>先返回<code>size</code>值，再执行<code>size=size-1</code>的操作。而且，由于结构体中变量的内存空间是连续的，所以执行<code>a[SIZE]=0</code>时，把<code>stru.num</code>的值置为了 0。为此，将<code>a[size--]=0</code>修改为<code>a[--size]=0</code>，再观察输出结果。</li>
</ul>
<pre><code> ~/debug $ vim demo.c
 ~/debug $ gcc -g demo.c -o demo
 ~/debug $ ./demo
 f(0)=0
 f(1)=2
 f(2)=4
 f(3)=6
</code></pre>
</li>
</ol>
<h2 id="2-性能分析"><a class="header" href="#2-性能分析">2. 性能分析</a></h2>
<ol>
<li>
<p><a href="https://missing-semester-cn.github.io/static/files/sorts.py">这里</a> 有一些排序算法的实现。请使用 <a href="https://docs.python.org/3/library/profile.html"><code>cProfile</code></a> 和 <a href="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a> 来比较插入排序和快速排序的性能。两种算法的瓶颈分别在哪里？然后使用 <code>memory_profiler</code> 来检查内存消耗，为什么插入排序更好一些？然后再看看原地排序版本的快排。附加题：使用 <code>perf</code> 来查看不同算法的循环次数及缓存命中及丢失情况。</p>
<pre><code> python -m cProfile -s time sorts.py #按照执行时间排序
</code></pre>
<pre><code> python -m cProfile -s time sorts.py | grep sorts.py
 33748/1000    0.066    0.000    0.069    0.000 sorts.py:23(quicksort)
 34356/1000    0.045    0.000    0.055    0.000 sorts.py:32(quicksort_inplace)
         3    0.037    0.012    0.347    0.116 sorts.py:4(test_sorted)
     1000    0.031    0.000    0.032    0.000 sorts.py:11(insertionsort)
         1    0.007    0.007    0.385    0.385 sorts.py:1(&lt;module&gt;)
</code></pre>
<p>使用 <code>line_profiler</code>进行分析，需要安装：</p>
<pre><code> pip install line_profiler
</code></pre>
<p>然后为需要分析的函数添加装饰器 <code>@profile</code>，并执行：</p>
<pre><code> kernprof -l -v sorts.py
</code></pre>
<p>首先对快速排序进行分析：</p>
<pre><code> Wrote profile results to sorts.py.lprof
 Timer unit: 1e-06 s

 Total time: 0.490021 s
 File: sorts.py
 Function: quicksort at line 22

 Line #      Hits         Time  Per Hit   % Time  Line Contents
 ==============================================================
     22                                           @profile
     23                                           def quicksort(array):
     24     32594      91770.0      2.8     18.7      if len(array) &lt;= 1:
     25     16797      36674.0      2.2      7.5          return array
     26     15797      37626.0      2.4      7.7      pivot = array[0]
     27     15797     125796.0      8.0     25.7      left = [i for i in array[1:] if i &lt; pivot]
     28     15797     119954.0      7.6     24.5      right = [i for i in array[1:] if i &gt;= pivot]
     29     15797      78201.0      5.0     16.0      return quicksort(left) + [pivot] + quicksort(right)
</code></pre>
<p>然后对插入排序进行分析：</p>
<pre><code> Total time: 1.33387 s
 File: sorts.py
 Function: insertionsort at line 11

 Line #      Hits         Time  Per Hit   % Time  Line Contents
 ==============================================================
     11                                           @profile
     12                                           def insertionsort(array):
     13
     14     26801      44242.0      1.7      3.3      for i in range(len(array)):
     15     25801      43372.0      1.7      3.3          j = i-1
     16     25801      41950.0      1.6      3.1          v = array[i]
     17    234763     434280.0      1.8     32.6          while j &gt;= 0 and v &lt; array[j]:
     18    208962     380062.0      1.8     28.5              array[j+1] = array[j]
     19    208962     343217.0      1.6     25.7              j -= 1
     20     25801      45248.0      1.8      3.4          array[j+1] = v
     21      1000       1503.0      1.5      0.1      return array
</code></pre>
<p>插入排序的耗时更高一些。快速排序的瓶颈在于 <code>left</code>和 <code>right</code>的赋值，而插入排序的瓶颈在<code>while</code>循环。<br />
使用 <code>memory_profiler</code>进行分析，需要安装：</p>
<pre><code> pip install memory_profiler
</code></pre>
<p>同样需要添加<code>@profile</code> 装饰器。 首先分析快速排序的内存使用情况：</p>
<pre><code> pi@raspberrypi:~$ python -m memory_profiler sorts.py
 Filename: sorts.py

 Line #    Mem usage    Increment  Occurences   Line Contents
 ============================================================
     22   20.199 MiB   20.199 MiB       32800   @profile
     23                                         def quicksort(array):
     24   20.199 MiB    0.000 MiB       32800       if len(array) &lt;= 1:
     25   20.199 MiB    0.000 MiB       16900           return array
     26   20.199 MiB    0.000 MiB       15900       pivot = array[0]
     27   20.199 MiB    0.000 MiB      152906       left = [i for i in array[1:] if i &lt; pivot]
     28   20.199 MiB    0.000 MiB      152906       right = [i for i in array[1:] if i &gt;= pivot]
     29   20.199 MiB    0.000 MiB       15900       return quicksort(left) + [pivot] + quicksort(right)
</code></pre>
<p>然后分析插入排序的内存使用情况：</p>
<pre><code> pi@raspberrypi:~$ python -m memory_profiler sorts.py

 Filename: sorts.py

 Line #    Mem usage    Increment  Occurences   Line Contents
 ============================================================
     11   20.234 MiB   20.234 MiB        1000   @profile
     12                                         def insertionsort(array):
     13
     14   20.234 MiB    0.000 MiB       26638       for i in range(len(array)):
     15   20.234 MiB    0.000 MiB       25638           j = i-1
     16   20.234 MiB    0.000 MiB       25638           v = array[i]
     17   20.234 MiB    0.000 MiB      237880           while j &gt;= 0 and v &lt; array[j]:
     18   20.234 MiB    0.000 MiB      212242               array[j+1] = array[j]
     19   20.234 MiB    0.000 MiB      212242               j -= 1
     20   20.234 MiB    0.000 MiB       25638           array[j+1] = v
     21   20.234 MiB    0.000 MiB        1000       return array
</code></pre>
<p>同时对比原地操作的快速排序算法内存情况：</p>
<pre><code> pi@raspberrypi:~$ python -m memory_profiler sorts.py
 Filename: sorts.py

 Line #    Mem usage    Increment  Occurences   Line Contents
 ============================================================
     31   20.121 MiB   20.121 MiB       33528   @profile
     32                                         def quicksort_inplace(array, low=0, high=None):
     33   20.121 MiB    0.000 MiB       33528       if len(array) &lt;= 1:
     34   20.121 MiB    0.000 MiB          42           return array
     35   20.121 MiB    0.000 MiB       33486       if high is None:
     36   20.121 MiB    0.000 MiB         958           high = len(array)-1
     37   20.121 MiB    0.000 MiB       33486       if low &gt;= high:
     38   20.121 MiB    0.000 MiB       17222           return array
     39
     40   20.121 MiB    0.000 MiB       16264       pivot = array[high]
     41   20.121 MiB    0.000 MiB       16264       j = low-1
     42   20.121 MiB    0.000 MiB      124456       for i in range(low, high):
     43   20.121 MiB    0.000 MiB      108192           if array[i] &lt;= pivot:
     44   20.121 MiB    0.000 MiB       55938               j += 1
     45   20.121 MiB    0.000 MiB       55938               array[i], array[j] = array[j], array[i]
     46   20.121 MiB    0.000 MiB       16264       array[high], array[j+1] = array[j+1], array[high]
     47   20.121 MiB    0.000 MiB       16264       quicksort_inplace(array, low, j)
     48   20.121 MiB    0.000 MiB       16264       quicksort_inplace(array, j+2, high)
     49   20.121 MiB    0.000 MiB       16264       return array
</code></pre>
<ul>
<li>遗憾的是，按照上面的方法使用<code>memory_profiler</code>给出的结果无法作为这三种排序算法内存消耗对比的依据（从我自己运行的结果来看，insertionsort的43.301MiB甚至还大于quicksort的43.195MiB，与预期结果相反!!）</li>
<li>另外，观察三组结果中，函数的每一行的<code>Increment</code>（即执行该行所导致的内存占用的增减变化）均为 0！这是由于test_sorted用于测试的list太小了，长度仅为1～50，导致排序算法中每一行创建的变量内存占用也很小。如果直接使用一个长度为2000的list来测试：<code>l = [random.randint(0,10000) for i in range(0, 2000)]</code>，会发现quicksort函数的<code>Left</code>或<code>Right</code>行的<code>Increment</code>数据不为 0（创建的list占用内存较大了）。与此同时，用该list测试insertionsort函数时，发现耗用时间较长。</li>
<li>参考<a href="https://alexisalulema.com/2022/08/07/python-profiling-memory-profiling-part-3-final/">python-profiling-memory-profiling</a>这篇文章，使用一个长度为 10 000的list测试冒泡排序的内存消耗，需要将近30分钟才输出结果。（使用memory_profiler要权衡时间与效率）</li>
</ul>
<p>使用perf检查每个算法的循环次数、缓存命中和丢失：</p>
<ul>
<li>insertionsort的结果</li>
</ul>
<pre><code> ~/debug $ vim sorts.py
 # 修改main函数删除for循环，改为：test_sorted(insertionsort)
 ~/debug $ sudo perf stat -e cycles,cache-references,cache-misses python3 sorts.py

 Performance counter stats for 'python3 sorts.py':

     187,253,954      cycles                                                  
         5,023,695      cache-references                                        
         891,768      cache-misses              #   17.751 % of all cache refs

     0.099464106 seconds time elapsed

     0.082930000 seconds user
     0.016586000 seconds sys
</code></pre>
<ul>
<li>quicksort的结果</li>
</ul>
<pre><code> ~/debug $ vim sorts.py
 # main函数的内容改为：test_sorted(quicksort)
 ~/debug $ sudo perf stat -e cycles,cache-references,cache-misses python3 sorts.py

 Performance counter stats for 'python3 sorts.py':

     192,741,421      cycles                                                  
         6,843,630      cache-references                                        
         898,594      cache-misses              #   13.130 % of all cache refs

     0.057831555 seconds time elapsed

     0.057863000 seconds user
     0.000000000 seconds sys
</code></pre>
<ul>
<li>quicksort_inplace的结果</li>
</ul>
<pre><code> ~/debug $ vim sorts.py
 # main函数改为：test_sorted(quicksort_inplace)
 ~/debug $ sudo perf stat -e cycles,cache-references,cache-misses python3 sorts.py

 Performance counter stats for 'python3 sorts.py':

     179,221,185      cycles                                                  
         5,700,092      cache-references                                        
         892,157      cache-misses              #   15.652 % of all cache refs

     0.097429528 seconds time elapsed

     0.089351000 seconds user
     0.008122000 seconds sys
</code></pre>
</li>
<li>
<p>这里有一些用于计算斐波那契数列 Python 代码，它为计算每个数字都定义了一个函数：</p>
<pre><code>#!/usr/bin/env python
def fib0(): return 0

def fib1(): return 1

s = &quot;&quot;&quot;def fib{}(): return fib{}() + fib{}()&quot;&quot;&quot;

if __name__ == '__main__':

    for n in range(2, 10):
        exec(s.format(n, n-1, n-2))
    # from functools import lru_cache
    # for n in range(10):
    #     exec(&quot;fib{} = lru_cache(1)(fib{})&quot;.format(n, n))
    print(eval(&quot;fib9()&quot;))
</code></pre>
<p>将代码拷贝到文件中使其变为一个可执行的程序。首先安装 <a href="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a>和<a href="http://graphviz.org/"><code>graphviz</code></a>(如果您能够执行<code>dot</code>, 则说明已经安装了 GraphViz.)。并使用 <code>pycallgraph graphviz -- ./fib.py</code> 来执行代码并查看<code>pycallgraph.png</code> 这个文件。<code>fib0</code> 被调用了多少次？我们可以通过记忆法来对其进行优化。将注释掉的部分放开，然后重新生成图片。这回每个<code>fibN</code> 函数被调用了多少次？</p>
<p>setuptools版本过高可能导致pycallgraph安装失败</p>
<pre><code>pip install &quot;setuptools&lt;58.0.0&quot;
pip install pycallgraph
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/4.png" alt="1.png" />放开注释内容后，再次执行：<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/5.png" alt="1.png" />注意：如果你是 Python 2.7的话，需要修改一下注释的内容:</p>
<pre><code>from backports.functools_lru_cache import lru_cache
</code></pre>
<p>不过生成的图片里面会包含很多不相关的内容。</p>
</li>
<li>
<p>我们经常会遇到的情况是某个我们希望去监听的端口已经被其他进程占用了。让我们通过进程的PID查找相应的进程。首先执行 <code>python -m http.server 4444</code> 启动一个最简单的 web 服务器来监听 <code>4444</code> 端口。在另外一个终端中，执行 <code>lsof | grep LISTEN</code> 打印出所有监听端口的进程及相应的端口。找到对应的 PID 然后使用 <code>kill &lt;PID&gt;</code> 停止该进程。<br />
<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/6.png" alt="1.png" /></p>
</li>
<li>
<p>限制进程资源也是一个非常有用的技术。执行 <code>stress -c 3</code> 并使用<code>htop</code> 对 CPU 消耗进行可视化。现在，执行<code>taskset --cpu-list 0,2 stress -c 3</code> 并可视化。<code>stress</code> 占用了3个 CPU 吗？为什么没有？阅读<a href="http://man7.org/linux/man-pages/man1/taskset.1.html"><code>man taskset</code></a>来寻找答案。附加题：使用 <a href="http://man7.org/linux/man-pages/man7/cgroups.7.html"><code>cgroups</code></a>来实现相同的操作，限制<code>stress -m</code>的内存使用。<br />
首先是设备正常运行状态下的资源占用情况：<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/7.png" alt="1.png" />创建负载：</p>
<pre><code> stress -c 3
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/8.png" alt="1.png" />限制资源消耗</p>
<pre><code> taskset --cpu-list 0,2 stress -c 3
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/9.png" alt="1.png" />taskset 命令可以将任务绑定到指定CPU核心。<br />
<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/10.png" alt="1.png" />接下来看<code>cgroups</code>是如何工作的，我参考了两篇文章：</p>
<ul>
<li><a href="https://tech.meituan.com/2015/03/31/cgroups.html">Linux资源管理之cgroups简介</a></li>
<li><a href="https://0xax.gitbooks.io/linux-insides/content/Cgroups/linux-cgroups-1.html">Linux-insidesControl Groups</a> ß</li>
</ul>
<p>首先我们看一下如何创建内存负载，这里创建 3 个 worker 来不停的申请释放 512M 内存：</p>
<pre><code> stress -m 3 --vm-bytes 512M
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/11.png" alt="1.png" />由于题目要求限制内存的使用，首先我们看一下内存设备是否已经挂载：</p>
<pre><code> root@raspberrypi:~# lssubsys -am
 memory
 cpuset /sys/fs/cgroup/cpuset
 cpu,cpuacct /sys/fs/cgroup/cpu,cpuacct
 blkio /sys/fs/cgroup/blkio
 devices /sys/fs/cgroup/devices
 freezer /sys/fs/cgroup/freezer
 net_cls,net_prio /sys/fs/cgroup/net_cls,net_prio
 perf_event /sys/fs/cgroup/perf_event
 pids /sys/fs/cgroup/pids
 root@raspberrypi:~#
</code></pre>
<p>内存没挂载的情况下，需要手动挂载：</p>
<pre><code> mount -t cgroup -o memory memory /sys/fs/cgroup/memory
</code></pre>
<p>我在树莓派上出现了不能挂载的情况，此时需要修改 <code>boot.cmdline.txt</code>，添加：</p>
<pre><code> cgroup_enable=memory  cgroup_memory=1 
</code></pre>
<p>然后重启，再次查看</p>
<pre><code> pi@raspberrypi:~$ lssubsys -am
 cpuset /sys/fs/cgroup/cpuset
 cpu,cpuacct /sys/fs/cgroup/cpu,cpuacct
 blkio /sys/fs/cgroup/blkio
 memory /sys/fs/cgroup/memory
 devices /sys/fs/cgroup/devices
 freezer /sys/fs/cgroup/freezer
 net_cls,net_prio /sys/fs/cgroup/net_cls,net_prio
 perf_event /sys/fs/cgroup/perf_event
 pids /sys/fs/cgroup/pids
 pi@raspberrypi:~$
</code></pre>
<p>已经挂载成功，然后创建组并写入规则（内存限制为128M）</p>
<pre><code> root@raspberrypi:/home/pi# cgcreate -g memory:cgroup_test_group
 root@raspberrypi:/home/pi# echo 128M &gt; /sys/fs/cgroup/memory/cgroup_test_group/memory.limit_in_bytes
</code></pre>
<p>然后在控制组中运行<code>stress</code>，创建 3 个 worker 申请 512M 内存：</p>
<pre><code> oot@raspberrypi:/home/pi# cgexec -g memory:cgroup_test_group stress -m 3 --vm-bytes 512M
 stress: info: [832] dispatching hogs: 0 cpu, 0 io, 3 vm, 0 hdd
 stress: FAIL: [832] (415) &lt;-- worker 833 got signal 9
 stress: WARN: [832] (417) now reaping child worker processes
 stress: FAIL: [832] (451) failed run completed in 5s
</code></pre>
<p>执行失败。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/12.png" alt="1.png" /><br />
如果是申请 1M 内存，则可以成功运行：</p>
<pre><code> cgexec -g memory:cgroup_test_group stress -m 3 --vm-bytes 1M
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/13.png" alt="1.png" /><br />
下面是使用cgroupV2限制stress命令内存的示例：</p>
<p>比较新版本的Ubuntu默认安装<code>cgroup v2</code>，可以参考<a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/linux/ubuntu_linux/cgroup/enable_cgroup_v2_ubuntu_20.04.html">Ubuntu激活cgroupv2</a>。下面，将使用cgroupv2实现限制进程内存消耗的操作，更多信息可参考<a href="https://zorrozou.github.io/docs/%E8%AF%A6%E8%A7%A3Cgroup%20V2.html">详解CgroupV2</a>。</p>
<p>设置，使用cgroup2</p>
<pre><code> ~ $ grep cgroup /proc/filesystems
 nodev   cgroup
 nodev   cgroup2
  # 输出结果有cgroup2,说明当前系统支持cgroup2
 ~ $ sudo vim /etc/default/grub
  # 查找变量GRUB_CMDLINE_LINUX_DEFAULT,将原来的行注释掉
  # 新增一行：GRUB_CMDLINE_LINUX_DEFAULT=&quot;systemd.unified_cgroup_hierarchy=1&quot;
 ~ $ sudo update-grub
 ~ $ reboot
</code></pre>
<p>重启后，检查：</p>
<pre><code> ~ $ cat /sys/fs/cgroup/cgroup.controllers
 cpuset cpu io memory hugetlb pids rdma misc
  # 这些是cgroup挂载的控制器
 ~ $ sudo su
 root@laihj:~# cd /sys/fs/cgroup
  # 该目录为cgroup的根root,在其下创建的子目录是其节点
 root@laihj:/sys/fs/cgroup# mkdir -p test test/cg
 root@laihj:/sys/fs/cgroup# ls test
 cg                     cgroup.type          memory.numa_stat
 cgroup.controllers      cpu.pressure         memory.oom.group
 cgroup.events           cpu.stat             memory.pressure
 cgroup.freeze           io.pressure          memory.stat
 cgroup.kill             memory.current       memory.swap.current
 cgroup.max.depth        memory.events        memory.swap.events
 cgroup.max.descendants  memory.events.local  memory.swap.high
 cgroup.procs            memory.high          memory.swap.max
 cgroup.stat             memory.low           pids.current
 cgroup.subtree_control  memory.max           pids.events
 cgroup.threads          memory.min           pids.max
 root@laihj:/sys/fs/cgroup# ls test/cg
 cgroup.controllers  cgroup.max.descendants  cgroup.type
 cgroup.events       cgroup.procs            cpu.pressure
 cgroup.freeze       cgroup.stat             cpu.stat
 cgroup.kill         cgroup.subtree_control  io.pressure
 cgroup.max.depth    cgroup.threads          memory.pressure
  # test节点挂载了memory控制器，所以目录下出现了&quot;memory.*&quot;文件
</code></pre>
<p>为test/cg挂载memory控制器，并设置memory的使用大小</p>
<pre><code> root@laihj:/sys/fs/cgroup# cd test
 root@laihj:/sys/fs/cgroup/test# cat cgroup.subtree_control
 root@laihj:/sys/fs/cgroup/test# echo &quot;+memory&quot; &gt; cgroup.subtree_control
 root@laihj:/sys/fs/cgroup/test# cat cgroup.subtree_control
 memory
 root@laihj:/sys/fs/cgroup/test# echo 100M &gt; memory.max
 root@laihj:/sys/fs/cgroup/test# echo 0 &gt; memory.swap.max
  # 设置memory的最大使用量为 100M,同时，必须限制内存交换空间的使用
</code></pre>
<p>将当前的<code>bash session pid</code>写入cg中，接下来在bash中执行的所有命令会受到刚才的memory设置的影响（注意，除了根，进程只能驻留在叶节点（没有子cgroup目录的cgroup目录<code>echo $$ &gt; test/cgroup.procs</code>会报错））</p>
<pre><code> root@laihj:/sys/fs/cgroup/test# echo $$ &gt; cg/cgroup.procs

 root@laihj:/sys/fs/cgroup/test# stress -m 3 --vm-bytes 200M
 stress: info: [5018] dispatching hogs: 0 cpu, 0 io, 3 vm, 0 hdd
 stress: FAIL: [5018] (416) &lt;-- worker 5020 got signal 9
 stress: WARN: [5018] (418) now reaping child worker processes
 stress: FAIL: [5018] (452) failed run completed in 0s

 root@laihj:/sys/fs/cgroup/test# stress -m 3 --vm-bytes 40M
  # 3 个 worker 各分配 40M,总的 120M,仍超过了设置的100M上限
 stress: info: [5030] dispatching hogs: 0 cpu, 0 io, 3 vm, 0 hdd
 stress: FAIL: [5030] (416) &lt;-- worker 5032 got signal 9
 stress: WARN: [5030] (418) now reaping child worker processes
 stress: FAIL: [5030] (452) failed run completed in 0s

 root@laihj:/sys/fs/cgroup/test# stress -m 3 --vm-bytes 20M
 stress: info: [5034] dispatching hogs: 0 cpu, 0 io, 3 vm, 0 hdd
 ^C
  # 正常执行，按下ctrl+C终止stress命令
</code></pre>
<p>删除cgroup下的节点，需要从叶节点开始（最内层的目录）</p>
<pre><code>  # 确保test/cg中的进程全部停止，这里需要退出当前bash session,即关闭终端，然后，重新开启
 ~ $ sudo rmdir /sys/fs/cgroup/test/cg
 ~ $ sudo rmdir /sys/fs/cgroup/test
</code></pre>
</li>
<li>
<p>(进阶题) <code>curl ipinfo.io</code> 命令或执行 HTTP 请求并获取关于您 IP 的信息。打开 <a href="https://www.wireshark.org/">Wireshark</a> 并抓取 <code>curl</code> 发起的请求和收到的回复报文。（提示：可以使用<code>http</code>进行过滤，只显示 HTTP 报文） 这里我使用的是<code>curl www.baidu.com</code>，请求百度的首页并过滤了除 HTTP 之外的其他报文：<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/14.png" alt="1.png" /><br />
<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/7/15.png" alt="1.png" /></p>
</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="metaprogramming"><a class="header" href="#metaprogramming">Metaprogramming</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="security-and-cryptography"><a class="header" href="#security-and-cryptography">Security and Cryptography</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="potpourri"><a class="header" href="#potpourri">Potpourri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="qa"><a class="header" href="#qa">Q&amp;A</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
