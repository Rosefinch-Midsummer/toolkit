<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Wrangling - Mdbook Template</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">开发工具</li><li class="chapter-item expanded "><a href="Shell工具和脚本.html"><strong aria-hidden="true">1.</strong> Shell Tools and Scripting</a></li><li class="chapter-item expanded "><a href="编辑器Vim.html"><strong aria-hidden="true">2.</strong> Editors (Vim)</a></li><li class="chapter-item expanded "><a href="数据整理.html" class="active"><strong aria-hidden="true">3.</strong> Data Wrangling</a></li><li class="chapter-item expanded "><a href="命令行环境.html"><strong aria-hidden="true">4.</strong> Command-line Environment</a></li><li class="chapter-item expanded "><a href="版本控制Git.html"><strong aria-hidden="true">5.</strong> Version Control (Git)</a></li><li class="chapter-item expanded "><a href="调试及性能分析.html"><strong aria-hidden="true">6.</strong> Debugging and Profiling</a></li><li class="chapter-item expanded "><a href="元编程.html"><strong aria-hidden="true">7.</strong> Metaprogramming</a></li><li class="chapter-item expanded "><a href="安全与密码学.html"><strong aria-hidden="true">8.</strong> Security and Cryptography</a></li><li class="chapter-item expanded affix "><li class="part-title">非开发实用工具</li><li class="chapter-item expanded "><a href="大杂烩.html"><strong aria-hidden="true">9.</strong> Potpourri</a></li><li class="chapter-item expanded "><a href="问答.html"><strong aria-hidden="true">10.</strong> Q&A</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mdbook Template</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="数据整理"><a class="header" href="#数据整理">数据整理</a></h1>
<p><a href="https://missing-semester-cn.github.io/2020/data-wrangling/">数据整理来源</a></p>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%E6%A6%82%E8%BF%B0">数据整理概述</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86">回到数据整理</a></li>
<li><a href="#awk--%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%BC%96%E8%BE%91%E5%99%A8">awk – 另外一种编辑器</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE">分析数据</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%E6%9D%A5%E7%A1%AE%E5%AE%9A%E5%8F%82%E6%95%B0">利用数据整理来确定参数</a></li>
<li><a href="#%E6%95%B4%E7%90%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE">整理二进制数据</a></li>
<li><a href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="#solution-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97">Solution-数据清洗</a></li>
</ul>
<h2 id="数据整理概述"><a class="header" href="#数据整理概述">数据整理概述</a></h2>
<p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！ 这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p>
<p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p>
<p>例如这样一条命令 <code>journalctl | grep -i intel</code>，它会找到所有包含intel(不区分大小写)的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p>
<p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p>
<pre><code class="language-bash">ssh myserver journalctl
</code></pre>
<p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p>
<pre><code class="language-bash">ssh myserver journalctl | grep sshd
</code></pre>
<p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 <code>grep</code> 程序！ <code>ssh</code> 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 <code>ssh</code> 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p>
<pre><code>ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' | less
</code></pre>
<p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 <code>less</code> 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p>
<pre><code>$ ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' &gt; ssh.log
$ less ssh.log
</code></pre>
<p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 <code>sed</code> 这个非常强大的工具。</p>
<p><code>sed</code> 是一个基于文本编辑器<code>ed</code>构建的”流编辑器” 。在 <code>sed</code> 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 <code>s</code>，即替换命令，例如我们可以这样写：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed 's/.*Disconnected from //'
</code></pre>
<p>上面这段命令中，我们使用了一段简单的正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code> 命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中 <code>REGEX</code> 部分是我们需要使用的正则表达式，而 <code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p>
<h2 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h2>
<p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： <code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>?</code> 匹配前面字符零次或一次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<p><code>sed</code> 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加<code>\</code>才能使其具有特殊含义。或者，您也可以添加<code>-E</code>选项来支持这些匹配。</p>
<p>回过头我们再看<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含”Disconnected from “的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 “Disconnected from” 作为自己的用户名会怎样呢？</p>
<pre><code>Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]
</code></pre>
<p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code> 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p>
<pre><code>46.97.239.16 port 55920 [preauth]
</code></pre>
<p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给 <code>*</code> 或 <code>+</code> 增加一个<code>?</code> 后缀使其变成非贪婪模式，但是很可惜 <code>sed</code> 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式：</p>
<pre><code>perl -pe 's/.*?Disconnected from //'
</code></pre>
<p>让我们回到 <code>sed</code> 命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>是最常见的工具。<code>sed</code> 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code> 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p>
<p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p>
<p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配一整行：</p>
<pre><code> | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//'
</code></pre>
<p>让我们借助正则表达式在线调试工具<a href="https://regex101.com/r/qqbZqh/2">regex debugger</a> 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code> 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀<code>[preauth]</code>，最后再匹配行尾。</p>
<p>注意，这样做的话，即使用户名是“Disconnected from”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p>
<p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名保留下来。对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如<code>\1</code>、 <code>\2</code>、<code>\3</code>等等，因此可以使用如下命令：</p>
<pre><code> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章<a href="https://www.regular-expressions.info/email.html">e-mail address</a>，匹配电子邮箱可一点<a href="https://emailregex.com/">也不简单</a>。网络上还有很多关于如何匹配电子邮箱地址的<a href="https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression/1917982">讨论</a>。人们还为其编写了<a href="https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php">测试用例</a>及 <a href="https://mathiasbynens.be/demo/url-regex">测试矩阵</a>。您甚至可以编写一个用于判断一个数<a href="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">是否为质数</a>的正则表达式。</p>
<p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p>
<h2 id="回到数据整理"><a class="header" href="#回到数据整理">回到数据整理</a></h2>
<p>OK，现在我们有如下表达式：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
</code></pre>
<p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用 <code>i</code> 命令)，打印特定的行 (使用 <code>p</code>命令)，基于索引选择特定行等等。详情请见<code>man sed</code>!</p>
<p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
</code></pre>
<p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
</code></pre>
<p><code>sort -n</code> 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序 <code>-k1,1</code> 则表示“仅基于以空格分割的第一列进行排序”。<code>,n</code> 部分表示“仅排序到第n个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p>
<p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code> 来代替<code>tail</code>。或者使用<code>sort -r</code>来进行倒序排序。</p>
<p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | awk '{print $2}' | paste -sd,
</code></pre>
<p>如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD <code>paste</code>使用。参考<a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell</a>的习题内容获取更多相关信息。</p>
<p>我们可以利用 <code>paste</code>命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割 (<code>-d</code>)，那<code>awk</code>的作用又是什么呢？</p>
<h2 id="awk--另外一种编辑器"><a class="header" href="#awk--另外一种编辑器">awk – 另外一种编辑器</a></h2>
<p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code> 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p>
<p>首先， <code>{print $2}</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p>
<p>让我们看看，还有什么炫酷的操作可以做。让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p>
<pre><code> | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l
</code></pre>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>{...}</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<pre><code>BEGIN { rows = 0 }
$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 }
END { print rows }
</code></pre>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 <code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以<a href="https://backreference.org/2010/02/10/idiomatic-awk">解决所有问题</a>。至于怎么做，就留给读者们做课后练习吧。</p>
<h2 id="分析数据"><a class="header" href="#分析数据">分析数据</a></h2>
<p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p>
<pre><code> | paste -sd+ | bc -l
</code></pre>
<p>使用bc需要执行<code>sudo apt install bc</code>命令。</p>
<p>下面这种更加复杂的表达式也可以：</p>
<pre><code>echo &quot;2*($(data | paste -sd+))&quot; | bc -l
</code></pre>
<p>您可以通过多种方式获取统计数据。如果已经安装了R语言，<a href="https://github.com/nferraz/st"><code>st</code></a>是个不错的选择：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | awk '{print $1}' | R --slave -e 'x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)'
</code></pre>
<p>R 也是一种编程语言，它非常适合被用来进行数据分析和<a href="https://ggplot2.tidyverse.org/">绘制图表</a>。这里我们不会讲的特别详细， 您只需要知道<code>summary</code> 可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用R语言就可以得到我们想要的统计数据。</p>
<p>如果您希望绘制一些简单的图表， <code>gnuplot</code> 可以帮助到您：</p>
<pre><code>ssh myserver journalctl
 | grep sshd
 | grep &quot;Disconnected from&quot;
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
 | sort | uniq -c
 | sort -nk1,1 | tail -n10
 | gnuplot -p -e 'set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes'
</code></pre>
<h2 id="利用数据整理来确定参数"><a class="header" href="#利用数据整理来确定参数">利用数据整理来确定参数</a></h2>
<p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 <code>xargs</code> 即可实现：</p>
<pre><code>rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed 's/-x86.*//' | xargs rustup toolchain uninstall
</code></pre>
<h2 id="整理二进制数据"><a class="header" href="#整理二进制数据">整理二进制数据</a></h2>
<p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p>
<pre><code>ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -
 | convert - -colorspace gray -
 | gzip
 | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -'
</code></pre>
<h1 id="课后练习"><a class="header" href="#课后练习">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//data-wrangling-solution">习题解答</a></p>
<ol>
<li>
<p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.</p>
</li>
<li>
<p>统计words文件 (<code>/usr/share/dict/words</code>) 中包含至少三个<code>a</code> 且不以<code>'s</code> 结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code>的 <code>y</code>命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很 有挑战性的问题：哪个组合从未出现过？</p>
</li>
<li>
<p>进行原地替换听上去很有诱惑力，例如： <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题</p>
</li>
<li>
<p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：</p>
<pre><code>Logs begin at ...
</code></pre>
<p>和</p>
<pre><code>systemd[577]: Startup finished in ...
</code></pre>
<p>在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>
<pre><code>=== system boot:
</code></pre>
<p>和</p>
<pre><code>Previous shutdown cause: 5
</code></pre>
</li>
<li>
<p>查看之前三次重启启动信息中不同的部分(参见 <code>journalctl</code>的<code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code> 来删除<code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code> )。最后，删除所有出现过3次的内容（因为这些内容是三次启动日志中的重复部分）。</p>
</li>
<li>
<p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者<a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从<a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<a href="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p>
</li>
</ol>
<h1 id="solution-数据清洗"><a class="header" href="#solution-数据清洗">Solution-数据清洗</a></h1>
<ol>
<li>
<p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.</p>
</li>
<li>
<p>统计words文件 (<code>/usr/share/dict/words</code>) 中包含至少三个<code>a</code> 且不以<code>'s</code> 结尾的单词个数。</p>
<pre><code>#这里我是在树莓派上面操作的
cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | wc -l
# 850
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/1.png" alt="1.png" /></p>
<ul>
<li>
<p>大小写转换：<code>tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;</code></p>
</li>
<li>
<p><code>^([^a]*a){3}.*[^'s]$</code>：查找一个以 a 结尾的字符串三次</p>
</li>
<li>
<p><code>grep -v &quot;\'s$&quot;</code>：匹配结尾为’s 的结果，然后取反。 借助 <code>grep -v</code>主要是这里不支持 lookback，不然下面的正则就可以完成</p>
<pre><code> ^([^a]*a){3}.*(?&lt;!'s)$
</code></pre>
<p>这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code>的 <code>y</code>命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。</p>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq -c | sort | tail -n3
# 53 as
# 64 ns
# 102 an
</code></pre>
<p>共存在多少种词尾两字母组合？</p>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq | wc -l
</code></pre>
<p>还有一个很 有挑战性的问题：哪个组合从未出现过？ 为了得到没出现的组合，首先我们要生成一个包含全部组合的列表，然后再使用上面得到的出现的组合，比较二者不同即可。</p>
<pre><code>#!/bin/bash
for i in {a..z};do
 for j in {a..z};do
    echo  &quot;$i$j&quot;
 done
done
</code></pre>
<pre><code>./all.sh &gt; all.txt
</code></pre>
<pre><code>cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a){3}.*$&quot; | grep -v &quot;'s$&quot; | sed -E &quot;s/.*([a-z]{2})$/\1/&quot; | sort | uniq &gt; occurance.txt
</code></pre>
<pre><code>diff --unchanged-group-format='' &lt;(cat occurance.txt) &lt;(cat all.txt) | wc -l
</code></pre>
<p><code>--unchanged-group-format=''</code>用于将两个文件中相同的内容设置为空字符串，剩下的内容就是差异的部分。</p>
</li>
</ul>
</li>
<li>
<p>进行原地替换听上去很有诱惑力，例如： <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题。<br />
<code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code> 表达式中后一个 <code>input.txt</code>会首先被清空，而且是发生在前的。所以前面一个<code>input.txt</code>在还没有被 <code>sed</code> 处理时已经为空了。在使用正则处理文件前最好是首先备份文件。</p>
<pre><code>sed -i.bak s/REGEX/SUBSTITUTION/ input.txt
</code></pre>
<p>可以自动创建一个后缀为 <code>.bak</code> 的备份文件。</p>
</li>
<li>
<p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：</p>
<pre><code>Logs begin at ...
</code></pre>
<p>和</p>
<pre><code>systemd[577]: Startup finished in ...
</code></pre>
<p>在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>
<pre><code>=== system boot:
</code></pre>
<p>和</p>
<pre><code>Previous shutdown cause: 5
</code></pre>
<p>为了进行这个练习，我们需要首先允许<code>journalctl</code>记录多次开机的日志，具体背景信息可以参考<a href="https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs">这里</a>和<a href="https://askubuntu.com/questions/765315/how-to-find-previous-boot-log-after-ubuntu-16-04-restarts">这里</a>否则我们看到的始终都只有本次启动的日志。</p>
<pre><code>vim /etc/systemd/journald.conf
</code></pre>
<p>设置<code>Storage=persistent</code> 执行上述命令后，重启</p>
<pre><code>pi@raspberrypi:~$ journalctl --list-boots
-1 d176984f171a4ceba353de47abd2b891 Thu 2021-05-27 15:55:36 BST—Fri 2021-05-28 02:09:50 BST
0 18c4819a536548a29def9f2b56f63dd0 Fri 2021-05-28 02:09:51 BST—Fri 2021-05-28 02:25:50 BST
</code></pre>
<p>可以看到已经可以列出多次启动信息了，然后我们进行十次重启。<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/2.png" alt="1.png" />可以使用 <code>systemd-analyze</code>工具看一下启动时间都花在哪里：</p>
<pre><code>sudo systemd-analyze plot &gt; systemd.svg
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/4/3.svg" alt="1.png" /><br />
<em>右键图片新窗口打开查看大图</em><br />
可以看到启动时间为 14.157s。 接下来，编写脚本<code>getlog.sh</code>来获取最近十次的启动时间数据：</p>
<pre><code>#!/bin/bash
for i in {0..9}; do
   journalctl -b-$i | grep &quot;Startup finished in&quot;
done
</code></pre>
<pre><code>./getlog &gt; starttime.txt
</code></pre>
<pre><code>#获取最长时间
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort | tail -n1
#获取最短时间
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort -r | tail -n1
#平均数（注意 awk 要使用单引号）
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| paste -sd+ | bc -l | awk '{print $1/10}'
# 中位数
cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort |paste -sd\  | awk '{print ($5+$6)/2}'
</code></pre>
<p>如果配合使用 R 语言脚本则更加简单：</p>
<pre><code>sudo apt-get install r-base
</code></pre>
<pre><code>cat starttime.txt | grep &quot;systemd\[1\]&quot; | sed -E &quot;s/.*=\ (.*)s\.$/\1/&quot;| sort | R -e 'd&lt;-scan(&quot;stdin&quot;,quiet=TRUE);min(d);max(d);mean(d);median(d);'
</code></pre>
<pre><code>&gt; d&lt;-scan(&quot;stdin&quot;,quiet=TRUE);min(d);max(d);mean(d);median(d);
[1] 14.023
[1] 15.989
[1] 14.4304
[1] 14.2915
</code></pre>
</li>
<li>
<p>查看之前三次重启启动信息中不同的部分(参见 <code>journalctl</code>的<code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code> 来删除<code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code> )。最后，删除所有出现过3次的内容（因为这些内容上三次启动日志中的重复部分）。 简单修改上面使用的<code>getlog.sh</code>，获取最近三次的日志，然后使用下面的命令：</p>
<pre><code>#注意 uniq 只能过滤相邻的行，所以必须先排序
cat last3start.txt | sed -E &quot;s/.*pi\ (.*)/\1/&quot; | sort | uniq -c | sort | awk '$1!=3  { print }'
</code></pre>
</li>
<li>
<p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者<a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从<a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<a href="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p>
<pre><code>~$ curl 'https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm#wikipedians' \
    |sed -n &quot;/table1/,/&lt;\/table&gt;/p&quot; \
    |grep &quot;&lt;tr&quot; | sed &quot;1,12d&quot;|head -n -3 \
    |sed -E 's/(&lt;[^&gt;]*&gt;)+/ /g' \
    |sed 's/ &amp;nbsp;/ -/g' \
    |sed 's/&amp;nbsp;//g' &gt; data
   
~$ cat data # 处理后的数据为Jan2001截至Oct2018的
Oct2018 2642056 12641 70805 10498 48.9M - 6101 - - - - 10.3M - - - - - - 42.6M 
Sep2018 2629415 11171 66574 10004 48.7M - 6116 - - - - 10.1M - - - - - - 42.4M 
Aug2018 2618244 12058 68688 10640 48.5M - 6839 - - - - 10.2M - - - - - - 42.1M 
Jul2018 2606186 12026 68037 10305 48.3M - 6987 - - - - 9.5M - - - - - - 41.9M 
...
Jan2001 7 7 9 - 31 12 1 8.6 1352 29% 10% 267 301kB 3.0k 15 - - 2 163 
</code></pre>
<p>命令说明（建议先查看网站的源码格式，更加容易理解下面的操作）</p>
</li>
</ol>
<ul>
<li>
<p><code>|sed -n &quot;/table1/,/&lt;\/table&gt;/p&quot;</code>：观察网站的源代码，可以发现第一个表格的id为<code>table1</code>，该命令将截取匹配到的<code>table1</code>以及下一个<code>&lt;/table&gt;</code>标签行之间的内容</p>
</li>
<li>
<p><code>|grep &quot;&lt;tr&quot;</code>：html表格中，含有数据的行是以<code>&lt;tr</code>开头，匹配这样的行</p>
</li>
<li>
<p><code>|sed &quot;1,12d&quot;</code>：去掉前12行（包含表格的表头）</p>
</li>
<li>
<p><code>|head -n -3</code>：去掉最后3行（包含非数据的内容）（注意：部分操作系统可能不支持该用法，最笨拙的替换实现方式是：<code>|sed &quot;$d&quot;|sed &quot;$d&quot;|sed &quot;$d&quot;</code>，即执行3次删除最后一行的操作）</p>
</li>
<li>
<p><code>|sed -E 's/(&lt;[^&gt;]*&gt;)+/ /g'</code>：使用正则匹配，将所有相邻的多个html标签（格式行如<code>&lt; tag &gt;</code>）替换为空格</p>
</li>
<li>
<p><code>|sed 's/ &amp;nbsp;/ -/g</code>：原表格中部分没有数据的单元格是以<code>&amp;nbsp;</code>填充的，将其替换为 <code>-</code>，避免在对数据操作时发生窜列的情况</p>
</li>
<li>
<p><code>|sed 's/&amp;nbsp;//g</code>：原表格中部分单元格内的空格也是用<code>&amp;nbsp;</code>表示的，将其全部删除（不影响数据处理）</p>
<pre><code>~$ awk '{print $1,$4,$5}' data | sort --key=2n | head -n 1
Jan2001 9 -
# 从data中读取第一列（时间，用来定位后续结果）及第三、四列，并以第二行的数据以数字大小进行排序，然后显示最大值的结果；下一个命令显示最小值的结果

~$ awk '{print $1,$4,$5}' data | sort --key=2n | tail -n 1
Mar2007 91388 11506

~$ awk '{print $1,$4,$5}' data | awk '{print $2-$3}' | awk '{s+=$1} END {print s}'
10153001
# 使用第二列的数据减去第三列的数据后，将结果加总
</code></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="编辑器Vim.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="命令行环境.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="编辑器Vim.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="命令行环境.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
