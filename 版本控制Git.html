<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Version Control (Git) - Mdbook Template</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">开发工具</li><li class="chapter-item expanded "><a href="Shell工具和脚本.html"><strong aria-hidden="true">1.</strong> Shell Tools and Scripting</a></li><li class="chapter-item expanded "><a href="编辑器Vim.html"><strong aria-hidden="true">2.</strong> Editors (Vim)</a></li><li class="chapter-item expanded "><a href="数据整理.html"><strong aria-hidden="true">3.</strong> Data Wrangling</a></li><li class="chapter-item expanded "><a href="命令行环境.html"><strong aria-hidden="true">4.</strong> Command-line Environment</a></li><li class="chapter-item expanded "><a href="版本控制Git.html" class="active"><strong aria-hidden="true">5.</strong> Version Control (Git)</a></li><li class="chapter-item expanded "><a href="调试及性能分析.html"><strong aria-hidden="true">6.</strong> Debugging and Profiling</a></li><li class="chapter-item expanded "><a href="元编程.html"><strong aria-hidden="true">7.</strong> Metaprogramming</a></li><li class="chapter-item expanded "><a href="安全与密码学.html"><strong aria-hidden="true">8.</strong> Security and Cryptography</a></li><li class="chapter-item expanded affix "><li class="part-title">非开发实用工具</li><li class="chapter-item expanded "><a href="大杂烩.html"><strong aria-hidden="true">9.</strong> Potpourri</a></li><li class="chapter-item expanded "><a href="问答.html"><strong aria-hidden="true">10.</strong> Q&A</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mdbook Template</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="版本控制git"><a class="header" href="#版本控制git">版本控制(Git)</a></h1>
<p>版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p>
<p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p>
<p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p>
<ul>
<li>当前模块是谁编写的？</li>
<li>这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li>
<li>最近的1000个版本中，何时/为什么导致了单元测试失败？</li>
</ul>
<p>尽管版本控制系统有很多， 其事实上的标准则是 <strong>Git</strong> 。而这篇 <a href="https://xkcd.com/1597/">XKCD 漫画</a> 则反映出了人们对 Git 的评价：</p>
<p><img src="https://imgs.xkcd.com/comics/git.png" alt="xkcd 1597" /></p>
<p>因为 Git 接口的抽象泄漏（leaky abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git 可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p>
<p>尽管 Git 的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍 Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git 的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p>
<p><a href="https://missing-semester-cn.github.io/2020/version-control/">Git版本控制来源</a></p>
<ul>
<li><a href="#git-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">Git 的数据模型</a>
<ul>
<li><a href="#%E5%BF%AB%E7%85%A7snapshot">快照（Snapshot）</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E5%BB%BA%E6%A8%A1%E5%85%B3%E8%81%94%E5%BF%AB%E7%85%A7">历史记录建模：关联快照</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA">数据模型及其伪代码表示</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80">对象和内存寻址</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
<li><a href="#%E4%BB%93%E5%BA%93">仓库</a></li>
</ul>
</li>
<li><a href="#%E6%9A%82%E5%AD%98%E5%8C%BA">暂存区</a></li>
<li><a href="#git-%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%8F%A3">Git 的命令行接口</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80">基础</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6">分支和合并</a></li>
<li><a href="#%E8%BF%9C%E7%AB%AF%E6%93%8D%E4%BD%9C">远端操作</a></li>
<li><a href="#%E6%92%A4%E9%94%80">撤销</a></li>
</ul>
</li>
<li><a href="#git-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C">Git 高级操作</a></li>
<li><a href="#%E6%9D%82%E9%A1%B9">杂项</a></li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
<li><a href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></li>
<li><a href="#solution-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">Solution-版本控制</a></li>
</ul>
<h1 id="git-的数据模型"><a class="header" href="#git-的数据模型">Git 的数据模型</a></h1>
<p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p>
<h2 id="快照snapshot"><a class="header" href="#快照snapshot">快照（Snapshot）</a></h2>
<p>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p>
<pre><code>&lt;root&gt; (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = &quot;hello world&quot;)
|
+- baz.txt (blob, contents = &quot;git is wonderful&quot;)
</code></pre>
<p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p>
<h2 id="历史记录建模关联快照"><a class="header" href="#历史记录建模关联快照">历史记录建模：关联快照</a></h2>
<p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，Git 并没有采用这样的模型。</p>
<p>在 Git 中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p>
<p>在 Git 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p>
<pre><code>o &lt;-- o &lt;-- o &lt;-- o
            ^  
             \
              --- o &lt;-- o
</code></pre>
<p>上面是一个 ASCII 码构成的简图，其中的 <code>o</code> 表示一次提交（快照）。</p>
<p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p>
<pre><code>
o &lt;-- o &lt;-- o &lt;-- o &lt;---- o
            ^            /
             \          v
              --- o &lt;-- o
</code></pre>
<p>Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p>
<h2 id="数据模型及其伪代码表示"><a class="header" href="#数据模型及其伪代码表示">数据模型及其伪代码表示</a></h2>
<p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p>
<pre><code>// 文件就是一组数据
type blob = array&lt;byte&gt;

// 一个包含文件和目录的目录
type tree = map&lt;string, tree | blob&gt;

// 每个提交都包含一个父辈，元数据和顶层树
type commit = struct {
    parent: array&lt;commit&gt;
    author: string
    message: string
    snapshot: tree
}
</code></pre>
<p>这是一种简洁的历史模型。</p>
<h2 id="对象和内存寻址"><a class="header" href="#对象和内存寻址">对象和内存寻址</a></h2>
<p>Git 中的对象可以是 blob、树或提交：</p>
<pre><code>type object = blob | tree | commit
</code></pre>
<p>Git 在储存数据时，所有的对象都会基于它们的 <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p>
<pre><code>objects = map&lt;string, object&gt;

def store(object):
    id = sha1(object)
    objects[id] = object

def load(id):
    return objects[id]
</code></pre>
<p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p>
<p>例如，<a href="https://missing-semester-cn.github.io/2020/version-control/#snapshots">上面</a>例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化），看上去是这样的：</p>
<pre><code>100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt
040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo
</code></pre>
<p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> (blob) 和 <code>foo</code> (树)。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p>
<pre><code>git is wonderful
</code></pre>
<h2 id="引用"><a class="header" href="#引用">引用</a></h2>
<p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p>
<p>针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code> 引用通常会指向主分支的最新一次提交。</p>
<pre><code>references = map&lt;string, string&gt;

def update_reference(name, id):
    references[name] = id

def read_reference(name):
    return references[name]

def load_reference(name_or_id):
    if name_or_id in references:
        return load(references[name_or_id])
    else:
        return load(name_or_id)
</code></pre>
<p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p>
<p>有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p>
<h2 id="仓库"><a class="header" href="#仓库">仓库</a></h2>
<p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和 <code>引用</code>。</p>
<p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>
<p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交 <code>5d83f9e</code> 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p>
<h1 id="暂存区"><a class="header" href="#暂存区">暂存区</a></h1>
<p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p>
<p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p>
<p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。</p>
<h1 id="git-的命令行接口"><a class="header" href="#git-的命令行接口">Git 的命令行接口</a></h1>
<p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 <a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>或可以观看本讲座的视频来学习。</p>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<ul>
<li><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li>
<li><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</li>
<li><code>git status</code>: 显示当前的仓库状态</li>
<li><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li>
<li><code>git commit</code>: 创建一个新的提交
<ul>
<li>如何编写 <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li>
<li>为何要 <a href="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li>
</ul>
</li>
<li><code>git log</code>: 显示历史日志</li>
<li><code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</li>
<li><code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li>
<li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</li>
<li><code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</li>
</ul>
<h2 id="分支和合并"><a class="header" href="#分支和合并">分支和合并</a></h2>
<ul>
<li><code>git branch</code>: 显示分支</li>
<li><code>git branch &lt;name&gt;</code>: 创建分支</li>
<li><code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支
<ul>
<li>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li>
</ul>
</li>
<li><code>git merge &lt;revision&gt;</code>: 合并到当前分支</li>
<li><code>git mergetool</code>: 使用工具来处理合并冲突</li>
<li><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</li>
</ul>
<h2 id="远端操作"><a class="header" href="#远端操作">远端操作</a></h2>
<ul>
<li><code>git remote</code>: 列出远端</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li>
<li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li>
<li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li>
<li><code>git fetch</code>: 从远端获取对象/索引</li>
<li><code>git pull</code>: 相当于 <code>git fetch; git merge</code></li>
<li><code>git clone</code>: 从远端下载仓库</li>
</ul>
<h2 id="撤销"><a class="header" href="#撤销">撤销</a></h2>
<ul>
<li><code>git commit --amend</code>: 编辑提交的内容或信息</li>
<li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li>
<li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li>
<li><code>git restore</code>: git2.32版本后取代git reset 进行许多撤销操作</li>
</ul>
<h1 id="git-高级操作"><a class="header" href="#git-高级操作">Git 高级操作</a></h1>
<ul>
<li><code>git config</code>: Git 是一个 <a href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li>
<li><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li>
<li><code>git add -p</code>: 交互式暂存</li>
<li><code>git rebase -i</code>: 交互式变基</li>
<li><code>git blame</code>: 查看最后修改某行的人</li>
<li><code>git stash</code>: 暂时移除工作目录下的修改内容</li>
<li><code>git bisect</code>: 通过二分查找搜索历史记录</li>
<li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">指定</a> 故意不追踪的文件</li>
</ul>
<h1 id="杂项"><a class="header" href="#杂项">杂项</a></h1>
<ul>
<li><strong>图形用户界面</strong>: Git 的 <a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a> 有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</li>
<li><strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>这样的框架中一般以及集成了这一功能</li>
<li><strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> 是 Vim 中集成 GIt 的常用插件</li>
<li><strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有<a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a> <a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a> <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</li>
<li><strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub 中您需要使用一个被称作<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>的方法来向其他项目贡献代码</li>
<li><strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像 <a href="https://about.gitlab.com/">GitLab</a> 和 <a href="https://bitbucket.org/">BitBucket</a> 这样的平台。</li>
</ul>
<h1 id="资源"><a class="header" href="#资源">资源</a></h1>
<ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git</a> ，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li>
<li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> ，简短的介绍了如何从 Git 错误中恢复；</li>
<li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> ，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li>
<li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li>
<li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> 通过基于浏览器的游戏来学习 Git ；</li>
</ul>
<h1 id="课后练习"><a class="header" href="#课后练习">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//version-control-solution">习题解答</a></p>
<ol>
<li>如果您之前从来没有用过 Git，推荐您阅读 <a href="https://git-scm.com/book/en/v2">Pro Git</a> 的前几章，或者完成像 <a href="https://learngitbranching.js.org/">Learn Git Branching</a>这样的教程。重点关注 Git 命令和数据模型相关内容；</li>
<li>Fork <a href="https://github.com/missing-semester-cn/missing-semester-cn.github.io.git">本课程网站的仓库</a>
<ol>
<li>将版本历史可视化并进行探索</li>
<li>是谁最后修改了 <code>README.md</code>文件？（提示：使用 <code>git log</code> 命令并添加合适的参数）</li>
<li>最后一次修改<code>_config.yml</code> 文件中 <code>collections:</code> 行时的提交信息是什么？（提示：使用 <code>git blame</code> 和 <code>git show</code>）</li>
</ol>
</li>
<li>使用 Git 时的一个常见错误是提交本不应该由 Git 管理的大文件，或是将含有敏感信息的文件提交给 Git 。尝试向仓库中添加一个文件并添加提交信息，然后将其从历史中删除 ( <a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">这篇文章也许会有帮助</a>)；</li>
<li>从 GitHub 上克隆某个仓库，修改一些文件。当您使用 <code>git stash</code> 会发生什么？当您执行 <code>git log --all --oneline</code> 时会显示什么？通过 <code>git stash pop</code> 命令来撤销 <code>git stash</code> 操作，什么时候会用到这一技巧？</li>
<li>与其他的命令行工具一样，Git 也提供了一个名为 <code>~/.gitconfig</code> 配置文件 (或 dotfile)。请在 <code>~/.gitconfig</code> 中创建一个别名，使您在运行 <code>git graph</code> 时，您可以得到 <code>git log --all --graph --decorate --oneline</code> 的输出结果；</li>
<li>您可以通过执行 <code>git config --global core.excludesfile ~/.gitignore_global</code> 在 <code>~/.gitignore_global</code> 中创建全局忽略规则。配置您的全局 gitignore 文件来自动忽略系统或编辑器的临时文件，例如 <code>.DS_Store</code>；</li>
<li>克隆 <a href="https://github.com/missing-semester-cn/missing-semester-cn.github.io.git">本课程网站的仓库</a>，找找有没有错别字或其他可以改进的地方，在 GitHub 上发起拉取请求（Pull Request）；</li>
</ol>
<h1 id="solution-版本控制"><a class="header" href="#solution-版本控制">Solution-版本控制</a></h1>
<ol>
<li>
<p>如果您之前从来没有用过 Git，推荐您阅读 Pro Git 的前几章，或者完成像 Learn Git Branching这样的教程。重点关注 Git 命令和数据模型相关内容；</p>
</li>
<li>
<p>Fork 本课程网站的仓库</p>
</li>
<li>
<p>将版本历史可视化并进行探索（按q退出git log）</p>
<pre><code> git log --all --graph --decorate
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/1.png" alt="1.png" /></p>
</li>
<li>
<p>是谁最后修改了 README.md文件？（提示：使用 git log 命令并添加合适的参数）</p>
<pre><code>git log -1 README.md
</code></pre>
<ul>
<li>-x 选项：查看最新的 x 次提交或特定文件的版本信息<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/2.png" alt="1.png" /></li>
</ul>
</li>
<li>
<p>最后一次修改_config.yml 文件中 collections: 行时的提交信息是什么？（提示：使用 git blame 和 git show）</p>
<pre><code> git blame _config.yml | grep collections
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/3.png" alt="1.png" /></p>
<pre><code> git show --pretty=format:&quot;%s&quot; a88b4eac | head -1
</code></pre>
<p>或者，使用git log命令</p>
<pre><code> git log --pretty=format:&quot;%s&quot; a88b4eac -1
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/4.png" alt="1.png" /></p>
</li>
<li>
<p>使用 Git 时的一个常见错误是提交本不应该由 Git 管理的大文件，或是将含有敏感信息的文件提交给 Git 。尝试向仓库中添加一个文件并添加提交信息，然后将其从历史中删除 ( 这篇文章也许会有帮助)；</p>
</li>
<li>
<p>首先提交一些敏感信息</p>
<pre><code> echo &quot;password123&quot;&gt;my_password
 git add .
 git commit -m &quot;add password123 to file&quot;
 git log HEAD
</code></pre>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/5.png" alt="1.png" /></p>
</li>
<li>
<p>使用<code>git filter-branch</code>清除提交记录</p>
<pre><code> git filter-branch --force --index-filter\
 'git rm --cached --ignore-unmatch ./my_password' \
 --prune-empty --tag-name-filter cat -- --all
</code></pre>
<p>文件已经删除<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/6.png" alt="1.png" />提交记录已经删除<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/7.png" alt="1.png" />
这里会报如下的Warning：<code>git-filter-branch has a glut of gotchas generating mangled history rewrites.  Hit Ctrl-C before proceeding to abort, then use an alternative filtering tool such as 'git filter-repo'(https://github.com/newren/git-filter-repo/) instead.  See the filter-branch manual page for more details; to squelch this warning, set FILTER_BRANCH_SQUELCH_WARNING=1.</code></p>
</li>
<li>
<p>从 GitHub 上克隆某个仓库，修改一些文件。当您使用 git stash 会发生什么？当您执行 git log –all –oneline 时会显示什么？通过 git stash pop 命令来撤销 git stash 操作，什么时候会用到这一技巧？<img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/8.png" alt="1.png" /><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/9.png" alt="1.png" /><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/10.png" alt="1.png" /><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/11.png" alt="1.png" /></p>
<ul>
<li>接下来，将在视频展示的demo仓库上展示stash操作（注意：Git Graph是可视化版本控制插件，GitLens是源代码管理插件，不是git的命令。）</li>
</ul>
<pre><code> ~/gits/demo (main?) $ git graph
 * a735daf (HEAD -&gt; main) Change the print functions
 - 9d983c7 Merge branch 'dog'
 |\
 | * aa83cee (dog) Add dog functionality
 * | 077e2a0 (cat) Add cat functionality
 |/
 * ce1d2f0 Add animal.py
 * ba821e1 Add another line
 * 1547103 Create demo for learning git commands
</code></pre>
<ul>
<li>创建新文件，添加到暂存区后，将其存入stash存储列表</li>
</ul>
<pre><code> ~/gits/demo (main?) $ echo 'new file' &gt; file.txt
 ~/gits/demo (main?) $ git add file.txt
 ~/gits/demo (main+?) $ git status
 On branch main
 Changes to be committed:
   (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
         new file:   file.txt

  # 将暂存区的file.txt存到stash 
 ~/gits/demo (main+) $ git stash save &quot;create file.txt&quot;
 Saved working directory and index state On main: create file.txt
</code></pre>
<ul>
<li>查看stash存储的内容</li>
</ul>
<pre><code>  # 列出所有的存储，按照git stash的执行顺序依次从0开始编号
  # 每份存储对应的编号，就是stash@{}中的数字
 ~/gits/demo (main) $ git stash list
 stash@{0}: On main: create file.txt

  # git stash show默认显示第一份存储，也可以指定要显示的存储
 ~/gits/demo (main) $ git stash show
  file.txt | 1 +
  1 file changed, 1 insertion(+)
 ~/gits/demo (main) $ git stash show stash@{0}
  file.txt | 1 +
  1 file changed, 1 insertion(+)
</code></pre>
<ul>
<li>执行<code>git stash</code>后，添加到暂存区的内容不会再提示需要提交(Changes to be committed)。而且，尽管执行<code>git stash</code>使得提交记录新增了两项，但是可以发现<code>HEAD</code>引用并没有变动。</li>
</ul>
<pre><code> ~/gits/demo (main) $ git status
 On branch main
 nothing to commit, working tree clean

 ~/gits/demo (main) $ git graph
 - 27e9528 (refs/stash) On main: create file.txt
 |\
 | * 108018a index on main: a735daf Change the print functions
 |/
 * a735daf (HEAD -&gt; main) Change the print functions
 - 9d983c7 Merge branch 'dog'
 |\
 | * aa83cee (dog) Add dog functionality
 * | 077e2a0 (cat) Add cat functionality
 |/
 * ce1d2f0 Add animal.py
 * ba821e1 Add another line
 * 1547103 Create demo for learning git commands
</code></pre>
<ul>
<li>从main分支切换到dog分支，再将存储恢复，然后提交，这时，我们刚才新建的file.txt,变成了dog分支下的一次新提交。</li>
</ul>
<pre><code> ~/gits/demo (main) $ git checkout dog
 Switched to branch 'dog'
 ~/gits/demo (dog) $ git stash pop
 On branch dog
 Changes to be committed:
   (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
         new file:   file.txt
    
 Dropped refs/stash@{0} (27e95285da3d0bad0c2a452238628dd893e623b7)
  # 该命令会删除原来的存储stash@{0}，并在当前分支dog下恢复暂存区文件file.txt
 ~/gits/demo (dog+) $ git status
 On branch dog
 Changes to be committed:
   (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
         new file:   file.txt
    
 ~/gits/demo (dog+) $ git commit -m 'Add file.txt on branch dog'
 [dog 19b71ce] Add file.txt on branch dog
  1 file changed, 1 insertion(+)
  create mode 100644 file.txt

 ~/gits/demo (dog) $ git graph
 * 19b71ce (HEAD -&gt; dog) Add file.txt on branch dog
 | * a735daf (main) Change the print functions
 | - 9d983c7 Merge branch 'dog'
 | |\
 | |/
 |/|
 * | aa83cee Add dog functionality
 | * 077e2a0 (cat) Add cat functionality
 |/
 * ce1d2f0 Add animal.py
 * ba821e1 Add another line
 * 1547103 Create demo for learning git commands
</code></pre>
<ul>
<li>当我们将改动添加到暂存区（<code>git add</code>）后，通过执行<code>git stash</code>后，可以自由地切换到其他分支（注意：在暂存区存有改动时，切换分支(<code>checkout</code>)是不被允许的）</li>
<li>另外，运用<code>stash</code>和<code>stash pop</code>，可以自由选择 <em>stash存储的改动</em> 即将提交到的分支（本例中，将原本应该在main分支下提交的记录移动到了dog分支下进行提交）</li>
</ul>
</li>
<li>
<p>与其他的命令行工具一样，Git 也提供了一个名为 ~/.gitconfig 配置文件 (或 dotfile)。请在 ~/.gitconfig 中创建一个别名，使您在运行 git graph 时，您可以得到 git log –all –graph –decorate –oneline 的输出结果；</p>
<pre><code>[alias]
    graph = log --all --graph --decorate --oneline
</code></pre>
</li>
<li>
<p>您可以通过执行 git config –global core.excludesfile ~/.gitignore_global 在 ~/.gitignore_global 中创建全局忽略规则。配置您的全局 gitignore 文件来自动忽略系统或编辑器的临时文件，例如 .DS_Store；</p>
<pre><code>git config --global core.excludesfile ~/.gitignore .DS_Store
</code></pre>
</li>
<li>
<p>克隆 本课程网站的仓库，找找有没有错别字或其他可以改进的地方，在 GitHub 上发起拉取请求（Pull Request）； 首先 fork 本网站仓库，然后克隆 fork 后的仓库</p>
<pre><code>git clone https://github.com/hanxiaomax/missing-semester.git
</code></pre>
<p>在本地进行修改后，提交到 fork 后的仓库，然后<a href="https://github.com/missing-semester/missing-semester/pulls">发起 PR</a></p>
<p><img src="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/6/12.png" alt="1.png" /></p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="命令行环境.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="调试及性能分析.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="命令行环境.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="调试及性能分析.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
