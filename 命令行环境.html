<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Command-line Environment - Mdbook Template</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">开发工具</li><li class="chapter-item expanded "><a href="Shell工具和脚本.html"><strong aria-hidden="true">1.</strong> Shell Tools and Scripting</a></li><li class="chapter-item expanded "><a href="编辑器Vim.html"><strong aria-hidden="true">2.</strong> Editors (Vim)</a></li><li class="chapter-item expanded "><a href="数据整理.html"><strong aria-hidden="true">3.</strong> Data Wrangling</a></li><li class="chapter-item expanded "><a href="命令行环境.html" class="active"><strong aria-hidden="true">4.</strong> Command-line Environment</a></li><li class="chapter-item expanded "><a href="版本控制Git.html"><strong aria-hidden="true">5.</strong> Version Control (Git)</a></li><li class="chapter-item expanded "><a href="调试及性能分析.html"><strong aria-hidden="true">6.</strong> Debugging and Profiling</a></li><li class="chapter-item expanded "><a href="元编程.html"><strong aria-hidden="true">7.</strong> Metaprogramming</a></li><li class="chapter-item expanded "><a href="安全与密码学.html"><strong aria-hidden="true">8.</strong> Security and Cryptography</a></li><li class="chapter-item expanded affix "><li class="part-title">非开发实用工具</li><li class="chapter-item expanded "><a href="大杂烩.html"><strong aria-hidden="true">9.</strong> Potpourri</a></li><li class="chapter-item expanded "><a href="问答.html"><strong aria-hidden="true">10.</strong> Q&A</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mdbook Template</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="命令行环境"><a class="header" href="#命令行环境">命令行环境</a></h1>
<p><a href="https://missing-semester-cn.github.io/2020/command-line/">命令行环境来源</a></p>
<ul>
<li><a href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6">任务控制</a>
<ul>
<li><a href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B">结束进程</a></li>
<li><a href="#%E6%9A%82%E5%81%9C%E5%92%8C%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B">暂停和后台执行进程</a></li>
</ul>
</li>
<li><a href="#%E7%BB%88%E7%AB%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">终端多路复用</a></li>
<li><a href="#%E5%88%AB%E5%90%8D">别名</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6dotfiles">配置文件（Dotfiles）</a>
<ul>
<li><a href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7">可移植性</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9C%E7%AB%AF%E8%AE%BE%E5%A4%87">远端设备</a>
<ul>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4">执行命令</a></li>
<li><a href="#ssh-%E5%AF%86%E9%92%A5">SSH 密钥</a>
<ul>
<li><a href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90">密钥生成</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6">基于密钥的认证机制</a></li>
</ul>
</li>
<li><a href="#%E9%80%9A%E8%BF%87-ssh-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6">通过 SSH 复制文件</a></li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">端口转发</a></li>
<li><a href="#ssh-%E9%85%8D%E7%BD%AE">SSH 配置</a></li>
<li><a href="#%E6%9D%82%E9%A1%B9">杂项</a></li>
</ul>
</li>
<li><a href="#shell--%E6%A1%86%E6%9E%B6">Shell &amp; 框架</a></li>
<li><a href="#%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8">终端模拟器</a></li>
<li><a href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a>
<ul>
<li><a href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6-1">任务控制</a></li>
<li><a href="#%E7%BB%88%E7%AB%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1">终端多路复用</a></li>
<li><a href="#%E5%88%AB%E5%90%8D-1">别名</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E8%BF%9C%E7%AB%AF%E8%AE%BE%E5%A4%87-1">远端设备</a></li>
</ul>
</li>
<li><a href="#solution-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83">Solution-命令行环境</a>
<ul>
<li><a href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6-2">任务控制</a></li>
<li><a href="#%E7%BB%88%E7%AB%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-2">终端多路复用</a></li>
<li><a href="#%E5%88%AB%E5%90%8D-2">别名</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1">配置文件</a></li>
<li><a href="#%E8%BF%9C%E7%AB%AF%E8%AE%BE%E5%A4%87-2">远端设备</a></li>
</ul>
</li>
<li><a href="#ssh%E5%BC%80%E5%90%AFwin10">SSH开启（win10）</a>
<ul>
<li><a href="#0-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">0 应用场景</a></li>
<li><a href="#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%90%AF">1 服务端开启</a></li>
<li><a href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5">2 客户端连接</a></li>
<li><a href="#3-%E5%85%B3%E9%97%AD%E5%AE%A2%E6%88%B7%E7%AB%AF">3 关闭客户端</a></li>
</ul>
</li>
</ul>
<p>当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p>
<p>我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p>
<p>我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。</p>
<h1 id="任务控制"><a class="header" href="#任务控制">任务控制</a></h1>
<p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用 <code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用 <code>Ctrl-C</code> 来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p>
<h2 id="结束进程"><a class="header" href="#结束进程">结束进程</a></h2>
<p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code> 信号，通过输入<code>Ctrl-\</code>可以发送该信号。</p>
<pre><code class="language-python">#!/usr/bin/env python
import signal, time

def handler(signum, time):
    print(&quot;\nI got a SIGINT, but I am not stopping&quot;)

signal.signal(signal.SIGINT, handler)
i = 0
while True:
    time.sleep(.1)
    print(&quot;\r{}&quot;.format(i), end=&quot;&quot;)
    i += 1
</code></pre>
<p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次 <code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code> 是我们在终端输入<code>Ctrl</code> 时的表示形式：</p>
<pre><code class="language-bash">$ python sigint.py
24^C
I got a SIGINT, but I am not stopping
26^C
I got a SIGINT, but I am not stopping
30^\[1]    39913 quit       python sigint.pyƒ
</code></pre>
<p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p>
<h2 id="暂停和后台执行进程"><a class="header" href="#暂停和后台执行进程">暂停和后台执行进程</a></h2>
<p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p>
<p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p>
<p>下面这个简单的会话中展示来了些概念的应用。</p>
<pre><code class="language-bash">$ sleep 1000
^Z
[1]  + 18653 suspended  sleep 1000

$ nohup sleep 2000 &amp;
[2] 18745
appending output to nohup.out

$ jobs
[1]  + suspended  sleep 1000
[2]  - running    nohup sleep 2000

$ bg %1
[1]  - 18653 continued  sleep 1000

$ jobs
[1]  - running    sleep 1000
[2]  + running    nohup sleep 2000

$ kill -STOP %1
[1]  + 18653 suspended (signal)  sleep 1000

$ jobs
[1]  + suspended (signal)  sleep 1000
[2]  - running    nohup sleep 2000

$ kill -SIGHUP %1
[1]  + 18653 hangup     sleep 1000

$ jobs
[2]  + running    nohup sleep 2000

$ kill -SIGHUP %2

$ jobs
[2]  + running    nohup sleep 2000

$ kill %2
[2]  + 18745 terminated  nohup sleep 2000

$ jobs

</code></pre>
<p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<p>您可以在 <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">这里</a> 或输入 <a href="https://www.man7.org/linux/man-pages/man7/signal.7.html"><code>man signal</code></a> 或使用 <code>kill -l</code> 来获取更多关于信号的信息。</p>
<h1 id="终端多路复用"><a class="header" href="#终端多路复用">终端多路复用</a></h1>
<p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p>
<ul>
<li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口
<ul>
<li><code>tmux</code> 开始一个新的会话</li>
<li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li>
<li><code>tmux ls</code> 列出当前所有会话</li>
<li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li>
<li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li>
</ul>
</li>
<li><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分
<ul>
<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code>关闭</li>
<li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li>
<li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li>
<li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li>
<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>
<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>
</ul>
</li>
<li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell
<ul>
<li><code>&lt;C-b&gt; &quot;</code> 水平分割</li>
<li><code>&lt;C-b&gt; %</code> 垂直分割</li>
<li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li>
<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>
<li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li>
<li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li>
</ul>
</li>
</ul>
<p>扩展阅读： <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">这里</a> 是一份 <code>tmux</code> 快速入门教程， <a href="http://linuxcommand.org/lc3_adv_termmux.php">而这一篇</a> 文章则更加详细，它包含了 <code>screen</code> 命令。您也许想要掌握 <a href="https://www.man7.org/linux/man-pages/man1/screen.1.html"><code>screen</code></a> 命令，因为在大多数 UNIX 系统中都默认安装有该程序。</p>
<h1 id="别名"><a class="header" href="#别名">别名</a></h1>
<p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<pre><code>alias alias_name=&quot;command_to_alias arg1 arg2&quot;
</code></pre>
<p>注意， <code>=</code>两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<pre><code class="language-bash"># 创建常用命令的缩写
alias ll=&quot;ls -lh&quot;

# 能够少输入很多
alias gs=&quot;git status&quot;
alias gc=&quot;git commit&quot;
alias v=&quot;vim&quot;

# 手误打错命令也没关系
alias sl=ls

# 重新定义一些命令行的默认行为
alias mv=&quot;mv -i&quot;           # -i prompts before overwrite
alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed
alias df=&quot;df -h&quot;           # -h prints human readable format

# 别名可以组合使用
alias la=&quot;ls -A&quot;
alias lla=&quot;la -l&quot;

# 在忽略某个别名
\ls
# 或者禁用别名
unalias la

# 获取别名的定义
alias ll
# 会打印 ll='ls -lh'
</code></pre>
<p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code> 或 <code>.zshrc</code>，下一节我们就会讲到。</p>
<h1 id="配置文件dotfiles"><a class="header" href="#配置文件dotfiles">配置文件（Dotfiles）</a></h1>
<p>很多程序的配置都是通过纯文本格式的被称作点文件的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源。</p>
<p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过点文件进行配置：</p>
<ul>
<li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>
<li><code>git</code> - <code>~/.gitconfig</code></li>
<li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li>
<li><code>ssh</code> - <code>~/.ssh/config</code></li>
<li><code>tmux</code> - <code>~/.tmux.conf</code></li>
</ul>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>
<ul>
<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>
<li><strong>可移植性</strong>: 您的工具在任何地方都以相同的配置工作</li>
<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>
<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>
</ul>
<p>配置文件中需要放些什么？您可以通过在线文档和<a href="https://en.wikipedia.org/wiki/Man_page">帮助手册</a>了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的<a href="https://github.com/search?o=desc&amp;q=dotfiles&amp;s=stars&amp;type=Repositories">dotfiles 仓库</a> —— 其中最受欢迎的那些可以在<a href="https://github.com/mathiasbynens/dotfiles">这里</a>找到（我们建议您不要直接复制别人的配置）。<a href="https://dotfiles.github.io/">这里</a> 也有一些非常有用的资源。</p>
<p>本课程的老师们也在 GitHub 上开源了他们的配置文件： <a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/jjgo/dotfiles">Jose</a>.</p>
<h2 id="可移植性"><a class="header" href="#可移植性">可移植性</a></h2>
<p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p>
<pre><code>if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi

# 使用和 shell 相关的配置时先检查当前 shell 类型
if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi

# 您也可以针对特定的设备进行配置
if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi
</code></pre>
<p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p>
<pre><code>[include]
    path = ~/.gitconfig_local
</code></pre>
<p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>
<pre><code># Test if ~/.aliases exists and source it
if [ -f ~/.aliases ]; then
    source ~/.aliases
fi
</code></pre>
<h1 id="远端设备"><a class="header" href="#远端设备">远端设备</a></h1>
<p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p>
<p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<pre><code>ssh foo@bar.mit.edu
</code></pre>
<p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p>
<h2 id="执行命令"><a class="header" href="#执行命令">执行命令</a></h2>
<p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。 <code>ssh foobar@server ls</code> 可以直接在用foobar的命令下执行 <code>ls</code> 命令。 想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p>
<h2 id="ssh-密钥"><a class="header" href="#ssh-密钥">SSH 密钥</a></h2>
<p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p>
<h3 id="密钥生成"><a class="header" href="#密钥生成">密钥生成</a></h3>
<p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<pre><code>ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519
</code></pre>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h3 id="基于密钥的认证机制"><a class="header" href="#基于密钥的认证机制">基于密钥的认证机制</a></h3>
<p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<pre><code>cat .ssh/id_ed25519.pub | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys'
</code></pre>
<p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p>
<pre><code>ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote
</code></pre>
<h2 id="通过-ssh-复制文件"><a class="header" href="#通过-ssh-复制文件">通过 SSH 复制文件</a></h2>
<p>使用 ssh 复制文件有很多方法：</p>
<ul>
<li><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code> 命令，然后通过这样的方法利用标准输入实现 <code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a> 命令会将标准输出写入到一个文件；</li>
<li><a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a> ：当需要拷贝大量的文件或目录时，使用<code>scp</code> 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li>
<li><a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a> 对 <code>scp</code> 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 <code>--partial</code>标记实现断点续传。<code>rsync</code> 的语法和<code>scp</code>类似；</li>
</ul>
<h2 id="端口转发"><a class="header" href="#端口转发">端口转发</a></h2>
<p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行 <em>端口转发</em>。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p>
<p><strong>本地端口转发</strong><img src="https://i.stack.imgur.com/a28N8.png%C2%A0" alt="Local Port Forwarding" title="本地端口转发" /></p>
<p><strong>远程端口转发</strong><img src="https://i.stack.imgur.com/4iK3b.png%C2%A0" alt="Remote Port Forwarding" title="远程端口转发" /></p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h2 id="ssh-配置"><a class="header" href="#ssh-配置">SSH 配置</a></h2>
<p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p>
<pre><code>alias my_server=&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server
</code></pre>
<p>不过，更好的方法是使用 <code>~/.ssh/config</code>.</p>
<pre><code>Host vm
    User foobar
    HostName 172.16.174.141
    Port 2222
    IdentityFile ~/.ssh/id_ed25519
    LocalForward 9999 localhost:8888

# 在配置文件中也可以使用通配符
Host *.mit.edu
    User foobaz
</code></pre>
<p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似 <code>scp</code>、<code>rsync</code>和<code>mosh</code>的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p>
<p>注意，<code>~/.ssh/config</code> 文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p>
<p>服务器侧的配置通常放在 <code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh 端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p>
<h2 id="杂项"><a class="header" href="#杂项">杂项</a></h2>
<p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<a href="https://mosh.org/">Mosh</a>（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p>
<p>有时将一个远端文件夹挂载到本地会比较方便， <a href="https://github.com/libfuse/sshfs">sshfs</a> 可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p>
<h1 id="shell--框架"><a class="header" href="#shell--框架">Shell &amp; 框架</a></h1>
<p>在 shell 工具和脚本那节课中我们已经介绍了 <code>bash</code> shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。</p>
<p>例如，<code>zsh</code> shell 是 <code>bash</code> 的超集并提供了一些方便的功能：</p>
<ul>
<li>智能替换, <code>**</code></li>
<li>行内替换/通配符扩展</li>
<li>拼写纠错</li>
<li>更好的 tab 补全和选择</li>
<li>路径展开 (<code>cd /u/lo/b</code> 会被展开为 <code>/usr/local/bin</code>)</li>
</ul>
<p><strong>框架</strong> 也可以改进您的 shell。比较流行的通用框架包括<a href="https://github.com/sorin-ionescu/prezto">prezto</a> 或 <a href="https://ohmyz.sh/">oh-my-zsh</a>。还有一些更精简的框架，它们往往专注于某一个特定功能，例如<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh 语法高亮</a> 或 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh 历史子串查询</a>。 像 <a href="https://fishshell.com/">fish</a> 这样的 shell 包含了很多用户友好的功能，其中一些特性包括：</p>
<ul>
<li>向右对齐</li>
<li>命令语法高亮</li>
<li>历史子串查询</li>
<li>基于手册页面的选项补全</li>
<li>更智能的自动补全</li>
<li>提示符主题</li>
</ul>
<p>需要注意的是，使用这些框架可能会降低您 shell 的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p>
<h1 id="终端模拟器"><a class="header" href="#终端模拟器">终端模拟器</a></h1>
<p>和自定义 shell 一样，花点时间选择适合您的 <strong>终端模拟器</strong>并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间<a href="https://anarc.at/blog/2018-04-12-terminal-emulators-1/">比较</a>的信息）</p>
<p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p>
<ul>
<li>字体选择</li>
<li>彩色主题</li>
<li>快捷键</li>
<li>标签页/面板支持</li>
<li>回退配置</li>
<li>性能（像 <a href="https://github.com/jwilm/alacritty">Alacritty</a> 或者 <a href="https://sw.kovidgoyal.net/kitty/">kitty</a> 这种比较新的终端，它们支持GPU加速）。</li>
</ul>
<h1 id="课后练习"><a class="header" href="#课后练习">课后练习</a></h1>
<p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//command-line-solution">习题解答</a></p>
<h2 id="任务控制-1"><a class="header" href="#任务控制-1">任务控制</a></h2>
<ol>
<li>
<p>我们可以使用类似 <code>ps aux | grep</code> 这样的命令来获取任务的 pid ，然后您可以基于pid 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 <code>sleep 10000</code> 这个任务。然后用 <code>Ctrl-Z</code> 将其切换到后台并使用 <code>bg</code>来继续允许它。现在，使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 来查找 pid 并使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pkill</code></a> 结束进程而不需要手动输入pid。(提示： 使用 <code>-af</code> 标记)。</p>
</li>
<li>
<p>如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？在这个练习中，我们使用 <code>sleep 60 &amp;</code> 作为先执行的程序。一种方法是使用 <a href="http://man7.org/linux/man-pages/man1/wait.1p.html"><code>wait</code></a> 命令。尝试启动这个休眠命令，然后待其结束后再执行 <code>ls</code> 命令。</p>
<p>但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 <code>wait</code> 只能对子进程起作用。之前我们没有提过的一个特性是，<code>kill</code> 命令成功退出时其状态码为 0 ，其他状态则是非0。<code>kill -0</code> 则不会发送信号，但是会在进程不存在时返回一个不为0的状态码。请编写一个 bash 函数 <code>pidwait</code> ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 <code>sleep</code> 来避免浪费 CPU 性能。</p>
</li>
</ol>
<h2 id="终端多路复用-1"><a class="header" href="#终端多路复用-1">终端多路复用</a></h2>
<ol>
<li>请完成这个 <code>tmux</code> <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">教程</a> 参考<a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">这些步骤</a>来学习如何自定义 <code>tmux</code>。</li>
</ol>
<h2 id="别名-1"><a class="header" href="#别名-1">别名</a></h2>
<ol>
<li>创建一个 <code>dc</code> 别名，它的功能是当我们错误的将 <code>cd</code> 输入为 <code>dc</code> 时也能正确执行。</li>
<li>执行 <code>history | awk '{$1=&quot;&quot;;print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用<code>history 1</code> 替换 <code>history</code>。</li>
</ol>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<p>让我们帮助您进一步学习配置文件：</p>
<ol>
<li>为您的配置文件新建一个文件夹，并设置好版本控制</li>
<li>在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 <code>$PS1</code> 开始）。</li>
<li>建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个 shell 脚本对每个文件使用 <code>ln -s</code>，也可以使用<a href="https://dotfiles.github.io/utilities/">专用工具</a></li>
<li>在新的虚拟机上测试该安装脚本。</li>
<li>将您现有的所有配置文件移动到项目仓库里。</li>
<li>将项目发布到GitHub。</li>
</ol>
<h2 id="远端设备-1"><a class="header" href="#远端设备-1">远端设备</a></h2>
<p>进行下面的练习需要您先安装一个 Linux 虚拟机（如果已经安装过则可以直接使用），如果您对虚拟机尚不熟悉，可以参考<a href="https://hibbard.eu/install-ubuntu-virtual-box/">这篇教程</a> 来进行安装。</p>
<ol>
<li>前往 <code>~/.ssh/</code> 并查看是否已经存在 SSH 密钥对。如果不存在，请使用<code>ssh-keygen -o -a 100 -t ed25519</code>来创建一个。建议为密钥设置密码然后使用<code>ssh-agent</code>，更多信息可以参考 <a href="https://www.ssh.com/ssh/agent">这里</a>；</li>
<li>在<code>.ssh/config</code>加入下面内容：</li>
</ol>
<pre><code>Host vm
    User username_goes_here
    HostName ip_goes_here
    IdentityFile ~/.ssh/id_ed25519
    LocalForward 9999 localhost:8888
</code></pre>
<ol>
<li>使用 <code>ssh-copy-id vm</code> 将您的 ssh 密钥拷贝到服务器。</li>
<li>使用<code>python -m http.server 8888</code> 在您的虚拟机中启动一个 Web 服务器并通过本机的<code>http://localhost:9999</code> 访问虚拟机上的 Web 服务器</li>
<li>使用<code>sudo vim /etc/ssh/sshd_config</code> 编辑 SSH 服务器配置，通过修改<code>PasswordAuthentication</code>的值来禁用密码验证。通过修改<code>PermitRootLogin</code>的值来禁用 root 登录。然后使用<code>sudo service sshd restart</code>重启 <code>ssh</code> 服务器，然后重新尝试。</li>
<li>(附加题) 在虚拟机中安装 <a href="https://mosh.org/"><code>mosh</code></a> 并启动连接。然后断开服务器/虚拟机的网络适配器。mosh可以恢复连接吗？</li>
<li>(附加题) 查看<code>ssh</code>的<code>-N</code> 和 <code>-f</code> 选项的作用，找出在后台进行端口转发的命令是什么？</li>
</ol>
<h1 id="solution-命令行环境"><a class="header" href="#solution-命令行环境">Solution-命令行环境</a></h1>
<h2 id="任务控制-2"><a class="header" href="#任务控制-2">任务控制</a></h2>
<ol>
<li>
<p>我们可以使用类似 ps aux | grep 这样的命令来获取任务的 pid ，然后您可以基于pid 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 sleep 10000 这个任务。然后用 Ctrl-Z 将其切换到后台并使用 bg来继续允许它。现在，使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html">pgrep</a> 来查找 pid 并使用 <a href="http://man7.org/linux/man-pages/man1/pgrep.1.html">pkill</a> 结束进程而不需要手动输入pid。(提示：: 使用 -af 标记)。</p>
<pre><code>sleep 10000
Ctrl-Z
bg
</code></pre>
<pre><code>pgrep sleep #列出包含关键字 sleep 的进程的 pid
&gt;
# 76560
# 81186
# 81292
</code></pre>
<pre><code>pgrep sleep 10000 #列出包含关键字 sleep 的进程的 pid
&gt;
# 76560
# 81186
# 81292
</code></pre>
<pre><code>-a  Include process ancestors in the match list.  By default, the current pgrep or pkill process and all of its ancestors are excluded (unless -v is used).

-f  Match against full argument lists. The default is to match against process names.
</code></pre>
<p>使用<code>pkill --ns &lt;PID&gt;</code>来结束进程</p>
<pre><code>pkill  -af sleep
</code></pre>
</li>
<li>
<p>如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？ 在这个练习中，我们使用 sleep 60 &amp; 作为先执行的程序。一种方法是使用 wait 命令。尝试启动这个休眠命令，然后待其结束后再执行 ls 命令。</p>
<pre><code>sleep 60 &amp;
pgrep sleep | wait; ls
</code></pre>
<p>但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 <a href="https://www.man7.org/linux/man-pages/man1/wait.1p.html">wait</a> 只能对子进程起作用。之前我们没有提过的一个特性是，kill 命令成功退出时其状态码为 0 ，其他状态则是非0。kill -0 则不会发送信号，但是会在进程不存在时返回一个不为0的状态码。请编写一个 bash 函数 pidwait ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 sleep 来避免浪费 CPU 性能。</p>
<pre><code>pidwait()
{
   while kill -0 $1 #循环直到进程结束
   do
   sleep 1 
   done
   ls
}
</code></pre>
<p>需要注意的是，这里 while 判断的是命令行的返回值而不是布尔值，这个和其他语言有所区别。返回值 0 表示成功所以能够进入循环，参考<a href="https://unix.stackexchange.com/questions/185793/why-is-it-while-kill-0-pid-and-not-until-kill-0-pid">这个问题</a></p>
<pre><code>sleep 60 &amp; pidwait $(pgrep sleep 60)
[1] 554
[1]  + 554 done       sleep 60
pidwait:kill:2: kill 554 failed: no such process
buggy.sh     debug_for.sh html_root    out.log
debug.sh     html.zip     marco.sh
</code></pre>
</li>
</ol>
<h2 id="终端多路复用-2"><a class="header" href="#终端多路复用-2">终端多路复用</a></h2>
<ol>
<li>请完成这个 <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">tmux</a> 教程，并参考<a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">这些步骤</a>来学习如何自定义 tmux。</li>
</ol>
<h2 id="别名-2"><a class="header" href="#别名-2">别名</a></h2>
<ol>
<li>
<p>创建一个 dc 别名，它的功能是当我们错误的将 cd 输入为 dc 时也能正确执行。</p>
<pre><code>alias dc=cd
</code></pre>
</li>
<li>
<p>执行 <code>history | awk '{$1=&quot;&quot;;print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用history 1 替换 history。</p>
<pre><code>history | awk '{$1=&quot;&quot;;print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10
62 g++ -std=c++11 tests.cpp
64 npm run src:build
68 git pull
80 ./a.out
118 git status
186 ll
258 cd ..
263 git push
376 git add .
1066 ls
</code></pre>
</li>
</ol>
<h2 id="配置文件-1"><a class="header" href="#配置文件-1">配置文件</a></h2>
<p>让我们帮助您进一步学习配置文件：</p>
<p>为您的配置文件新建一个文件夹，并设置好版本控制 在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mord">1</span><span class="mord cjk_fallback">开始）。建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord cjk_fallback">脚本对每个文件使用</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">，也可以使用专用工具在新的虚拟机上测试该安装脚本。将您现有的所有配置文件移动到项目仓库里。将项目发布到</span><span class="mord mathnormal">G</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">。</span><span class="mord">‘‘‘</span><span class="mspace nobreak"> </span></span></span></span> mkdir ~/gits/dotfiles   # gits目录是创建用来存放所有git及github仓库的目录
~  git init ~/gits/dotfiles</p>
<h1 id="将本机的配置文件如-vimrcbashrctmuxconf-等复制进该目录"><a class="header" href="#将本机的配置文件如-vimrcbashrctmuxconf-等复制进该目录">将本机的配置文件，如 .vimrc/.bashrc/.tmux.conf 等复制进该目录</a></h1>
<p>~  ls -a ~/gits/dotfiles
.  ..  .bashrc  .git  .profile  .tmux.conf  .vimrc  .zshrc</p>
<h1 id="其中-分别表示本目录及上级目录git为git仓库的配置文件其他文件为存放在仓库中的系统配置文件"><a class="header" href="#其中-分别表示本目录及上级目录git为git仓库的配置文件其他文件为存放在仓库中的系统配置文件">其中，&quot;. ..&quot;分别表示本目录及上级目录，&quot;.git&quot;为git仓库的配置文件，其他文件为存放在仓库中的系统配置文件</a></h1>
<pre><code>
- 学习下一讲的git操作后，可以创建Github帐号，将这个仓库push到Github上
- 在另一台机器，或虚拟机上，将上面的Github仓库复制下来
    
    ```
     ~ &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8889em;vertical-align:-0.1944em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace nobreak&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; vim autoconfig.sh   # 创建脚本
     ~  cat autoconfig.sh
     #!/bin/bash
     files=(ls -a 1 | grep -E '.[^.]+' |grep -v .git)
     # 去掉 ls -a 返回结果中的 &quot;. .. .git&quot;
     for file in `echo files`; do
         ln -s $1/$file ~/$file # 创建软链接
     done
    
     ~ $ source autoconfig.sh 
     # 执行脚本，为dotfiles中的配置文件创建在主目录 ~ 下的软链接
    ```
    

## 远端设备

进行下面的练习需要您先安装一个 Linux 虚拟机（如果已经安装过则可以直接使用），如果您对虚拟机尚不熟悉，可以参考这篇教程 来进行安装。

1. 前往 ~/.ssh/ 并查看是否已经存在 SSH 密钥对。如果不存在，请使用`ssh-keygen -o -a 100 -t ed25519`来创建一个。建议为密钥设置密码然后使用ssh-agent，更多信息可以参考 这里；
    
    ```
    ssh-keygen -o -a 100 -t ed25519
    
    ls ~/.ssh
    config         id_ed25519     id_ed25519.pub known_hosts
    ```
    
2. 在.ssh/config加入下面内容：
    
    ```
    Host vm
       User username_goes_here
       HostName ip_goes_here
       IdentityFile ~/.ssh/id_ed25519
       LocalForward 9999 localhost:8888
    ```
    
    这里我的远端设备是树莓派，ssh 配置如下
    
    ```
    Host pi
       User pi
       HostName 192.168.50.56
       IdentityFile ~/.ssh/id_ed25519
       LocalForward 9999 localhost:8888
    ```
    
3. 使用 `ssh-copy-id vm` 将您的 ssh 密钥拷贝到服务器。
    
    ```
    ssh-copy-pi pi #拷贝秘钥
    ```
    
    随后可以直接使用`ssh pi`进行免密登录
    
4. 使用`python -m http.server 8888`在您的虚拟机中启动一个 Web 服务器并通过本机的`http://localhost:9999` 访问虚拟机上的 Web 服务器 这里我在树莓派上启动一个服务，并在 MacOS 上通过 ssh 端口转发进行访问。
    
    ```
    pi@raspberrypi:~$ python -m http.server 8888
    Serving HTTP on 0.0.0.0 port 8888 (http://0.0.0.0:8888/) ...
    ```
    
    ```
    curl localhost:9999
    ```
    
    ```
    pi@raspberrypi:~$ python -m http.server 8888
    Serving HTTP on 0.0.0.0 port 8888 (http://0.0.0.0:8888/) ...
    127.0.0.1 - - [15/May/2021 02:45:53] &quot;GET / HTTP/1.1&quot; 200 -
    ```
    
    ![1.png](https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions/images/5/1.png)
    
5. 使用`sudo vim /etc/ssh/sshd_config` 编辑 SSH 服务器配置，通过修改`PasswordAuthentication`的值来禁用密码验证。通过修改`PermitRootLogin`的值来禁用 root 登录。然后使用`sudo service sshd restart`重启 ssh 服务器，然后重新尝试。
    
    ```
    #注意是服务器的 sshd 配置
    pi@raspberrypi:~$ vim /etc/ssh/sshd_config
    ```
    
    修改：
    
    - `PasswordAuthentication`的值为 no
    - `PermitRootLogin`的值为 no 然后重启服务
        
        ```
        #for MacOS
         sudo launchctl stop com.openssh.sshd
         sudo launchctl start com.openssh.sshd
        ```
        
    
    下面提供的是虚拟机上的操作示例。
    
    - 在虚拟机上创建**root登录帐号** ([login as root](https://help.ubuntu.com/community/RootSudo#root_account))。注意：root登录 和 root用户 是不一样的
    
    ```
    ~ $ VBoxManage startvm &quot;ubuntu_server&quot; --type headless
    ~ $ ssh my_server
    # 使用ssh连接成功，跳转到虚拟机的终端
    my_server@myserver:~$ sudo su
    root@myserver:~# passwd root    # 输入密码，创建root登录帐号
    root@myserver:~# vim ~/etc/ssh/sshd_config
    # 查找到行&quot;#PermitRootLogin prohibit-password&quot;，使用 o 在下方新增一行
    # 输入&quot;PermitRootLogin yes&quot;
    
    root@myserver:~# service sshd restart   
    # 重启sshd服务，使刚才的修改生效
    root@myserver:~# exit
    my_server@myserver:~$ exit
    # 断开与虚拟机的ssh连接
    ```
    
    - 备注：sshd服务可能需要重启虚拟机，才能生效（可以直接在终端重启虚拟机，如下）
    
    ```
    ~ $ VBoxManage controlvm &quot;ubuntu_server&quot; poweroff
    ~ $ VBoxManage startvm &quot;ubuntu_server&quot; --type headless
    ```
    
    - 使用 root登陆 连接虚拟机
    
    ```
    ~ $ ssh root@192.168.1.9
    # 输入刚才设置的密码
    root@myserver:~# 
    ```
    
    - 重新配置sshd，禁用 root登录
    
    ```
    root@myserver:~# vim /etc/ssh/sshd_config
    # 查找到行&quot;#PasswordAuthentication yes&quot;，使用`o`在其下方新增一行
    # 输入&quot;PasswordAuthentication no&quot;
    # 查找到行&quot;PermitRootLogin yes&quot;，将 yes 修改为 no
    
    root@myserver:~# service sshd restart    
    root@myserver:~# exit
    my_server@myserver:~$ exit
    
    ~ $
    ```
    
    - 再次尝试 root登录
    
    ```
    ~ $ ssh root@192.168.1.9
    # 要求输入密码，可是输入密码后，仍会显示
    Permission denied, please try again.
    # 显示 3 次或更多次要求输入密码后，输出
    Permission denied (publickey,password)
    ~ $ 
    ~ $ ssh my_server
    my_server@myserver:~$   
    ```
    
    - 以上对于`PermitRootLogin`及`PasswordAuthentication`的修改，只影响 root登录方式，前面使用的`ssh my_server`登录方式不受影响
    - 总体而言，允许root登录，是有安全风险的，一般不建议使用。对于已创建的root登录方式，可删除：
    
    ```
    my_server@myserver:~$ sudo passwd -dl root
    ```
    
6. 附加题：在虚拟机中安装 mosh 并启动连接。然后断开服务器/虚拟机的网络适配器。mosh可以恢复连接吗？
    
    - 在虚拟机上安装mosh
        
        ```
        my_server@myserver:~$ sudo apt-get install mosh
        my_server@myserver:~$ mosh-server
        ```
        
    - 在终端使用mosh连接虚拟机
        
        ```
        ~ $ sudo apt install mosh
        ~ $ mosh my_server@196.168.1.9
        ```
        
    - 在VirtualBox管理器的最上方，“控制(M)”中选择“设置”，在“网络”选项中，将“连接方式”（默认是“桥接网卡”）改为“未指定”，即可断开网络适配器
    - 断开网络适配器后，无论使用ssh，还是mosh连接，都不能主动恢复连接（需要重新修改虚拟机的网络连接方式）
        - mosh在断开连接后，会有提示，告知：连接断开，在尝试重连
        - 重新连上网络适配器后，ssh或mosh连接都能恢复（而且断开后连接虚拟机输入的内容能继续显示），只是mosh的延迟稍微小一些
7. 附加题：查看ssh的-N 和 -f 选项的作用，找出在后台进行端口转发的命令是什么？
    
    ```
       -N      Do not execute a remote command.  This is useful for just forwarding ports.
    
       -f      Requests ssh to go to background just before command execution.  This is useful if ssh is going to ask for passwords or passphrases, but the user wants it in the background.  This implies -n.  The recommended way to start X11 programs at a remote site is with something like ssh -f host xterm.
    
       If the ExitOnForwardFailure configuration option is set to ``yes'', then a client started with -f will wait for all remote port forwards to be successfully established before placing itself in the background.
    ```
    
    - -N 就是不执行远端命令，适用于端口转发的情况
    - -f 是让 ssh 在执行命令前切换到后台运行
    
    后台进行端口转发
    
    ```
    ssh -fN -L 9999:localhost:8888 pi
    ```











# SSH开启（win10）

[SSH开启（win10）](https://zhuanlan.zhihu.com/p/391373172)


## 0 应用场景

一台win10电脑，在局域网下，通过ssh连接到另一台win10电脑

## 1 服务端开启

**1.1 开启开发人员模式**

开始 → 设置 → 更新和安全 →开发者选项 ，把开发人员模式的开关调到“开”

![](https://pic4.zhimg.com/80/v2-6edbfaf5c7f1671848a3050b674e44ab_1440w.webp)

**1.2 安装 OpenSSH服务器**

开始 → 设置 → 系统 →可选功能，确保已经装好OpenSSH服务器，一般来说默认安装OpenSSH客户端。如果没有安装，则需要在“添加功能”里搜到并安装。

![](https://pic4.zhimg.com/80/v2-51457a21a50298b0b51e7ed2462a8f13_1440w.webp)

打开此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;到path里面添加C:\Windows\System32\OpenSSH  
 
![](https://img-blog.csdnimg.cn/bcaa28517e264e8e850f87b43c2b426d.png)

![](https://img-blog.csdnimg.cn/ce0ebb6928a4477ca6c57dc59cb232b3.png)

 至此SSH环境变量在windows添加完成，最后重启电脑即可。


**1.3 检查SSH**

按下快捷键“win + R”，输入“cmd”

![](https://pic3.zhimg.com/80/v2-8e9b4b993be66aba37f89c6d34dfc882_1440w.webp)

在命令行中输入“ssh”,如果得到以下画面，代表成功安装。

```text
ssh
</code></pre>
<p><img src="https://pic1.zhimg.com/80/v2-9c52bb268a7dcbd5c5a119967a90016c_1440w.webp" alt="" /></p>
<p><strong>1.4 开启SSH服务</strong></p>
<p>在命令行中输入&quot;net start sshd&quot;</p>
<pre><code class="language-text">net start sshd
</code></pre>
<p>如果成功开启，则有</p>
<p><img src="https://pic1.zhimg.com/80/v2-f3b242108ae94d7f8f3f0069da95df2c_1440w.webp" alt="" /></p>
<p>也有可能开启失败，例如</p>
<p><img src="https://pic2.zhimg.com/80/v2-4a7f4b37c26d8849d60396e866a99f7d_1440w.webp" alt="" /></p>
<p>这是权限的问题，以管理员的身份操作即可。</p>
<p>右键屏幕左下方的“开始”，点击“Windows PowerShell(管理员)”</p>
<p>再输入&quot;net start sshd&quot;即可</p>
<p><img src="https://pic4.zhimg.com/80/v2-2984b97d7f061e86470e621b07a4515f_1440w.webp" alt="" /></p>
<p><strong>1.5 获取用户名和IP</strong></p>
<p>客服端通过SSH连接服务器，需要用到服务器的用户名和IP。</p>
<p>用户名获取：在CMD命令行上输入：“echo %username%”</p>
<pre><code class="language-text">echo %username%
</code></pre>
<p><img src="https://pic3.zhimg.com/80/v2-e13b257442a351b15b46e28ded839f0e_1440w.webp" alt="" /></p>
<p>获取IP：在CMD命令行上输入：&quot;ipconfig&quot;</p>
<pre><code class="language-text">ipconfig
</code></pre>
<p><img src="https://pic4.zhimg.com/80/v2-797c77b545f142025eefd6f735bc5ae3_1440w.webp" alt="" /></p>
<h2 id="2-客户端连接"><a class="header" href="#2-客户端连接">2 客户端连接</a></h2>
<p>在另一台win10电脑，在CMD命令行上输入：ssh 服务器用户名 @服务器IP，例如</p>
<p>用户名假如查到的是：Administrator</p>
<p>IP假如查到的是：192.168.0.177</p>
<pre><code class="language-text">ssh Administrator@192.168.0.177
</code></pre>
<p><img src="https://pic4.zhimg.com/80/v2-3695f9008bba0d60483817e2b6fca2ab_1440w.webp" alt="" /></p>
<p>输入服务器（win10电脑）的密码即可。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ba109e8c6f63ea8c7799f139bb4de892_1440w.webp" alt="" /></p>
<h2 id="3-关闭客户端"><a class="header" href="#3-关闭客户端">3 关闭客户端</a></h2>
<p>服务的开启和关闭不影响你使用ssh连接,只要你有OpenSSH客户端</p>
<pre><code class="language-bash">net start sshd # 开启ssh服务  (windows中)
net stop sshd # 关闭ssh服务  (windows中)   

logout             # linux中退出系统 (不想输入,直接Ctrl+D组合键也可)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="数据整理.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="版本控制Git.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="数据整理.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="版本控制Git.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
